{"pages":[{"title":"about","text":"这是关于的页面，可以在这里向世界介绍你！","link":"/about/index.html"},{"title":"photos","text":"","link":"/photos/index.html"}],"posts":[{"title":"Android中的IPC之Binder机制","text":"Android中的IPC机制即跨进程通信技术（Inter-Process-Comunicate），主要技术是 Android 的序列化机制和Binder。 Android 跨进程通信常见的几种方式；Bundle、文件共享、AIDL、Messenger、ContentProVider和Socket等。其中AIDL、Messenger、ContentProvider底层属于基于 Android Binder 机制实现的。 ##1. Android 多进程模式 关于开启多进程模式注意，android:process=&quot;:remote&quot; 与android:precess=&quot;com.xxx.xxx.remote&quot;指定Android 多进程方式的区别，进程名以”:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一进程，而进程名不以”:”开头的进程属于全局进程，其他应用通过 ShareUID 方式（签名也需相同）可以和它跑在同一个进程中。Android系统为每个应用分配一个唯一的 UUID，具有相同的 UUID 的应用才能共享数据。 多进程模式下会造成如下几方面的问题： 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPrefence 的可靠性下降（SharedPrefence 本质上是读写 xml 文件进行存储，并发操作会导致混乱） Application 多次创建 运行在同一个进程中的组件是属于同一个虚拟机和同一个 Application 的，同理，运行在不同进程中的组件是属于两个不同的虚拟机和 Application 的。 2. IPC基础概念介绍IPC基本概念主要包含三方面内容：Serializable 和Parcelable 接口以及 Binder。Serializable 和Parcelable 接口可以完成对象的序列化过程。通过序列化保证对象的持久化，可以使用 Intent 、Bundle 以及网络传递对象。 ###2.1 Serializable序列化 Serializable 实现序列化的过程主要通过下面的表示实现: 1private static final long serialVersionUID = 8711368828010083044L 序列化标识并不是必须的，系统会自动生成这个标识，但是当实现 Serializable 序列化接口的对象实体类结构发生变化，序列化标识也会重新赋值，这将对与反序列化过程有影响。 12345678910//序列化过程User user = new User(\"0\",\"jake\",true);ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"cache.txt\"));out.writeObject(user);out.close();//反序列化过程ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"cache.txt\"));User newUser = (User)int.readObject();in.close(); 需要注意的是 user 和 newUser 的内容相同，但不是同一个对象。关于 serialVersionUID 这个标识，只有序列化之前的对象的 serialVersionUID 值和序列化之后 serialVersionUID 值一致，才可以正常反序列化。实体类中成员数量和类型发生变化， serialVersionUID 值都会改变。一般来说我们手动指定 serialVersionUID 值，这样反序列化过程不会受到影响。如果不手动指定 serialVersionUID ，反序列化是当前类有所改变，比如增加或者删除了某些成员变量，那么系统就会重新计算当前类结的 hash 值并把它赋值给 serialVersionUID，这个时候当前类的serialVersionUID 就和序列化后的数据中的 serialVersionUID 不一致，于是反序列化失败。当我们手动指定了它以后，就可以很大程度上避免反序列化过程的失败，比如删除了某些成员变量或者增加了某些成员变量，数据仍然可以正常反序列化。不过如果类结构发生非常规性改变，比如修改类名，变量类型或者名称，即便指定了serialVersionUID，依然会反序列化失败。 2.2 Parcelable序列化Parcelable 是 Android 平台上提供的序列化方案，相对于 Serialable 大量的 IO 操作，拥有更好的性能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Book implements Parcelable { private int bookId; private String bookName; public Book() {} public Book(int bookId, String bookName) { this.bookId = bookId; this.bookName = bookName; } public int getBookId() { return bookId; } public void setBookId(int bookId) { this.bookId = bookId; } public String getBookName() { return bookName; } public void setBookName(String bookName) { this.bookName = bookName; } protected Book(Parcel in) { bookId = in.readInt(); bookName = in.readString(); } //当设置参数标签为out和inout时会要求重写这个方法 public void readFromParcel(Parcel in) { bookId = in.readInt(); bookName = in.readString(); } public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() { @Override public Book createFromParcel(Parcel in) { return new Book(in); } @Override public Book[] newArray(int size) { return new Book[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(bookId); dest.writeString(bookName); }} 3. Android进程通信之Binder机制###3.1 Messenger-进程间通信的信使 Messenger 根据 Handler 生成实例构造方法： 123456789101112131415161718192021222324//Messenger.java/** * Create a new Messenger pointing to the given Handler. Any Message * objects sent through this Messenger will appear in the Handler as if * {@link Handler#sendMessage(Message) Handler.sendMessage(Message)} had * been called directly. * * @param target The Handler that will receive sent messages. */public Messenger(Handler target) { mTarget = target.getIMessenger();}/** * Send a Message to this Messenger's Handler. * * @param message The Message to send. Usually retrieved through * {@link Message#obtain() Message.obtain()}. * * @throws RemoteException Throws DeadObjectException if the target * Handler no longer exists. */public void send(Message message) throws RemoteException { mTarget.send(message);} 通过 Handler 对象创建 Messenger，通过 Messenger#send(Message) 方法就可以跨进程传递信息。 12345678910111213141516171819202122232425//MainActivity.java private Messenger client = new Messenger(new MessengerHandler());private ServiceConnection serviceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { MainActivity.this.service = new Messenger(service); Message msg = Message.obtain(null, Contanstants.MSG_FROM_CLIENT); Bundle bundle = new Bundle(); bundle.putString(\"msg\", \"hello, this is client\"); msg.setData(bundle); //指定回复信使 msg.replyTo = client; try { MainActivity.this.service.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { }}; MainActivity 通过调用bindservice() 方法，获取IBinder 对象。看一下 Messenger 关于 IBinder 参数的构造方法： 123456789/** * Create a Messenger from a raw IBinder, which had previously been * retrieved with {@link #getBinder}. * * @param target The IBinder this Messenger should communicate with. */public Messenger(IBinder target) { mTarget = IMessenger.Stub.asInterface(target);} 上面是 clien 端向 service 端发送信息，再看一下关于 service 端处理 client 端的数据，并回复 client 端。上述代码我们在 Message 传递信息中指定了回复信使，看一下 service 端代码： 1234567891011121314151617181920212223242526272829//MessengerService.javaprivate Messenger mMessenger = new Messenger(new MessengerHandler());private static class MessengerHandler extends Handler { @Override public void handleMessage(Message msg) { if (msg.what == Contanstants.MSG_FROM_CLIENT) { Bundle bundle = msg.getData(); Log.d(TAG, bundle.getString(\"msg\")); Messenger clientMessenger = msg.replyTo; Message replyMsg = Message.obtain(null, Contanstants.MSG_FROM_SERVER); bundle.putString(\"msg\", \"this is server\"); replyMsg.setData(bundle); try { clientMessenger.send(replyMsg); } catch (RemoteException e) { e.printStackTrace(); } } else { super.handleMessage(msg); } }}@Nullable@Overridepublic IBinder onBind(Intent intent) { return mMessenger.getBinder();}} ###3.2 AIDL（android interface define launage） 关于基于 Binder 机制的 AIDL 以及 Messenger 概述：AIDL 文件在编译过程中会在 build 文件中生成对应的java文件，所以我们也可以通过写java文件来实现进程间通信。这里简单介绍一样 AIDL 文件对应java文件的结构以便于理解后续的概念： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public interface IBookManager extends android.os.IInterface { //... public static abstract class Stub extends android.os.Binder implements com.markzl.android.androidipc.entity.IBookManager { private static final java.lang.String DESCRIPTOR = \"com.markzl.android.androidipc.entity.IBookManager\"; /** * Construct the stub at attach it to the interface. */ public Stub() { this.attachInterface(this, DESCRIPTOR); } /** * Cast an IBinder object into an com.markzl.android.androidipc.entity.IBookManager interface, * generating a proxy if needed. * client端会调用该方法根据service端传回的IBinder对象生成IBookManager对象 */ public static com.markzl.android.androidipc.entity.IBookManager asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.markzl.android.androidipc.entity.IBookManager))) { return ((com.markzl.android.androidipc.entity.IBookManager) iin); } return new com.markzl.android.androidipc.entity.IBookManager.Stub.Proxy(obj); } /** * service端会将当前的binder通过@link{Service#OnBinder(Intent intent)}传递给client */ @Override public android.os.IBinder asBinder() { return this; } //... private static class Proxy implements com.markzl.android.androidipc.entity.IBookManager { //... } } public void addBookIn(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookInOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException;} 可以看到 client 端调用的IBookManager.Stub#asInterface()方法中，会先通过 binder 对象查询当前进程中的IBookManager 对象是否存在，不存在就走 Proxy 代理类。关于 Proxy 中如何处理跨进程通信，下面会结合AIDL定向标签来介绍。 ###3.3 关于 AIDL 中定向标签 in，out，inout 通过分析定向标签，我们同样可以学习到 AIDL 的基本原理。 12345678910// IBookManager.aidlpackage com.markzl.android.androidipc.entity;import com.markzl.android.androidipc.entity.Book;import com.markzl.android.androidipc.IOnNewBookAddedListener;interface IBookManager { void addBookIn(in Book book); void addBookOut(out Book book); void addBookInOut(inout Book book);} 生成的 java 文件： 123456789101112131415161718192021222324252627282930313233343536public interface IBookManager extends android.os.IInterface { //... public static abstract class Stub extends android.os.Binder implements com.markzl.android.androidipc.entity.IBookManager { //... @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { java.lang.String descriptor = DESCRIPTOR; switch (code) { //根据方法对应的code码处理相应数据 //... case TRANSACTION_addBookIn: //... break; case TRANSACTION_addBookOut: //... break; case TRANSACTION_addBookInOut: //... break; } } private static class Proxy implements com.markzl.android.androidipc.entity.IBookManager { //... static final int TRANSACTION_addBookIn = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBookOut = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); static final int TRANSACTION_addBookInOut = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2); } } public void addBookIn(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookInOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException;} 3.3.1 in 标签in 标签 client 端向 service 端写入数据，我们看一下生成的对应的 IBookManager.java 文件，其中用于跨进程处理数据的 IBookManager.Stub 内部私有 Proxy 类： 123456789101112131415161718192021222324252627282930313233//IBookManager.java private static class Proxy implements com.markzl.android.androidipc.entity.IBookManager { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } @Override public void addBookIn(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_addBookIn, _data, _reply, 0); _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } }} 可以看到 Proxy 中类将我们传入的实体序列化后，交给 mRemote#transact 方法处理，从 Proxy 类中可以看出，mRemote 是一个 IBinder 对象，在调用 Proxy 的构造方法时传入的是 Binder 的对象。 transact 方法是在IBinder 接口类中定义的，其实现类 Binder#transact 方法如下： 1234567891011121314151617/** * Default implementation rewinds the parcels and calls onTransact. On * the remote side, transact calls into the binder to do the IPC. */public final boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException { if (false) Log.v(\"Binder\", \"Transact: \" + code + \" to \" + this); if (data != null) { data.setDataPosition(0); } boolean r = onTransact(code, data, reply, flags); if (reply != null) { reply.setDataPosition(0); } return r;} 可以看到最终调用的方法是onTransact(code, data, reply, flags)，接下来我们看一下 onTransact 中方法如何处理序列化后的数据： 12345678910111213141516171819@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { //... switch (code) { //... case TRANSACTION_addBookIn: { data.enforceInterface(descriptor); com.markzl.android.androidipc.entity.Book _arg0; if ((0 != data.readInt())) { _arg0 = com.markzl.android.androidipc.entity.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.addBookIn(_arg0); reply.writeNoException(); return true; } }} onTransact() 方法中将序列化的数据重新反序列化成一个新的Book对象，然后调用service端的addBookIn()方法添加Book对象。注意这个过程是生成一个新的Book对象，具体为什么要注意生成新对象后面会讲到。这里总结一下in标签的作用向service传递数据但没有处理service的reply结果。 3.3.2 out标签同样首先看Proxy类中生成的addBookOut()方法： 12345678910111213141516@Overridepublic void addBookOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_addBookOut, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) { book.readFromParcel(_reply); } } finally { _reply.recycle(); _data.recycle(); }} 可以看到这里我们并没有处理 Book 对象，_data 始终没有写入 Book 对象，而且调用transact() 方法之后的_reply.readInt() 不等于0的时候，会重新从 _reply 中读取 book 实体。我们再来看一下调用的 onTransact() 方法中如何处理out标签： 1234567891011121314case TRANSACTION_addBookOut: { data.enforceInterface(descriptor); com.markzl.android.androidipc.entity.Book _arg0; _arg0 = new com.markzl.android.androidipc.entity.Book(); this.addBookOut(_arg0); reply.writeNoException(); if ((_arg0 != null)) { reply.writeInt(1); _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } return true;} out定向标签中是重新生成了一个新的 Book 对象，没有写入任何值。然后调用了addBook(Book book)方法，由此可知 service 并没有真正添加 client 传来的 Book 对象。 3.3.3 inout标签先看 Proxy#addBookInOut() ： 12345678910111213141516171819202122@Overridepublic void addBookInOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_addBookInOut, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) { book.readFromParcel(_reply); } } finally { _reply.recycle(); _data.recycle(); }} 在 _data 传入 book 序列化数据时和in标签同样的处理， _reply 的处理和 out 标签时保持一致。接着我们看一下 addBookInOut() 方法标签对应的 onTransact() 方法。 123456789101112131415161718case TRANSACTION_addBookInOut: { data.enforceInterface(descriptor); com.markzl.android.androidipc.entity.Book _arg0; if ((0 != data.readInt())) { _arg0 = com.markzl.android.androidipc.entity.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.addBookInOut(_arg0); reply.writeNoException(); if ((_arg0 != null)) { reply.writeInt(1); _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } return true;} 调用IBookManager#Stub实例对象通过 addBookInOut 方法添加由data反序列化后得到的Book对象。inout标签在某种意义上算得上是in和out标签的“并集”，目前并没有看出out和inout标签中的 _reply 值存在的意义。_reply在处理有返回值的方法使用如下: 1234567891011121314151617//Proxy#getBookList()@Overridepublic java.util.List&lt;com.markzl.android.androidipc.entity.Book&gt; getBookList() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.markzl.android.androidipc.entity.Book&gt; _result; try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.markzl.android.androidipc.entity.Book.CREATOR); } finally { _reply.recycle(); _data.recycle(); } return _result;} onTransact()中对于_reply赋值如下： 12345678//IBookManager.Stub#onTransact()case TRANSACTION_getBookList: { data.enforceInterface(descriptor); java.util.List&lt;com.markzl.android.androidipc.entity.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true;} 关于AIDL各种方法生成的详细内容都可以在build文件夹下生成对应java文件中看到。 3.4 service端数据改动时如何主动响应client端service数据有改动如何主动响应client端？这种情况类似View的setOnClickListener设置监听事件方法，当View被单击调用OnClickListener#onClick方法来做出相应处理，即事件回调。在之前的IBookManager添加如下接口： 123456//...interface IBookManager { //... void setOnBookAddedListener(OnBookAddedListener listener); void removeOnBookAddedListener(OnBookAddedListener listener);} 创建接口类OnBookAddedListener: 1234//OnBookAddedListener.aidlinterface OnBookAddedListener{ void onNewBookAdded();} 然后在service中实现如下： 12345678910111213141516171819202122232425262728public class BookService extends Service { private List&lt;Book&gt; mBookList = new ArrayList&lt;&gt;(); private List&lt;OnBookAddedListener&gt; mListenerList = new ArrayList&lt;&gt;(); IBookManager bookManager = new IBookManager.Stub() { //... @Override public void setOnBookAddedListener(OnBookAddedListener listener) throws RemoteException { mListenerList.add(listener); } @Override public void removeOnBookAddedListener(OnBookAddedListener listener) throws RemoteException { mListenerList.remove(listener); } }; @Nullable @Override public IBinder onBind(Intent intent) { //开启线程不断添加新书。然后遍历mListenerList， //调用OnBookAddedListener#onNewBookAdded()方法通知client端 new Thread(new AddBookWorker()).start(); return bookManager.asBinder(); } //...} 在client端与ServiceConnection#onServiceConnected()注册监听方法： 12345678910@Overridepublic void onServiceConnected(ComponentName name, IBinder service) { bookManager = IBookManager.Stub.asInterface(service); try { //listener中打印日志 bookManager.registerOnNewBookAddListener(listener); } catch (RemoteException e) { e.printStackTrace(); }} 在bindService()方法之后，当service端线程不断添加新书，我们可以正常打印新书添加日志信息，但是当我们调用removeOnBookAddedListener()方法时，打印日志信息并没有像我们期望的那样停止。这是因为client端进程中的OnBookAddedListener对象和service端的OnBookAddedListener对象不是同一个对象，正如我们在3.3.1末尾提到的一样。那么我们该如何在serice端和client操作同一个对象。这里系统为我们提供了RemoteCallbackList类，原理是通过键值对的形式保存OnBookAddedListener对象，使得我们添加和移除的是同一个对象。关于RemoteCallbackList的介绍： 12remoteCallbackList.register(listener);remoteCallbackList.unregister(listener); 其中RemoteCallbackList#register() 简单的概述如下（详情请阅读源码）: 1234IBinder binder = listener.asBinder();//...Callback cb = new Callback(listener, cookie);mCallbacks.put(binder, cb); 可以看出利用的是两个进程使用的是同一个Binder对象来作为key，通过client 端和service端相同key(binder)删除相应的listener。 3.5 关于Binder线程池的使用// 待续……","link":"/2019/06/16/AndroidIPC机制/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/06/14/hello-world/"},{"title":"Rxjava操作符：第1篇 Creating Observables","text":"参考文章：https://github.com/ReactiveX/RxJava/wiki/Creating-Observables 本文基于Rxjava 2.x版本,介绍用于创建 Observable 对象的操作符。 Operators that originate new Observables. Create — create an Observable from scratch by calling observer methods programmatically Defer — do not create the Observable until the observer subscribes, and create a fresh Observable for each observer Empty/Never/Throw — create Observables that have very precise and limited behavior From — convert some other object or data structure into an Observable Interval — create an Observable that emits a sequence of integers spaced by a particular time interval Just — convert an object or a set of objects into an Observable that emits that or those objects Range — create an Observable that emits a range of sequential integers Repeat — create an Observable that emits a particular item or sequence of items repeatedly Start — create an Observable that emits the return value of a function Timer — create an Observable that emits a single item after a given delay create 操作符通过 create 方法构造 Observable 对象，通过被观察者的 subcribe 方法建立起观察者与被观察者的联系。 create example 123456789Observable&lt;String&gt; observable = Observable.create(emitter -&gt; { emitter.onNext(\"Hello\"); emitter.onNext(\"World\"); emitter.onComplete(); emitter.onError(new NullPointerException());});observable.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(\"onComplete\")); defer 操作符一个允许延迟操作的操作符，直到 ObservableSource 订阅了观察者 Observer，发射源 emitting item 才会发射数据。defer会为每一个 Observer 观察者对象创建新的 Observable ，所以下面两次打印数据是不同的。而 create 操作符观察者对象无论被订阅多少次，数据都是相同的。 defer example 123456789Observable&lt;Long&gt; observable = Observable.defer(() -&gt; { long time = System.currentTimeMillis(); return Observable.just(time);});observable.subscribe(time -&gt; System.out.println(time));Thread.sleep(1000);observable.subscribe(time -&gt; System.out.println(time));//print 1562638410886 1562638411891 empty 操作符这个操作符会生成一个没有发射数据的 Observable 对象，只会且直接调用 Observer#onComplete 方法。 empty example 1234567Observable&lt;String&gt; empty = Observable.empty();empty.subscribe( v -&gt; System.out.println(\"This should never be printed!\"), error -&gt; System.out.println(\"Or this!\"), () -&gt; System.out.println(\"Done will be printed.\"));//print Done will be printed. never 操作符never 操作符不会调用观察者对象的 onNext、onComplete 或者 onError 方法，它主要用来测试或者禁用组合操作符中的某些 Observable 对象。 never example 123456Observable&lt;String&gt; never = Observable.never();never.subscribe( v -&gt; System.out.println(\"This should never be printed!\"), error -&gt; System.out.println(\"Or this!\"), () -&gt; System.out.println(\"This neither!\")); error 操作符error 操作符只会调用 Observer#error 方法，常见 error 使用场景： error example 123456789101112131415161718Observable&lt;String&gt; results = Observable.fromCallable((Callable&lt;String&gt;) () -&gt; { if (Math.random() &lt; 0.5) { throw new IOException(); } throw new IllegalArgumentException();}).onErrorResumeNext(error -&gt; { if (error instanceof IllegalArgumentException) { return Observable.empty(); } return Observable.error(error);});for (int i = 0; i &lt; 10; i++) { results.subscribe( v -&gt; System.out.println(\"This should never be printed!\"), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\"));} from 操作符fromIterable 操作符根据 Iterable （类似 List，Set，Collection 等） 对象创建可观察者模型。 fromIterable example 123456List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));Observable&lt;Integer&gt; observable = Observable.fromIterable(list);observable.subscribe(item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\")); fromArray 操作符根据数组创建可观察者模型。 123456789Integer[] array = new Integer[10];for (int i = 0; i &lt; array.length; i++) { array[i] = i;}Observable&lt;Integer&gt; observable = Observable.fromArray(array);observable.subscribe(item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\")); fromCallable 操作符当订阅事件发生，Callable中的方法会被调用，返回值会转发至观察者。 12345678910Callable&lt;String&gt; callable = () -&gt; { System.out.println(\"Hello World!\"); return \"Hello World!\";};Observable&lt;String&gt; observable = Observable.fromCallable(callable);observable.subscribe(item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\"));//print Hello World! Hello World! Done fromAction 操作符//待验证… 12345Action action = () -&gt; System.out.println(\"Hello World!\");Completable completable = Completable.fromAction(action);completable.subscribe(() -&gt; System.out.println(\"Done\"), error -&gt; error.printStackTrace()); fromRunnable 操作符//待验证… 12345Runnable runnable = () -&gt; System.out.println(&quot;Hello World!&quot;);Completable completable = Completable.fromRunnable(runnable);completable.subscribe(() -&gt; System.out.println(&quot;Done&quot;), error -&gt; error.printStackTrace()); fromFuture 操作符给定预先存在的，已经运行或已经完成的java.util.concurrent.Future，等待Future正常完成或以阻塞方式使用异常并将生成的值或异常转发给使用者。 123456789101112ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();//延迟1秒Future&lt;String&gt; future = executor.schedule(() -&gt; \"Hello world!\", 1, TimeUnit.SECONDS);Observable&lt;String&gt; observable = Observable.fromFuture(future);observable.subscribe( item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\"));executor.shutdown(); from{reactive type} 操作符//待验证… 12345678Flux&lt;Integer&gt; reactorFlux = Flux.fromCompletionStage(CompletableFuture.&lt;Integer&gt;completedFuture(1));Observable&lt;Integer&gt; observable = Observable.fromPublisher(reactorFlux);observable.subscribe( item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\")); generate 操作符//待验证… 12345678int startValue = 1;int incrementValue = 1;Flowable&lt;Integer&gt; flowable = Flowable.generate(() -&gt; startValue, (s, emitter) -&gt; { int nextValue = s + incrementValue; emitter.onNext(nextValue); return nextValue;});flowable.subscribe(value -&gt; System.out.println(value)); interval 操作符interval操作符指定定时发送发出数据的时间间隔，interval 有多个重载方法，最终都会调用下面的方法： 123456789101112131415/** * @param initialDelay 发射第一条数据的延迟时间 * @param period 其它数据的延迟发射周期 * @param unit 时间单位 * @param scheduler 任务调度器 */@CheckReturnValue@NonNull@SchedulerSupport(SchedulerSupport.CUSTOM)public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) { ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); return RxJavaPlugins.onAssembly(new ObservableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));} interval()的其它重载方法默认不设置 initialDleay 值时，initialDelay 的值将和 period 值保持一致，默认的调度器 Schedulers.computation()。在 java 中使用默认调度器的时候，interval 方法不会正常执行，程序会自动退出。interval 方法指定线程是未阻塞的，并不会阻止 JVM 退出程序。指定调度器 trampoline() 延长程序存活时间，interval 方法会正常执行。在Android中程序是在活跃的，不需要指定调度器。问题详情见 Rxjava issue interval example 12345678Observable&lt;Long&gt; clock = Observable.interval(1, TimeUnit.SECONDS, Schedulers.trampoline());clock.subscribe(time -&gt; { if (time % 2 == 0) { System.out.println(\"Tick\"); } else { System.out.println(\"Tock\"); }}); just 操作符根据 just 方法中顺序依次发射数据到下游观察者对象，just 方法可定义 1~9 个参数，但参数类型应保持一致。 just example 12345Observable&lt;Object&gt; observable = Observable.just(\"1\", \"A\", \"3.2\", \"def\"); observable.subscribe(item -&gt; System.out.print(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println());//print 1A3.2def range 操作符发出指定范围的整数队列值，调用的是 onNext 方法。 range example 123456789String greeting = \"Hello World!\";Observable&lt;Integer&gt; indexes = Observable.range(0, greeting.length());Observable&lt;Character&gt; characters = indexes .map(index -&gt; greeting.charAt(index));characters.subscribe(character -&gt; System.out.print(character), error -&gt; error.printStackTrace(), () -&gt; System.out.println()); timer 操作符timer(long, TimeUnit) 方法指定延迟时间发射出指定数据，不重复发出。 timer example 123Observable&lt;Long&gt; eggTimer = Observable.timer(5, TimeUnit.MINUTES);eggTimer.blockingSubscribe(v -&gt; System.out.println(&quot;Egg is ready!&quot;));","link":"/2019/06/18/第1篇 Creating Observables/"},{"title":"Rxjava操作符：第2篇 Transforming Observable","text":"参考文章 https://github.com/ReactiveX/RxJava/wiki/Transforming-Observables 本文基于Rxjava 2.x版本,介绍用于变换 Observable 对象的操作符。 Operators that transform items that are emitted by an Observable. Buffer — periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time 定期将Observable中的项目收集到包中并发出这些包，而不是一次发送一个项目 FlatMap — transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable 将Observable发出的项目转换为Observables，然后将这些项目的排放量变为单个Observable GroupBy — divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key 将一个Observable划分为一组Observable，每个Observable从原始Observable中发出一组不同的项目，按键组织 Map — transform the items emitted by an Observable by applying a function to each item 通过将函数应用于每个项目来转换Observable发出的项目 Scan — apply a function to each item emitted by an Observable, sequentially, and emit each successive value 将函数应用于Observable发出的每个项目，按顺序发出每个连续的值 Window — periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time 定期将Observable中的项目细分为Observable窗口并发出这些窗口，而不是一次发出一个项目 buffer 操作符 buffer 操作符是缓存多个 emiter.onNext 事件，一次发出。buffer 方法有多个重载方法，可以仔细阅读源码注释。Buffer 方法的返回值是 Observable&lt;List&lt;T&gt;&gt; 类型。 12345678Observable.range(0, 10) .buffer(4) .subscribe((List&lt;Integer&gt; buffer) -&gt; System.out.println(buffer));// prints:// [0, 1, 2, 3]// [4, 5, 6, 7]// [8, 9] cast 操作符将被观察者传递的数据转换成指定类型。注意使用 fliter 操作符过滤非指定类型数据，以避免 Java 类型转换错误 ClassCastException 。 1234567891011Observable&lt;Number&gt; numbers = Observable.just(1, 4.0, 3f, 7, 12, 4.6, 5);numbers.filter((Number x) -&gt; Integer.class.isInstance(x)) .cast(Integer.class) .subscribe((Integer x) -&gt; System.out.println(x));// prints:// 1// 7// 12// 5 concatMap 操作符ConcatMap 操作符还有很多扩展方法，concatMapCompletable、 concatMapCompletableDelayError、concatMapDelayError、 concatMapEager、concatMapEagerDelayError、concatMapIterable、 concatMapMaybe、concatMapMaybeDelayError、 concatMapSingle、concatMapSingleDelayError 等，这里主要介绍 concatMap 和 concatMapIterable 操作符。 ConcatMap 操作的是 Observable 对象，根据初始被观察者传递的数据转换成新的 Observable 向下传递。注意 ConcatMap 操作符是按照发射顺序执行的。 12345678Observable.range(0, 5) .concatMap(i -&gt; { long delay = Math.round(Math.random() * 2); return Observable.timer(delay, TimeUnit.SECONDS).map(n -&gt; i); }) .blockingSubscribe(System.out::print);// prints 01234 concatIterable 操作符concatIterable 操作符会将转换生成的 Iterable 列表数据中的每一项单独从发射源发出，且发射源数据是按照顺序发出的。 12345Observable.just(\"A\", \"B\", \"C\") .concatMapIterable(item -&gt; Arrays.asList(item,item,item)) .subscribe(System.out::println);//print AAABBBCCC flatMap 操作符作用和 concatMap 操作符类似。flatMap 操作符与 concatMap 操作符区别：flatMap 操作符不是按照发射顺序执行。这种操作符主要是需要通过源 Observable 数据 获取新的 Observable 数据时使用。例如从某请求地址获取到参数，然后根据获取到的参数请求另一地址获取最终我们需要的数据。 1234567891011121314151617Observable.just(\"A\", \"B\", \"C\") .flatMap(a -&gt; { return Observable.intervalRange(1, 3, 0, 1, TimeUnit.SECONDS) .map(b -&gt; '(' + a + \", \" + b + ')'); }) .blockingSubscribe(System.out::println);//打印顺序有可能不同//(A, 1)//(B, 1)//(C, 1)//(B, 2)//(A, 2)//(C, 2)//(B, 3)//(A, 3)//(C, 3) flatMapIterable 操作符作用和 concatMapIterable 操作符相同，会将 Iterable 列表中的值生成 Observable&lt;T&gt; 发射源。 123456789101112131415Observable.just(1, 2, 3, 4) .flatMapIterable(x -&gt; { switch (x % 4) { case 1: return Arrays.asList(\"A\"); case 2: return Arrays.asList(\"B\", \"B\"); case 3: return Arrays.asList(\"C\", \"C\", \"C\"); default: return Arrays.asList(); } }) .subscribe(System.out::print);//print ABBCCC groupBy 操作符类似 butter 操作符打包多个发射项目，但是是根据 group(key,value) 来分包的。注意groupBy操作符返回值类型是 Observable&lt;GroupedObservable&lt;K, V&gt;&gt; ，发射源 onNext方法中传递的将会是 GroupedObservable&lt;K, V&gt; 类型，而我们需要的值在每个 GroupeObservable 中，这里我们使用 concatMapSingle 操作符将每个中的数据合并生成新的 Single&lt;List&lt;T&gt;&gt; 向下传递。 123456789101112Observable&lt;String&gt; animals = Observable.just( \"Tiger\", \"Elephant\", \"Cat\", \"Chameleon\", \"Frog\", \"Fish\", \"Turtle\", \"Flamingo\");animals.groupBy(animal -&gt; animal.charAt(0), String::toUpperCase) .concatMapSingle(Observable::toList) .subscribe(System.out::println);//println//[TIGER, TURTLE]//[ELEPHANT]//[CAT, CHAMELEON]//[FROG, FISH, FLAMINGO] map 操作符直接操作发射数据，返回变换后的数据并向下游传递。 12345678Observable.just(1, 2, 3) .map(x -&gt; x * x) .subscribe(System.out::println);// prints:// 1// 4// 9 scan 操作符scan操作符实现的是一种类似累加器的功能，如下所示 partialSum 参数为之前发射数据的和。 1234567891011Observable.just(5, 3, 8, 1, 7) .scan(0, (partialSum, x) -&gt; partialSum + x) .subscribe(System.out::println);// prints:// 0// 5// 8// 16// 17// 24 window 操作符window 操作符作用和 buffer 类似，不过 window 方法的返回值是 Observable&lt;Observable&lt;T&gt;&gt; 对象，直接传递的是Observable&lt;T&gt; 对象，在订阅方法中打印的是 Observable 对象，而不是其中传递的值。通过 flatMap 方法或者其扩展方法，既可处理按照 window(connt , skip) 设置打包数据的传递。而 buffer 方法的操作符返回值类型是 Observable&lt;List&lt;T&gt;&gt;。 123456789101112131415Observable.range(1, 10) // Create windows containing at most 2 items, and skip 3 items before starting a new window. .window(2, 3) .flatMapSingle(window -&gt; { return window.map(String::valueOf) .reduce(new StringJoiner(\", \", \"[\", \"]\"), StringJoiner::add); }) .subscribe(System.out::println);// prints:// [1, 2] window 中 emitter.onNext(1); emitter.onNext(2);// [4, 5]// [7, 8]// [10] 按照参数指定的数据打包为 Observable&lt;T&gt; 对象，参数 Observable 中会调用 onNext 方法来处理每一个集合数据。因为参数类型为 Observable&lt;T&gt; , 所有订阅方法中 onNext 方法只会调用4次。","link":"/2019/06/19/第2篇 Transforming Observable/"},{"title":"Rxjava操作符：第3篇 Flitering Observable","text":"参考文章：https://github.com/ReactiveX/RxJava/wiki/Filtering-Observables本文基于Rxjava 2.x版本,介绍用于 Observable 过滤发射项目的操作符。 Operators that selectively emit items from a source Observable. Debounce — only emit an item from an Observable if a particular timespan has passed without it emitting another item 如果特定的时间跨度已经过去而没有发出另一个项目，则只从Observable中发出一个项目 Distinct — suppress duplicate items emitted by an Observable 过滤重复发射源 ElementAt — emit only item n emitted by an Observable 仅发出方法中指定的发射源 Filter — emit only those items from an Observable that pass a predicate test 仅发出符合过滤条件的发射源 First — emit only the first item, or the first item that meets a condition, from an Observable 仅保留发射序列的第一个发射源 IgnoreElements — do not emit any items from an Observable but mirror its termination notification 忽略发射序列的所有元素，只会响应 onComplete 方法 Last — emit only the last item emitted by an Observable 仅保留发射序列的最后一个发射源 Sample — emit the most recent item emitted by an Observable within periodic time intervals 取每个时间周期内的最后一个发射源。 Skip — suppress the first n items emitted by an Observable 跳过起始位置的 n 个发射源 SkipLast — suppress the last n items emitted by an Observable 跳过终点位置的 n 个发射源 Take — emit only the first n items emitted by an Observable 保留起始位置的 n 个发射源 TakeLast — emit only the last n items emitted by an Observable 保留终点位置的 n 个发射源 debounce 操作符当发射源 Emitter#onNext 方法发射间隔小于 debounce 方法指定间隔，取时间间隔有交集的最后一个发射源。在当前指定时间周期内只有一个发射源的时候，直接发出该发射源，如果指定时间周期出现多个发射源，取周期内最后一个发射源发出，其他的发射源过滤掉。根据下面的 debounce 图解可以得知，debounce 周期随发射源发出开始计算。注意和 sample 操作符区别 1234567891011121314151617181920212223242526272829303132333435363738// Diagram:// -A--------------B----C-D-------------------E-|----&gt;// a---------1s// b---------1s// c---------1s// d---------1s// e-|----&gt;// -----------A---------------------D-----------E-|--&gt;Observable&lt;String&gt; source = Observable.create(emitter -&gt; { emitter.onNext(\"A\"); Thread.sleep(1_500); emitter.onNext(\"B\"); Thread.sleep(500); emitter.onNext(\"C\"); Thread.sleep(250); emitter.onNext(\"D\"); Thread.sleep(2_000); emitter.onNext(\"E\"); emitter.onComplete();});source.subscribeOn(Schedulers.io()) .debounce(1, TimeUnit.SECONDS) .blockingSubscribe( item -&gt; System.out.println(\"onNext: \" + item), Throwable::printStackTrace, () -&gt; System.out.println(\"onComplete\"));// prints:// onNext: A// onNext: D// onNext: E// onComplete distinct 操作符过滤重复的发射项目 123456789Observable.just(2, 3, 4, 4, 2, 1) .distinct() .subscribe(System.out::println);// prints:// 2// 3// 4// 1 elementAt 操作符获取指定发射序列上某条数据 12345678910Observable&lt;Long&gt; source = Observable.&lt;Long, Long&gt;generate(() -&gt; 1L, (state, emitter) -&gt; { emitter.onNext(state); return state + 1L;}).scan((product, x) -&gt; product * x);Maybe&lt;Long&gt; element = source.elementAt(5);element.subscribe(System.out::println);// prints 720 filter 操作符过滤非函数判断指定的发射序列 12345678Observable.just(1, 2, 3, 4, 5, 6) .filter(x -&gt; x % 2 == 0) .subscribe(System.out::println);// prints:// 2// 4// 6 first 操作符取发射序列的第一个发射源，和 last 操作符对应。first 方法中参数为指定默认值。 123456Observable&lt;String&gt; source = Observable.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);Single&lt;String&gt; firstOrDefault = source.first(&quot;D&quot;);firstOrDefault.subscribe(System.out::println);// prints A ignoreElement 操作符忽略被观察者发射序列携带的数据，返回值为 Completable&lt;T&gt; ，只调用 onComplete 方法 12345678Observable&lt;Long&gt; source = Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS);Completable completable = source.ignoreElements();completable.doOnComplete(() -&gt; System.out.println(\"Done!\")) .blockingAwait();// prints (after 5 seconds):// Done! last 操作符去发射序列最后一个发射源，last 方法参数为默认值 123456Observable&lt;String&gt; source = Observable.just(\"A\", \"B\", \"C\");Single&lt;String&gt; lastOrDefault = source.last(\"D\");lastOrDefault.subscribe(System.out::println);// prints C sample 操作符从指定的时间周期中取最后一个发射源。与 debounce 操作符的区别是，sample 操作符的时间周期是独立的。 123456789101112131415161718192021222324252627282930313233// Diagram:// -A----B-C-------D-----E-|--&gt;// -0s-----c--1s---d----2s-|--&gt;// -----------C---------D--|--&gt;Observable&lt;String&gt; source = Observable.create(emitter -&gt; { emitter.onNext(\"A\"); Thread.sleep(500); emitter.onNext(\"B\"); Thread.sleep(200); emitter.onNext(\"C\"); Thread.sleep(800); emitter.onNext(\"D\"); Thread.sleep(600); emitter.onNext(\"E\"); emitter.onComplete();});source.subscribeOn(Schedulers.io()) .sample(1, TimeUnit.SECONDS) .blockingSubscribe( item -&gt; System.out.println(\"onNext: \" + item), Throwable::printStackTrace, () -&gt; System.out.println(\"onComplete\"));// prints:// onNext: C// onNext: D// onComplete skip 操作符指定从起始位置跳过 n 个发射源后继续发射 123456789101112Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.skip(4) .subscribe(System.out::println);// prints:// 5// 6// 7// 8// 9// 10 skipLast 操作符指定跳过终点位置的 n 个发射源 123456789101112Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.skipLast(4) .subscribe(System.out::println);// prints:// 1// 2// 3// 4// 5// 6 take 操作符和 skip 操作符相反操作，指定保留从起始位置发射的 n 个发射源 12345678910Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.take(4) .subscribe(System.out::println);// prints:// 1// 2// 3// 4 takeLast 操作符和 skipLast操作符相反，保留从终点位置发射的 n 个发射源 12345678910Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.takeLast(4) .subscribe(System.out::println);// prints:// 7// 8// 9// 10","link":"/2019/06/20/第3篇 Flitering Observables/"},{"title":"Rxjava操作符：第4篇 Combining Observables","text":"参考文章：https://github.com/ReactiveX/RxJava/wiki/Combining-Observables 本文基于Rxjava 2.x版本,介绍用于操作多个 Observable 对象的操作符。 Operators that work with multiple source Observables to create a single Observable And/Then/When — combine sets of items emitted by two or more Observables by means of Patternand Plan intermediaries CombineLatest — when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function Join — combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable Merge — combine multiple Observables into one by merging their emissions StartWith — emit a specified sequence of items before beginning to emit the items from the source Observable Switch — convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables Zip — combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function startWith操作符在 Observable 序列发送之前添加起始位置指定发送的 Observable startWith Example 1234Observable&lt;String&gt; names = Observable.just(\"Spock\", \"McCoy\");names.startWith(\"Kirk\").subscribe(item -&gt; System.out.println(item));// prints Kirk, Spock, McCoy merge 操作符merge 操作符 merge 操作符在用来合并多个 Observable 操作，合并的序列依次调用 Emitter#onNext() 方法执行，遇到错误序列将不继续执行。 merge Example 12345Observable.just(1, 2, 3) .mergeWith(Observable.just(4, 5, 6)) .subscribe(item -&gt; System.out.println(item));// prints 1, 2, 3, 4, 5, 6 mergeDelayError 操作符 和 merge 操作符类似，不过遇到错误会保存下来，等所有 Observable 执行完毕，再处理出现错误的Observable。注意 mergeDelayError 是静态泛型方法，只可以通过类名访问。 mergeDelayError Example 1234567Observable&lt;String&gt; observable1 = Observable.error(new IllegalArgumentException(\"\"));Observable&lt;String&gt; observable2 = Observable.just(\"Four\", \"Five\", \"Six\");Observable.mergeDelayError(observable1, observable2) .subscribe(item -&gt; System.out.println(item));// emits 4, 5, 6 and then the IllegalArgumentException (in this specific// example, this throws an `OnErrorNotImplementedException`). zip 操作符将多个 Observable 发射的数据合并起来，并生成一个Observable根据合并后的数据继续向下传递。onNext 方法只会调用一次。zip 、zipArray、zipIterable、zipWith zip Example 123456Observable&lt;String&gt; firstNames = Observable.just(\"James\", \"Jean-Luc\", \"Benjamin\");Observable&lt;String&gt; lastNames = Observable.just(\"Kirk\", \"Picard\", \"Sisko\");firstNames.zipWith(lastNames, (first, last) -&gt; first + \" \" + last) .subscribe(item -&gt; System.out.println(item));// prints James Kirk, Jean-Luc Picard, Benjamin Sisko zip 操作符 会将对应 Observable 对应的 Emitter onNext 的数据合并最后通过新生成的 Observable 发射调整后的数据。 combineLatest 操作符让两个 Obserable 序列按照最新发出的数据组合在一起生成一个 Observable 序列向下传递。 combineLatest Example 1234567891011121314151617Observable&lt;Long&gt; newsRefreshes = Observable.interval(100, TimeUnit.MILLISECONDS);Observable&lt;Long&gt; weatherRefreshes = Observable.interval(50, TimeUnit.MILLISECONDS);Observable.combineLatest(newsRefreshes, weatherRefreshes, (newsRefreshTimes, weatherRefreshTimes) -&gt; \"Refreshed news \" + newsRefreshTimes + \" times and weather \" + weatherRefreshTimes) .subscribe(item -&gt; System.out.println(item));// prints:// Refreshed news 0 times and weather 0// Refreshed news 0 times and weather 1// Refreshed news 0 times and weather 2// Refreshed news 1 times and weather 2// Refreshed news 1 times and weather 3// Refreshed news 1 times and weather 4// Refreshed news 2 times and weather 4// Refreshed news 2 times and weather 5// ... switchOnNext 操作符switchOnNext Example 12345678910111213141516171819202122Observable&lt;Observable&lt;String&gt;&gt; timeIntervals = Observable.interval(1, TimeUnit.SECONDS) .map(ticks -&gt; Observable.interval(100, TimeUnit.MILLISECONDS) .map(innerInterval -&gt; \"outer: \" + ticks + \" - inner: \" + innerInterval));Observable.switchOnNext(timeIntervals) .subscribe(item -&gt; System.out.println(item));// prints:// outer: 0 - inner: 0// outer: 0 - inner: 1// outer: 0 - inner: 2// outer: 0 - inner: 3// outer: 0 - inner: 4// outer: 0 - inner: 5// outer: 0 - inner: 6// outer: 0 - inner: 7// outer: 0 - inner: 8// outer: 1 - inner: 0// outer: 1 - inner: 1// outer: 1 - inner: 2// outer: 1 - inner: 3// ...","link":"/2019/06/21/第4篇 Combining Observables/"},{"title":"Android预览pdf文档","text":"谷歌为我们提供了PdfRender工具类对pdf文档进行渲染，首先看一下PdfRender的构造方法： 123456789101112131415161718192021222324/** * Creates a new instance. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; The provided file descriptor must be &lt;strong&gt;seekable&lt;/strong&gt;, * i.e. its data being randomly accessed, e.g. pointing to a file. * &lt;/p&gt; * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; This class takes ownership of the passed in file descriptor * and is responsible for closing it when the renderer is closed. * &lt;/p&gt; * &lt;p&gt; * If the file is from an untrusted source it is recommended to run the renderer in a separate, * isolated process with minimal permissions to limit the impact of security exploits. * &lt;/p&gt; * * @param input Seekable file descriptor to read from. * * @throws java.io.IOException If an error occurs while reading the file. * @throws java.lang.SecurityException If the file requires a password or * the security scheme is not supported. */public PdfRenderer(@NonNull ParcelFileDescriptor input){ //略...} 可以看构造方法中的参数是ParcelFileDescriptor的一个实例，那么ParcelFileDescriptor类是做什么的呢？ParcelFileDescriptor是Android提供的一种数据结构，支持数据的写入和写出。我们通过ParcelFileDescriptor#open生成ParcelFileDescriptor对象： 1234567891011121314151617181920/** * Create a new ParcelFileDescriptor accessing a given file. * * @param file The file to be opened. * @param mode The desired access mode, must be one of * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or * {@link #MODE_READ_WRITE}; may also be any combination of * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE}, * {@link #MODE_WORLD_READABLE}, and * {@link #MODE_WORLD_WRITEABLE}. * @return a new ParcelFileDescriptor pointing to the given file. * @throws FileNotFoundException if the given file does not exist or can not * be opened with the requested mode. * @see #parseMode(String) */ public static ParcelFileDescriptor open(File file, int mode) throws FileNotFoundException { final FileDescriptor fd = openInternal(file, mode); if (fd == null) return null; return new ParcelFileDescriptor(fd); } 从该方法中可以看出ParcelFileDescriptor#open实际操作的是FileDescriptor，仔细阅读FileDescriptor的注释，FileDescriptor是文件操作符。FileDescriptor可以用来表示开放文件、开放套接字。以FileDecriptor表示文件来说，当FileDescroptor表示某文件 时，我们可以通俗的将FileDescriptor看成是该文件。但是，我们不能直接通过FileDescription对该文件进行操作；若需要通过FileDescriptor对该文件进行操作，则需要新创建FileDescriptor对应的FileOutputSteam，再对文件进行操作。这里有对FileDescription的详细描述。 12345678 ParcelFileDescriptor mFileDescriptor; PdfRenderer mPdfRenderer; //根据文件对象创建mFileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY); // This is the PdfRenderer we use to render the PDF. if (mFileDescriptor != null) { mPdfRenderer = new PdfRenderer(mFileDescriptor); } 打开pdf指定页面和生成当前页面的Bitmap展示： 12345678910111213141516171819202122private PdfRenderer.Page mCurrentPage;private void showPage(int index) { if (mPdfRenderer.getPageCount() &lt;= index) { return; } // Make sure to close the current page before opening another one. if (null != mCurrentPage) { mCurrentPage.close(); } // Use `openPage` to open a specific page in PDF. mCurrentPage = mPdfRenderer.openPage(index); // Important: the destination bitmap must be ARGB (not RGB). Bitmap bitmap = Bitmap.createBitmap(mCurrentPage.getWidth(), mCurrentPage.getHeight(),Bitmap.Config.ARGB_8888); // Here, we render the page onto the Bitmap. // To render a portion of the page, use the second and third parameter. Pass nulls to get // the default result. // Pass either RENDER_MODE_FOR_DISPLAY or RENDER_MODE_FOR_PRINT for the last parameter. mCurrentPage.render(bitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY); // We are ready to show the Bitmap to user. mImageView.setImageBitmap(bitmap); updateUi();} 渲染pdf代码，pdf文档来源于assets目录下","link":"/2019/06/14/android/Android预览pdf文档/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","link":"/tags/Android开发艺术探索/"},{"name":"Rxjava操作符","slug":"Rxjava操作符","link":"/tags/Rxjava操作符/"},{"name":"Android","slug":"Android","link":"/tags/Android/"}],"categories":[{"name":"Android开发艺术探索笔记","slug":"Android开发艺术探索笔记","link":"/categories/Android开发艺术探索笔记/"},{"name":"Rxjava笔记","slug":"Rxjava笔记","link":"/categories/Rxjava笔记/"},{"name":"Android开发笔记","slug":"Android开发笔记","link":"/categories/Android开发笔记/"}]}