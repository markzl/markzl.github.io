{"pages":[{"title":"about","text":"这是关于的页面，可以在这里向世界介绍你！","link":"/about/index.html"},{"title":"photos","text":"","link":"/photos/index.html"}],"posts":[{"title":"Android混淆手册","text":"只有在与代码压缩（混淆）相配合使用时，资源压缩才能发挥作用。代码压缩器移除所有未使用的代码后，资源压缩器便可确定应用仍然使用的资源有哪些。当您添加包含资源的代码库时尤其如此 - 您必须移除未使用的库代码，使库资源变为未引用资源，因而可由资源压缩器移除。 1234567891011android { ... buildTypes { release { shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } } 混淆文件模版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#---------------------------------1.实体类---------------------------------# 保留实体类和成员不被混淆-keep public class com.android.example.entity.** { *;}#-------------------------------------------------------------------------#---------------------------------2.第三方包-------------------------------#-------------------------------------------------------------------------#---------------------------------3.与js互相调用的类------------------------# 保留JS方法不被混淆-keepclassmembers class com.example.xxx.MainActivity$JSInterface1 { &lt;methods&gt;;}#-------------------------------------------------------------------------#---------------------------------4.反射相关的类和方法-----------------------#----------------------------------------------------------------------------############################################### 对于一些基本指令的添加,不需要修改############################################### 代码混淆压缩比，在0和7之间，默认为5，一般不需要改-optimizationpasses 5#这个是给Microsoft Windows用户的，因为ProGuard假定使用的操作系统是能区分两个只是大小写不同的文件名，但是Microsoft Windows不是这样的操作系统，所以必须为ProGuard指定-dontusemixedcaseclassnames选项# 混淆时不使用大小写混合，混淆后的类名为小写-dontusemixedcaseclassnames#用于告诉ProGuard，不要跳过对非公开类的处理。默认情况下是跳过的，因为程序中不会引用它们，有些情况下人们编写的代码与类库中的类在同一个包下，并且对包中内容加以引用，此时需要加入此条声明。# 指定不去忽略非公共的库的类-dontskipnonpubliclibraryclasses# 指定不去忽略非公共的库的类的成员-dontskipnonpubliclibraryclassmembers# 不做预校验，preverify是proguard的4个步骤之一# Android不需要preverify，去掉这一步可加快混淆速度-dontpreverify# 有了verbose这句话，混淆后就会生成映射文件# 包含有类名-&gt;混淆后类名的映射关系# 然后使用printmapping指定映射文件的名称-verbose-printmapping proguardMapping.txt# 指定混淆时采用的算法，后面的参数是一个过滤器# 这个过滤器是谷歌推荐的算法，一般不改变-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*# 保护代码中的Annotation不被混淆，这在JSON实体映射时非常重要，比如fastJson-keepattributes *Annotation*,InnerClasses# 避免混淆泛型，这在JSON实体映射时非常重要，比如fastJson-keepattributes Signature#抛出异常时保留代码行号，在异常分析中可以方便定位-keepattributes SourceFile,LineNumberTable############################################### Android开发中一些需要保留的公共部分############################################### 保留了继承自Activity、Application这些类的子类# 因为这些子类，都有可能被外部调用# 比如说，第一行就保证了所有Activity的子类不要被混淆-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService# androidx混淆配置-keep class com.google.android.material.** {*;}-keep class androidx.** {*;}-keep public class * extends androidx.**-keep interface androidx.** {*;}-dontwarn com.google.android.material.**-dontnote com.google.android.material.**-dontwarn androidx.**# 保留 support 下的所有类及其内部类-keep class android.support.** { *; }# 保留继承的-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.**# 保留在Activity中的方法参数是view的方法，# 从而我们在layout里面编写onClick就不会被影响-keepclassmembers class * extends android.app.Activity { public void *(android.view.View);}# 对于带有回调函数onXXEvent的，不能被混淆-keepclassmembers class * { void *(**On*Event); void *(**On*Listener);}# 保留自定义控件（继承自View）不被混淆-keep public class * extends android.view.View { *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);}-keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);}# 保留所有的本地native方法不被混淆-keepclasseswithmembernames class * { native &lt;methods&gt;;}# 枚举类不能被混淆-keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String);}# 保留Parcelable序列化的类不被混淆-keep class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator *;}# 保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();}# 对于R（资源）下的所有类及其方法，都不能被混淆-keep class **.R$* { *;}#-------------------------webview(项目中没有使用可以忽略)-------------------------------keepclassmembers class fqcn.of.javascript.interface.for.Webview { public *;}-keepclassmembers class * extends android.webkit.WebViewClient { public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);}-keepclassmembers class * extends android.webkit.WebViewClient { public void *(android.webkit.WebView, jav.lang.String);}# ----------------------------- 其他的 -----------------------------## 删除代码中Log相关的代码-assumenosideeffects class android.util.Log { public static boolean isLoggable(java.lang.String, int); public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...);}# 保持测试相关的代码-dontnote junit.framework.**-dontnote junit.runner.**-dontwarn android.test.**-dontwarn android.support.test.**-dontwarn org.junit.** Keep 配置 保留 防止被移除或者被重命名 防止被重命名 类和类成员 -keep -keepnames 仅类成员 -keepmembers -keepmembernames 如果拥有某成员，保留类和类成员 -keepclasseswithmembers -keepclasseswithmembernames 如果不确定自己该用哪个的话，就用 -keep，它能保证匹配的类在压缩这一阶段不被移除，并且在混淆阶段不会被重新命名。 如果只声明保护一个类，并没有指定受保护的成员。proguard只会保护它的类名和它的无参构造函数。其它。其它成员依旧会被压缩、优化、混淆。 如果声明保护一个方法，proguard会把它当作程序的入口点，方法名不会变，它里面的方法依旧会被优化、混淆。 Proguard 常用通配符 Proguard 通配符 描述 &lt;field&gt; 匹配类中的所有字段 &lt;method&gt; 匹配类中的所有方法 &lt;init&gt; 匹配类中所有的构造函数 * 匹配任意长度字符，不包含包名分割符 (.) ** 匹配任意长度字符，包含包名分隔符 (.) … … 常用自定义混淆规则 混淆类相关规则 1234567891011121314151617//不混淆某个包下所有的类-keep public class com.android.example.** { *; }//不混淆所有类名中包含了\"model\"的类及成员-keep public class **.*model*.** {*;}//不混淆某个类-keep public class com.android.example.Test { *; }//不混淆某个类下的内部类-keep public class com.android.example.Text$* { *; }//不混淆某个类的子类-keep public class * extends com.android.example.Test { *; }//不混淆某个接口的实现类-keep public class * implements com.android.example.MyInterface {*;} 混淆构造方法和普通方法规则 12345678910111213141516// 不混淆构造方法-keep public class com.android.example.Test{ public &lt;init&gt;();}// 不混淆带String类型参数构造方法-keep public class com.android.example.Test{ public &lt;init&gt;(java.lang.String)}//不混淆某个类中指定方法-keep public class com.android.example.Test{ public void test();}//不混淆某个类中的所有静态方法-keep public class com.android.example.Test{ public static &lt;method&gt;;} 混淆之后打包会在/build/outputs/mapping/release路径下生成 mapping.txt ，使用 AndroidStudio 的 Analyze APK 分析工具可以通过解析此文件反编译后得到混淆之前的源文件。也可以通过 Bugly 中的上传符号表配置上传 mapping 文件，方便我们查看混淆之前的异常。","link":"/2018/11/20/Android混淆手册/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2016/10/16/hello-world/"},{"title":"Android的Handler消息机制分析","text":"Handler的介绍中出现最多的关键字，Looper，ThreadLocal，MessageQueue。 在工作线程的 handler#sendMessage 方法实际上是向主线程即UI线程的消息队列插入消息，通过ActivityThread初始化Looper对象，并通过Looper.looper方法循环查询消息队列的新消息。 分析Handler消息机制我们先从 Handler#sendMessage() 方法来分析，先看一下sendMessage()方法最终会调用的方法，如下所示： 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis);} 先大概看下这个方法的作用，就是向 MessageQueue 消息队列中插入一条消息。这里我们先不分析enqueueMessage() 方法，我们先来看一下 Handler 中的 MessageQueue 何时初始化的。 1234567891011121314151617181920public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;} 可以看到 mQueue 是在 Handler 的构造方法中初始化的，而 mQueue 来自于 Looper 对象，一步步分析，我们接着分析 Looper对象，即 mLooper = Looper.myLooper() 点击 myLooper() 方法我们可以看到： 1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static @Nullable Looper myLooper() { return sThreadLocal.get();} 到这里 Handler 中的三个关键点MessageQueue 、Looper 、ThreadLocal都出现了，现在我们要分析的 sThreadLocal.get() 从哪里获取 Looper 对象。先简单介绍一下ThreadLocal类：保存线程中的变量，仅当线程存活的时候才可以获取到该变量。现在要看一下哪里调用 ThreadLocal.set(Looper) 方法，如下所示： 123456private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed));} 我们都知道Activity在创建过程中，ActivityThread 的main方法中会调用 Looper.prepareMainLooper() 方法，这里的执行过程中还有一个关键的方法Looper.loop()，这个我们下面分发消息的时候会介绍。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); // Find the value for {@link #PROC_START_SEQ_IDENT} if provided on the command line. // It will be in the format \"seq=114\" long startSeq = 0; if (args != null) { for (int i = args.length - 1; i &gt;= 0; --i) { if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) { startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); } } } ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");} 最终会调用上面提到的 prepare(boolean quitAllowed) 方法。到这里我们只把只把几个关键点何时创建介绍了一下。接下来介绍Handler传递消息的过程。还是接着 sendMessageAtTime(Message msg, long uptimeMillis)方法分析，注意这里的 msg.target 为Handler对象。上面讲到 sendMessage 会通过 enqueueMessage(queue, msg, uptimeMillis) 向我们的消息队列插入消息，Message为单向链表，根据消息处理时间来判断链表的添加顺序，该方法如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(\"Message must have a target.\"); } if (msg.isInUse()) { throw new IllegalStateException(msg + \" This message is already in use.\"); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true;} 最后通过 Looper#looper 循环从 MessageQueue 中取消息: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start' final int thresholdOverride = SystemProperties.getInt(\"log.looper.\" + Process.myUid() + \".\" + Thread.currentThread().getName() + \".slow\", 0); boolean slowDeliveryDetected = false; for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) { logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); } final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) { slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; } final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; try { msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } if (logSlowDelivery) { if (slowDeliveryDetected) { if ((dispatchStart - msg.when) &lt;= 10) { Slog.w(TAG, \"Drained\"); slowDeliveryDetected = false; } } else { if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, \"delivery\", msg)) { // Once we write a slow delivery log, suppress until the queue drains. slowDeliveryDetected = true; } } } if (logSlowDispatch) { showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, \"dispatch\", msg); } if (logging != null) { logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); } msg.recycleUnchecked(); }} msg.target.dispatchMessage(msg) 的处理方法最终是调用 Handler#dispatchMessage 方法，如下所示： 123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }} 讲到这里我们不但看出最后是走到我们覆盖的 handleMessage(msg) 方法中，而且看到有个 msg.callback 判断，这个callback是什么？callback 为 Runable 的实例，这也就解释了为什么 Handler#post(Runable()) 方法最终是在UI线程中处理的。如果不理解的话，看一下Handler的post方法就知道了。 123public final boolean post(Runnable r){ return sendMessageDelayed(getPostMessage(r), 0);}","link":"/2019/10/22/Android开发笔记/Android的Handler消息机制分析/"},{"title":"Android okhttp使用详解","text":"Get 请求1234567Request request = new Request.Builder() .url(url) .build();OkHttpClient client = new OkHttpClient();try (Response response = client.newCall(request).execute()) { return response.body().string();} 通过Request构建请求体，然后由 client 执行。这里 Request 默认请求类型是Get。注意这个是SynchronousGet是同步执行的。在Android UI线程直接运行会报错提示：==android.os.NetworkOnMainThreadException==。 异步Get请求 AsynchronousGet1234567891011121314Request request = new Request.Builder() .url(\"http://publicobject.com/helloworld.txt\") .build();client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { e.printStackTrace(); } @Override public void onResponse(Call call, Response response) throws IOException { try (ResponseBody responseBody = response.body()) { System.out.println(responseBody.string()); } }}); 异步请求会在Android 中开启一个线程队列，在子线程中运行，不影响Android UI 线程。注意的是Callback类回调仍然执行在子线程中，需要通过handler处理UI线程相关操作。 Post 请求注意下述代码中演示的同步请求，通过client.newCall(request).enqueue(Callback)可以进行异步请求 Post 提交 json 请求体123456789101112MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");RequestBody body = RequestBody.create(JSON, json);OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(url) .post(body) .build();try (Response response = client.newCall(request).execute()) { return response.body().string();} 根据string类型的json字符串请求请求体，通过post(ReqeustBody)方法请求数据。 Post 提交 String 请求体注意创建的MediaType类型，MediaType类型根据自己需求创建。这里定义为markdown类型： 12345678910111213MediaType MEDIA_TYPE_MARKDOWN = MediaType.get(\"text/x-markdown; charset=utf-8\");OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(\"https://api.github.com/markdown/raw\") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)) .build();try (Response response = client.newCall(request).execute()) { if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string());} Post 提交Form表单（FormBody）12345678910111213RequestBody formBody = new FormBody.Builder() .add(\"md5\", \"12232\") .build();Request request = new Request.Builder() .url(\"http://221.130.29.94:8090/bookQr/test/isUpload\") .post(formBody) .build();try (Response response = client.newCall(request).execute()) { if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string());} Post 提交File文件12345678910111213MediaType MEDIA_TYPE_MARKDOWN= MediaType.get(\"text/x-markdown; charset=utf-8\");OkHttpClient client = new OkHttpClient();File file = new File(\"README.md\");Request request = new Request.Builder() .url(\"https://api.github.com/markdown/raw\") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)) .build();try (Response response = client.newCall(request).execute()) { if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string());} Post 提交多种类型文件（MultiPartBody）123456789101112131415161718MediaType MEDIA_TYPE_PNG = MediaType.get(\"image/png\");RequestBody requestBody = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(\"title\", \"Square Logo\") .addFormDataPart(\"image\", \"logo-square.png\", RequestBody.create(MEDIA_TYPE_PNG, new File(filePath))) .build();OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(\"https://api.imgur.com/3/image\") .post(requestBody) .build();try (Response response = client.newCall(request).execute()) { if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string());} ##访问请求头内容（Acessing Header） 1234567891011121314Request request = new Request.Builder() .url(\"https://api.github.com/repos/square/okhttp/issues\") .header(\"User-Agent\", \"OkHttp Headers.java\") .addHeader(\"Accept\", \"application/json; q=0.5\") .addHeader(\"Accept\", \"application/vnd.github.v3+json\") .build();OkHttpClient client = new OkHttpClient();try (Response response = client.newCall(request).execute()) { if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(\"Server: \" + response.header(\"Server\")); System.out.println(\"Date: \" + response.header(\"Date\")); System.out.println(\"Vary: \" + response.headers(\"Vary\"));} Request.Builder#header()和Request.Builder#addHeader()区别，header()方法添加的key只有一个，多次添加改变value值，addHeader() 会为当前key再添加一个值。对于Response#header()和Response#headers()区别：header()方法会打印对于key出现的最后一次值，而headers()会将对应key的所有值列出来。 okhttp拦截器 - Interceptor##添加应用拦截器 123OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(new LoggingInterceptor()) .build(); 如何实现自定义拦截器，我们需要实现系统提供的 Interceptor 接口： 1234567891011121314private static class LoggingInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { long t1 = System.nanoTime(); Request request = chain.request(); logger.info(String.format(\"Sending request %s on %s%n%s\", request.url(), chain.connection(), request.headers())); Response response = chain.proceed(request); long t2 = System.nanoTime(); logger.info(String.format(\"Received response for %s in %.1fms%n%s\", request.url(), (t2 - t1) / 1e6d, response.headers())); return response; }} 当我们发起网络请求，打印日志如下,request#headers()值为空： 123456789101112Sending request http://www.publicobject.com/helloworld.txt on nullUser-Agent: OkHttp SampleReceived response for http://www.publicobject.com/helloworld.txt in 2957.8msServer: nginx/1.10.0 (Ubuntu)Date: Mon, 01 Jul 2019 02:52:58 GMTContent-Type: text/plainContent-Length: 1759Last-Modified: Tue, 27 May 2014 02:35:47 GMTConnection: keep-aliveETag: \"5383fa03-6df\"Accept-Ranges: bytes ##添加网络拦截器 添加网络拦截器如下所示： 123OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new LoggingInterceptor()) .build(); 打印日志信息： 1234567891011121314151617181920212223242526272829Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=www.publicobject.com/54.187.32.157:80 cipherSuite=none protocol=http/1.1}User-Agent: OkHttp SampleHost: www.publicobject.comConnection: Keep-AliveAccept-Encoding: gzipReceived response for http://www.publicobject.com/helloworld.txt in 271.5msServer: nginx/1.10.0 (Ubuntu)Date: Mon, 01 Jul 2019 02:54:12 GMTContent-Type: text/htmlContent-Length: 194Connection: keep-aliveLocation: https://publicobject.com/helloworld.txtSending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=publicobject.com/54.187.32.157:443 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 protocol=http/1.1}User-Agent: OkHttp SampleHost: publicobject.comConnection: Keep-AliveAccept-Encoding: gzipReceived response for https://publicobject.com/helloworld.txt in 176.9msServer: nginx/1.10.0 (Ubuntu)Date: Mon, 01 Jul 2019 02:54:13 GMTContent-Type: text/plainContent-Length: 1759Last-Modified: Tue, 27 May 2014 02:35:47 GMTConnection: keep-aliveETag: \"5383fa03-6df\"Accept-Ranges: bytes 网络拦截器打印了两次日志信息，第一个地址是http://www.publicobject.com/helloworld.txt,第二个地址是https://publicobject.com/helloworld.txt。 Application interceptors（应用拦截器） 不必担心中间的responses，例如重定向和重连。 总是调用一次，即使是从缓存HTTP响应。 观察应用程序的原始意图。不关心OkHttp的注入headers，例如If-None-Match 允许短路和不执行Chain.proceed(). 允许重连，多次调用proceed()。 Network Interceptors （网络拦截器） 能够操作中间反应，例如重定向和重连。 不能被缓存响应，例如短路网络调用（short-circuit the network）。 观察数据，正如它将在网络上传输。 访问携带request的Connection 注意在进行okhttp请求获取下载进度，根据Callback返回 缓存响应数据（Reponse Caching） To cache responses, you’ll need a cache directory that you can read and write to, and a limit on the cache’s size. The cache directory should be private, and untrusted applications should not be able to read its contents! 我们需要限制缓存的大小，并且缓存数据的目录不可以被其他应用读取。 Response caching uses HTTP headers for all configuration. You can add request headers like Cache-Control: max-stale=3600 and OkHttp’s cache will honor them. Your webserver configures how long responses are cached with its own response headers, like Cache-Control: max-age=9600. There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET. 我们可以手动为request请求添加请求头”Cache-Control: max-stale=3600”，设置缓存时间。或者由服务器决定我们的缓存时间。max-stale是发起请求方设置的缓存时间，只对请求端有效。max-age为设置相应数据的缓存有效期时间，在没有超过max-age的情况下，会自动从缓存中读数据；在超出max-age的情况会向服务端发送新的请求，如果请求失败会返回缓存的数据。如果max-age有效期过了，请求端设置了max-stale，仍然可以从缓存中读取，不需要去服务器请求新的内容。因此max-age和max-stale在请求中同时使用的情况下，缓存的时间为max-age和max-stale的和，超出max-age值会提示Warning: 110 HttpURLConnection &quot;Response is stale。max-age和max-stale详解 12345678910111213141516171819202122232425262728293031int cacheSize = 10 * 1024 * 1024; // 10 MiBCache cache = new Cache(cacheDirectory, cacheSize);OkHttpClient client = new OkHttpClient.Builder() .cache(cache) .build();Request request = new Request.Builder() .url(\"http://publicobject.com/helloworld.txt\") .build();String response1Body;try (Response response1 = client.newCall(request).execute()) { if (!response1.isSuccessful()) throw new IOException(\"Unexpected code \" + response1); response1Body = response1.body().string(); System.out.println(\"Response 1 response: \" + response1); System.out.println(\"Response 1 cache response: \" + response1.cacheResponse()); System.out.println(\"Response 1 network response: \" + response1.networkResponse());}String response2Body;try (Response response2 = client.newCall(request).execute()) { if (!response2.isSuccessful()) throw new IOException(\"Unexpected code \" + response2); response2Body = response2.body().string(); System.out.println(\"Response 2 response: \" + response2); System.out.println(\"Response 2 cache response: \" + response2.cacheResponse()); System.out.println(\"Response 2 network response: \" + response2.networkResponse());}System.out.println(\"Response 2 equals Response 1? \" + response1Body.equals(response2Body)); response2的数据将从缓存中获取，日志信息如下： 1234567Response 1 response: Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}Response 1 cache response: Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}Response 1 network response: Response{protocol=http/1.1, code=304, message=Not Modified, url=https://publicobject.com/helloworld.txt}Response 2 response: Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}Response 2 cache response: Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}Response 2 network response: nullResponse 2 equals Response 1? true","link":"/2018/06/22/Android开发笔记/Android okhttp使用详解/"},{"title":"Android中的IPC之Binder机制","text":"Android中的IPC机制即跨进程通信技术（Inter-Process-Comunicate），主要技术是 Android 的序列化机制和Binder。 Android 跨进程通信常见的几种方式；Bundle、文件共享、AIDL、Messenger、ContentProVider和Socket等。其中AIDL、Messenger、ContentProvider底层属于基于 Android Binder 机制实现的。 Android 多进程模式关于开启多进程模式注意，android:process=&quot;:remote&quot; 与android:precess=&quot;com.xxx.xxx.remote&quot;指定Android 多进程方式的区别，进程名以”:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一进程，而进程名不以”:”开头的进程属于全局进程，其他应用通过 ShareUID 方式（签名也需相同）可以和它跑在同一个进程中。Android系统为每个应用分配一个唯一的 UUID，具有相同的 UUID 的应用才能共享数据。 多进程模式下会造成如下几方面的问题： 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPrefence 的可靠性下降（SharedPrefence 本质上是读写 xml 文件进行存储，并发操作会导致混乱） Application 多次创建 运行在同一个进程中的组件是属于同一个虚拟机和同一个 Application 的，同理，运行在不同进程中的组件是属于两个不同的虚拟机和 Application 的。 IPC基础概念介绍IPC基本概念主要包含三方面内容：Serializable 和Parcelable 接口以及 Binder。Serializable 和Parcelable 接口可以完成对象的序列化过程。通过序列化保证对象的持久化，可以使用 Intent 、Bundle 以及网络传递对象。 Serializable序列化Serializable 实现序列化的过程主要通过下面的表示实现: 1private static final long serialVersionUID = 8711368828010083044L 序列化标识并不是必须的，系统会自动生成这个标识，但是当实现 Serializable 序列化接口的对象实体类结构发生变化，序列化标识也会重新赋值，这将对与反序列化过程有影响。 12345678910//序列化过程User user = new User(\"0\",\"jake\",true);ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"cache.txt\"));out.writeObject(user);out.close();//反序列化过程ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"cache.txt\"));User newUser = (User)int.readObject();in.close(); 需要注意的是 user 和 newUser 的内容相同，但不是同一个对象。关于 serialVersionUID 这个标识，只有序列化之前的对象的 serialVersionUID 值和序列化之后 serialVersionUID 值一致，才可以正常反序列化。实体类中成员数量和类型发生变化， serialVersionUID 值都会改变。一般来说我们手动指定 serialVersionUID 值，这样反序列化过程不会受到影响。如果不手动指定 serialVersionUID ，反序列化是当前类有所改变，比如增加或者删除了某些成员变量，那么系统就会重新计算当前类结的 hash 值并把它赋值给 serialVersionUID，这个时候当前类的serialVersionUID 就和序列化后的数据中的 serialVersionUID 不一致，于是反序列化失败。当我们手动指定了它以后，就可以很大程度上避免反序列化过程的失败，比如删除了某些成员变量或者增加了某些成员变量，数据仍然可以正常反序列化。不过如果类结构发生非常规性改变，比如修改类名，变量类型或者名称，即便指定了serialVersionUID，依然会反序列化失败。 Parcelable序列化Parcelable 是 Android 平台上提供的序列化方案，相对于 Serialable 大量的 IO 操作，拥有更好的性能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Book implements Parcelable { private int bookId; private String bookName; public Book() {} public Book(int bookId, String bookName) { this.bookId = bookId; this.bookName = bookName; } public int getBookId() { return bookId; } public void setBookId(int bookId) { this.bookId = bookId; } public String getBookName() { return bookName; } public void setBookName(String bookName) { this.bookName = bookName; } protected Book(Parcel in) { bookId = in.readInt(); bookName = in.readString(); } //当设置参数标签为out和inout时会要求重写这个方法 public void readFromParcel(Parcel in) { bookId = in.readInt(); bookName = in.readString(); } public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() { @Override public Book createFromParcel(Parcel in) { return new Book(in); } @Override public Book[] newArray(int size) { return new Book[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(bookId); dest.writeString(bookName); }} Android进程通信之Binder机制Messenger-进程间通信的信使Messenger 根据 Handler 生成实例构造方法： 123456789101112131415161718192021222324//Messenger.java/** * Create a new Messenger pointing to the given Handler. Any Message * objects sent through this Messenger will appear in the Handler as if * {@link Handler#sendMessage(Message) Handler.sendMessage(Message)} had * been called directly. * * @param target The Handler that will receive sent messages. */public Messenger(Handler target) { mTarget = target.getIMessenger();}/** * Send a Message to this Messenger's Handler. * * @param message The Message to send. Usually retrieved through * {@link Message#obtain() Message.obtain()}. * * @throws RemoteException Throws DeadObjectException if the target * Handler no longer exists. */public void send(Message message) throws RemoteException { mTarget.send(message);} 通过 Handler 对象创建 Messenger，通过 Messenger#send(Message) 方法就可以跨进程传递信息。 12345678910111213141516171819202122232425//MainActivity.java private Messenger client = new Messenger(new MessengerHandler());private ServiceConnection serviceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { MainActivity.this.service = new Messenger(service); Message msg = Message.obtain(null, Contanstants.MSG_FROM_CLIENT); Bundle bundle = new Bundle(); bundle.putString(\"msg\", \"hello, this is client\"); msg.setData(bundle); //指定回复信使 msg.replyTo = client; try { MainActivity.this.service.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { }}; MainActivity 通过调用bindservice() 方法，获取IBinder 对象。看一下 Messenger 关于 IBinder 参数的构造方法： 123456789/** * Create a Messenger from a raw IBinder, which had previously been * retrieved with {@link #getBinder}. * * @param target The IBinder this Messenger should communicate with. */public Messenger(IBinder target) { mTarget = IMessenger.Stub.asInterface(target);} 上面是 clien 端向 service 端发送信息，再看一下关于 service 端处理 client 端的数据，并回复 client 端。上述代码我们在 Message 传递信息中指定了回复信使，看一下 service 端代码： 1234567891011121314151617181920212223242526272829//MessengerService.javaprivate Messenger mMessenger = new Messenger(new MessengerHandler());private static class MessengerHandler extends Handler { @Override public void handleMessage(Message msg) { if (msg.what == Contanstants.MSG_FROM_CLIENT) { Bundle bundle = msg.getData(); Log.d(TAG, bundle.getString(\"msg\")); Messenger clientMessenger = msg.replyTo; Message replyMsg = Message.obtain(null, Contanstants.MSG_FROM_SERVER); bundle.putString(\"msg\", \"this is server\"); replyMsg.setData(bundle); try { clientMessenger.send(replyMsg); } catch (RemoteException e) { e.printStackTrace(); } } else { super.handleMessage(msg); } }}@Nullable@Overridepublic IBinder onBind(Intent intent) { return mMessenger.getBinder();}} AIDL（android interface define launage）关于基于 Binder 机制的 AIDL 以及 Messenger 概述：AIDL 文件在编译过程中会在 build 文件中生成对应的java文件，所以我们也可以通过写java文件来实现进程间通信。这里简单介绍一样 AIDL 文件对应java文件的结构以便于理解后续的概念： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public interface IBookManager extends android.os.IInterface { //... public static abstract class Stub extends android.os.Binder implements com.markzl.android.androidipc.entity.IBookManager { private static final java.lang.String DESCRIPTOR = \"com.markzl.android.androidipc.entity.IBookManager\"; /** * Construct the stub at attach it to the interface. */ public Stub() { this.attachInterface(this, DESCRIPTOR); } /** * Cast an IBinder object into an com.markzl.android.androidipc.entity.IBookManager interface, * generating a proxy if needed. * client端会调用该方法根据service端传回的IBinder对象生成IBookManager对象 */ public static com.markzl.android.androidipc.entity.IBookManager asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.markzl.android.androidipc.entity.IBookManager))) { return ((com.markzl.android.androidipc.entity.IBookManager) iin); } return new com.markzl.android.androidipc.entity.IBookManager.Stub.Proxy(obj); } /** * service端会将当前的binder通过@link{Service#OnBinder(Intent intent)}传递给client */ @Override public android.os.IBinder asBinder() { return this; } //... private static class Proxy implements com.markzl.android.androidipc.entity.IBookManager { //... } } public void addBookIn(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookInOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException;} 可以看到 client 端调用的IBookManager.Stub#asInterface()方法中，会先通过 binder 对象查询当前进程中的IBookManager 对象是否存在，不存在就走 Proxy 代理类。关于 Proxy 中如何处理跨进程通信，下面会结合AIDL定向标签来介绍。 关于 AIDL 中定向标签 in，out，inout通过分析定向标签，我们同样可以学习到 AIDL 的基本原理。 12345678910// IBookManager.aidlpackage com.markzl.android.androidipc.entity;import com.markzl.android.androidipc.entity.Book;import com.markzl.android.androidipc.IOnNewBookAddedListener;interface IBookManager { void addBookIn(in Book book); void addBookOut(out Book book); void addBookInOut(inout Book book);} 生成的 java 文件： 123456789101112131415161718192021222324252627282930313233343536public interface IBookManager extends android.os.IInterface { //... public static abstract class Stub extends android.os.Binder implements com.markzl.android.androidipc.entity.IBookManager { //... @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { java.lang.String descriptor = DESCRIPTOR; switch (code) { //根据方法对应的code码处理相应数据 //... case TRANSACTION_addBookIn: //... break; case TRANSACTION_addBookOut: //... break; case TRANSACTION_addBookInOut: //... break; } } private static class Proxy implements com.markzl.android.androidipc.entity.IBookManager { //... static final int TRANSACTION_addBookIn = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBookOut = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); static final int TRANSACTION_addBookInOut = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2); } } public void addBookIn(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookInOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException;} in 标签in 标签 client 端向 service 端写入数据，我们看一下生成的对应的 IBookManager.java 文件，其中用于跨进程处理数据的 IBookManager.Stub 内部私有 Proxy 类： 123456789101112131415161718192021222324252627282930313233//IBookManager.java private static class Proxy implements com.markzl.android.androidipc.entity.IBookManager { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } @Override public void addBookIn(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_addBookIn, _data, _reply, 0); _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } }} 可以看到 Proxy 中类将我们传入的实体序列化后，交给 mRemote#transact 方法处理，从 Proxy 类中可以看出，mRemote 是一个 IBinder 对象，在调用 Proxy 的构造方法时传入的是 Binder 的对象。 transact 方法是在IBinder 接口类中定义的，其实现类 Binder#transact 方法如下： 1234567891011121314151617/** * Default implementation rewinds the parcels and calls onTransact. On * the remote side, transact calls into the binder to do the IPC. */public final boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException { if (false) Log.v(\"Binder\", \"Transact: \" + code + \" to \" + this); if (data != null) { data.setDataPosition(0); } boolean r = onTransact(code, data, reply, flags); if (reply != null) { reply.setDataPosition(0); } return r;} 可以看到最终调用的方法是onTransact(code, data, reply, flags)，接下来我们看一下 onTransact 中方法如何处理序列化后的数据： 12345678910111213141516171819@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { //... switch (code) { //... case TRANSACTION_addBookIn: { data.enforceInterface(descriptor); com.markzl.android.androidipc.entity.Book _arg0; if ((0 != data.readInt())) { _arg0 = com.markzl.android.androidipc.entity.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.addBookIn(_arg0); reply.writeNoException(); return true; } }} onTransact() 方法中将序列化的数据重新反序列化成一个新的Book对象，然后调用service端的addBookIn()方法添加Book对象。注意这个过程是生成一个新的Book对象，具体为什么要注意生成新对象后面会讲到。这里总结一下in标签的作用向service传递数据但没有处理service的reply结果。 out标签同样首先看Proxy类中生成的addBookOut()方法： 12345678910111213141516@Overridepublic void addBookOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_addBookOut, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) { book.readFromParcel(_reply); } } finally { _reply.recycle(); _data.recycle(); }} 可以看到这里我们并没有处理 Book 对象，_data 始终没有写入 Book 对象，而且调用transact() 方法之后的_reply.readInt() 不等于0的时候，会重新从 _reply 中读取 book 实体。我们再来看一下调用的 onTransact() 方法中如何处理out标签： 1234567891011121314case TRANSACTION_addBookOut: { data.enforceInterface(descriptor); com.markzl.android.androidipc.entity.Book _arg0; _arg0 = new com.markzl.android.androidipc.entity.Book(); this.addBookOut(_arg0); reply.writeNoException(); if ((_arg0 != null)) { reply.writeInt(1); _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } return true;} out定向标签中是重新生成了一个新的 Book 对象，没有写入任何值。然后调用了addBook(Book book)方法，由此可知 service 并没有真正添加 client 传来的 Book 对象。 inout标签先看 Proxy#addBookInOut() ： 12345678910111213141516171819202122@Overridepublic void addBookInOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_addBookInOut, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) { book.readFromParcel(_reply); } } finally { _reply.recycle(); _data.recycle(); }} 在 _data 传入 book 序列化数据时和in标签同样的处理， _reply 的处理和 out 标签时保持一致。接着我们看一下 addBookInOut() 方法标签对应的 onTransact() 方法。 123456789101112131415161718case TRANSACTION_addBookInOut: { data.enforceInterface(descriptor); com.markzl.android.androidipc.entity.Book _arg0; if ((0 != data.readInt())) { _arg0 = com.markzl.android.androidipc.entity.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.addBookInOut(_arg0); reply.writeNoException(); if ((_arg0 != null)) { reply.writeInt(1); _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } return true;} 调用IBookManager#Stub实例对象通过 addBookInOut 方法添加由data反序列化后得到的Book对象。inout标签在某种意义上算得上是in和out标签的“并集”，目前并没有看出out和inout标签中的 _reply 值存在的意义。_reply在处理有返回值的方法使用如下: 1234567891011121314151617//Proxy#getBookList()@Overridepublic java.util.List&lt;com.markzl.android.androidipc.entity.Book&gt; getBookList() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.markzl.android.androidipc.entity.Book&gt; _result; try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.markzl.android.androidipc.entity.Book.CREATOR); } finally { _reply.recycle(); _data.recycle(); } return _result;} onTransact()中对于_reply赋值如下： 12345678//IBookManager.Stub#onTransact()case TRANSACTION_getBookList: { data.enforceInterface(descriptor); java.util.List&lt;com.markzl.android.androidipc.entity.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true;} 关于AIDL各种方法生成的详细内容都可以在build文件夹下生成对应java文件中看到。 service端数据改动时如何主动响应client端service数据有改动如何主动响应client端？这种情况类似View的setOnClickListener设置监听事件方法，当View被单击调用OnClickListener#onClick方法来做出相应处理，即事件回调。在之前的IBookManager添加如下接口： 123456//...interface IBookManager { //... void setOnBookAddedListener(OnBookAddedListener listener); void removeOnBookAddedListener(OnBookAddedListener listener);} 创建接口类OnBookAddedListener: 1234//OnBookAddedListener.aidlinterface OnBookAddedListener{ void onNewBookAdded();} 然后在service中实现如下： 12345678910111213141516171819202122232425262728public class BookService extends Service { private List&lt;Book&gt; mBookList = new ArrayList&lt;&gt;(); private List&lt;OnBookAddedListener&gt; mListenerList = new ArrayList&lt;&gt;(); IBookManager bookManager = new IBookManager.Stub() { //... @Override public void setOnBookAddedListener(OnBookAddedListener listener) throws RemoteException { mListenerList.add(listener); } @Override public void removeOnBookAddedListener(OnBookAddedListener listener) throws RemoteException { mListenerList.remove(listener); } }; @Nullable @Override public IBinder onBind(Intent intent) { //开启线程不断添加新书。然后遍历mListenerList， //调用OnBookAddedListener#onNewBookAdded()方法通知client端 new Thread(new AddBookWorker()).start(); return bookManager.asBinder(); } //...} 在client端与ServiceConnection#onServiceConnected()注册监听方法： 12345678910@Overridepublic void onServiceConnected(ComponentName name, IBinder service) { bookManager = IBookManager.Stub.asInterface(service); try { //listener中打印日志 bookManager.registerOnNewBookAddListener(listener); } catch (RemoteException e) { e.printStackTrace(); }} 在bindService()方法之后，当service端线程不断添加新书，我们可以正常打印新书添加日志信息，但是当我们调用removeOnBookAddedListener()方法时，打印日志信息并没有像我们期望的那样停止。这是因为client端进程中的OnBookAddedListener对象和service端的OnBookAddedListener对象不是同一个对象，正如我们在3.3.1末尾提到的一样。那么我们该如何在serice端和client操作同一个对象。这里系统为我们提供了RemoteCallbackList类，原理是通过键值对的形式保存OnBookAddedListener对象，使得我们添加和移除的是同一个对象。关于RemoteCallbackList的介绍： 12remoteCallbackList.register(listener);remoteCallbackList.unregister(listener); 其中RemoteCallbackList#register() 简单的概述如下（详情请阅读源码）: 1234IBinder binder = listener.asBinder();//...Callback cb = new Callback(listener, cookie);mCallbacks.put(binder, cb); 可以看出利用的是两个进程使用的是同一个Binder对象来作为key，通过client 端和service端相同key(binder)删除相应的listener。 关于Binder线程池的使用// 待续……","link":"/2019/10/23/Android开发笔记/AndroidIPC机制/"},{"title":"Android使用RenderScript处理图片","text":"RenderScript是Android平台上简单快速处理图片效果的脚本工具，Renderscript``基于C99（Ed. C 语言）。使用前需要在Module下build.gradle文件中添加两行代码： 12345defaultConfig { //略... renderscriptTargetApi 24 renderscriptSupportModeEnabled true} renderscriptTargetApi - Specifies the bytecode version to be generated. We recommend you set this value to the lowest API level able to provide all the functionality you are using and set renderscriptSupportModeEnabled to true. Valid values for this setting are any integer value from 11 to the most recently released API level. If your minimum SDK version specified in your application manifest is set to a different value, that value is ignored and the target value in the build file is used to set the minimum SDK version. renderscriptTargetApi- 指定要生成的字节码版本。建议将此值设置为能够提供您正在使用的所有功能的最低API级别，并将renderscriptSupportModeEnabled设置为true。此设置的有效值是从11到最近发布的API级别的任何整数值。如果应用程序清单中指定的最低SDK版本设置为其他值，则忽略该值，并使用构建中的目标值设置最低SDK版本。 renderscriptSupportModeEnabled - Specifies that the generated bytecode should fall back to a compatible version if the device it is running on does not support the target version. renderscriptSupportModeEnabled - 指定生成的字节码如果运行的设备不支持目标版本，则应回退到兼容版本。 Renderscript将使用C写的脚本并行计算图片的每一个像素。一个脚本就是一个扩展名为'.rs'的文件，必须置于app/src/main/rs。Android Studio 并不会为你生成这个目录或者任何脚本。 ##使用ScriptInstrinsicBlur模糊图片 模糊图片，系统为我们提供了ScriptInstrinsicBlur工具类，不需要使用rs脚本渲染 ： 12345678910111213141516171819202122232425262728293031323334 public static Bitmap blurBitmap(Bitmap bitmap, float radius, Context context) { //Create renderscript RenderScript rs = RenderScript.create(context); //Create allocation from Bitmap Allocation allocation = Allocation.createFromBitmap(rs, bitmap); Type t = allocation.getType(); //Create allocation with the same type Allocation blurredAllocation = Allocation.createTyped(rs, t); //Create script ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); //Set blur radius （maximum 25.0） blurScript.setRadius(radius); //Set input for script blurScript.setInput(allocation); //Call script for output allocation blurScript.forEach(blurredAllocation); //Copy script result into bitmap blurredAllocation.copyTo(bitmap); //Destroy everything to free memory allocation.destroy(); blurredAllocation.destroy(); blurScript.destroy(); t.destroy(); rs.destroy(); return bitmap;} Renderscript.jar包中提供了简单的图片渲染工具类，例ScriptIntrinsicBlur，ScriptIntrinsicConvolve5x5，ScriptIntrinsicColorMatrix等。同时可以自定是rs文件，项目编译后会生成对应脚本类。例rs文件夹下有名为hist_Eq.rs文件，编译后会生成对应的ScriptC_histEq类。 直方图均衡化 ​ Y 分量上的Histogram Equalization (前后对比) Y的直方图均衡化算法很简单： 把RGB颜色空间转换成YUV颜色空间。 计算Y分量的直方图。 根据直方图重新映射Y分量。 重新把YUV转换回RGB颜色空间。 我们现在可以开始创建我们的rs文件了：histEq.rs，位于rs目录。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#pragma version(1)#pragma rs_fp_relaxed#pragma rs java_package_name(com.example.q.renderscriptexample) #include \"rs_debug.rsh\" int32_t histo[256];float remapArray[256];int size; //Method to keep the result between 0 and 1static float bound (float val) { float m = fmax(0.0f, val); return fmin(1.0f, m);} uchar4 __attribute__((kernel)) root(uchar4 in, uint32_t x, uint32_t y) { //Convert input uchar4 to float4 float4 f4 = rsUnpackColor8888(in); //Get YUV channels values float Y = 0.299f * f4.r + 0.587f * f4.g + 0.114f * f4.b; float U = ((0.492f * (f4.b - Y))+1)/2; float V = ((0.877f * (f4.r - Y))+1)/2; //Get Y value between 0 and 255 (included) int32_t val = Y * 255; //Increment histogram for that value rsAtomicInc(&amp;histo[val]); //Put the values in the output uchar4, note that we keep the alpha value return rsPackColorTo8888(Y, U, V, f4.a);} uchar4 __attribute__((kernel)) remaptoRGB(uchar4 in, uint32_t x, uint32_t y) { //Convert input uchar4 to float4 float4 f4 = rsUnpackColor8888(in); //Get Y value float Y = f4.r; //Get Y value between 0 and 255 (included) int32_t val = Y * 255; //Get Y new value in the map array Y = remapArray[val]; //Get value for U and V channel (back to their original values) float U = (2*f4.g)-1; float V = (2*f4.b)-1; //Compute values for red, green and blue channels float red = bound(Y + 1.14f * V); float green = bound(Y - 0.395f * U - 0.581f * V); float blue = bound(Y + 2.033f * U); //Put the values in the output uchar4 return rsPackColorTo8888(red, green, blue, f4.a);} void init() { //init the array with zeros for (int i = 0; i &lt; 256; i++) { histo[i] = 0; remapArray[i] = 0.0f; }} void createRemapArray() { //create map for y float sum = 0; for (int i = 0; i &lt; 256; i++) { sum += histo[i]; remapArray[i] = sum / (size); }} 这里有几个方法： bound(float val): 这个方法用于让结果保持在0到1之间。 root(): 这个方法是为input Allocation的每一个像素而调用（被叫做一个kernel）。它把像素从RGBA转换成YUVA，它把结果放在 output allocation。它还增加了Y直方图的值。 remaptoRGB(): 这个方法也是一个kernel。它重新映射Y值然后从YUVA转换回RGBA。 init(): 当在java中创建脚本的时候，这个方法自动被调用。它用0初始化数组。 createRemapArray(): 它为Y分量创建remap数组。 你可以像以往在c中那样创建方法。但是这里如果你需要像我在bound()中那样返回什么东西，这个方法必须是静态的。 12345678910111213141516171819202122232425262728293031323334353637383940414243public static Bitmap histogramEqualization(Bitmap image, Context context) { //Get image size int width = image.getWidth(); int height = image.getHeight(); //Create new bitmap Bitmap res = image.copy(image.getConfig(), true); //Create renderscript RenderScript rs = RenderScript.create(context); //Create allocation from Bitmap Allocation allocationA = Allocation.createFromBitmap(rs, res); //Create allocation with same type Allocation allocationB = Allocation.createTyped(rs, allocationA.getType()); //Create script from rs file. ScriptC_histEq histEqScript = new ScriptC_histEq(rs); //Set size in script histEqScript.set_size(width*height); //Call the first kernel. histEqScript.forEach_root(allocationA, allocationB); //Call the rs method to compute the remap array histEqScript.invoke_createRemapArray(); //Call the second kernel histEqScript.forEach_remaptoRGB(allocationB, allocationA); //Copy script result into bitmap allocationA.copyTo(res); //Destroy everything to free memory allocationA.destroy(); allocationB.destroy(); histEqScript.destroy(); rs.destroy(); return res;} 参考文章： RenderScript :简单而快速的图像处理 RenderScript Overview | Android Developers","link":"/2018/05/06/Android开发笔记/Android使用RenderScript处理图片/"},{"title":"Android设置全屏及沉浸式布局","text":"下述代码根据 AppCompatActivity 及主题 parent=&quot;Theme.AppCompat.NoActionBar&quot; 和midSdk 21实现。 对于非刘海屏幕而言有两种方式设置全屏 代码中设定，需要写在 setContentView() 之前： 123456// 隐藏标题//requestWindowFeature(Window.FEATURE_NO_TITLE);// 设置全屏getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN)//或者是通过设置DecorView#setSystemUiVisibility(int) //getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN) 需要说明一点 requestWindowFeature() 方法是指定主题为 parent=&quot;android:Theme.Black&quot;之类的Activity 时隐藏老式 ActionBar 标题栏内容。对于继承 AppCompatActivity 这个方法无效。如果继承 AppCompatActivity 的 Activity 需要隐藏标题栏，可以通过以下方法： 123if(getSupportActionBar()!=null){ getSupportActionBar().hide();} 指定 Activity 的 Theme 主题 1android:theme=\"@style/FullScreenTheme\" 主题设置属性： 123456//styles.xml&lt;style name=\"FullScreenTheme\" parent=\"Theme.AppCompat.NoActionBar\"&gt; //这里指定的是Appcompat主题，这个属性可以去掉 &lt;!--&lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt;--&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;&lt;/style&gt; 上述两种方式都可以指定非刘海屏幕全屏显示。 关于刘海屏的全屏展示。测试机是华为8x刘海屏手机，发现设置全屏之后界面并没有延伸到刘海。刘海屏幕全屏适配分为两种情况：Android P 及Android P 一下： Android P 9.0系统提供了处理刘海屏的方法。设置全屏如下 1234567if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) { WindowManager.LayoutParams lp = getWindow().getAttributes(); // 始终允许窗口延伸到屏幕短边上的刘海区域 lp.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; getWindow().setAttributes(lp);}getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN| View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); Android P 中新增了窗口布局参数属性 layoutInDisplayCutoutMode，共有三种模式 LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT：仅当缺口区域完全包含在状态栏之中时，才允许窗口延伸到刘海区域显示 LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER：// 永远不允许窗口延伸到刘海区域 LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES：始终允许窗口延伸到屏幕短边上的刘海区域 通过设置 setSystemUiVisibility(int) 方法可以获取实现常见的全屏或者是沉浸式布局的效果: 控制SystemBar相关： SYSTEM_UI_FLAG_FULLSCREEN SYSTEM_UI_FLAG_HIDE_NAVIGATION SYSTEM_UI_FLAG_LOW_PROFILE 布局相关： SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION SYSTEM_UI_FLAG_LAYOUT_STABLE 沉浸式相关 (4.4 引入)： SYSTEM_UI_IMMERSIVE SYSTEM_UI_IMMERSIVE_STICKY 控制 SystemBar 相关SYSTEM_UI_FLAG_FULLSCREEN 该属性是用来隐藏状态栏的， SYSTEM_UI_HIDE_NAVIGATION 该属性是用来隐藏导航栏的 SYSTEM_UI_LOW_PROFILE 这个属性的能力是让SystemBar在视觉上变得模糊，重要性变得更低一点。具体表现是状态栏图标仅保留电量时间关键图标，并且变暗。导航栏图标变成三个点或者变暗。这个flag使用的很少。 布局相关 在新的Android4.1以及之后新的SystemUI设置里，仅单独设置隐藏状态栏和导航栏的flag会导致布局重绘，为了在显隐状态栏和导航栏的时候保持布局的稳定的显示效果，就需要以下属性了。 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 可以让布局延伸到状态栏的位置。在状态栏在隐藏和显示之前切换的时候，布局稳定的显示在状态栏后面（如果显示状态栏则布局在状态栏后面，隐藏状态栏布局也不变）。 SYSTEM_UI_FLAG_LAYOUT_STABLE 该flag的作用是保持布局稳定，避免在显隐状态栏导航栏的时候发生布局的变化。可以辅助以下SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN、SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION两个flag的使用，让应用保持全屏的情况下，布局不随状态栏导航栏显隐发生变化。也可以不配合这两个flag使用，也能达到保持布局稳定的效果，不过不能实现全屏，会留出状态栏和导航栏的位置。 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 可以让布局延伸到导航栏的位置。可以让导航栏在隐藏和显示之前切换的时候，布局稳定的显示在导航栏后面（如果显示导航栏则在导航栏后面，隐藏导航栏也不变）。 关于沉浸式界面在代码中指定。在 setContentView() 之前指定状态栏颜色透明即可,设置状态栏透明后，界面布局将延伸到状态栏。注意如果设置全屏，状态栏不再显示. 123456//设置沉浸式状态栏Window window = getWindow();//设置状态栏颜色window.setStatusBarColor(Color.TRANSPARENT);//设置布局延伸到状态栏window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); 对于状态栏白色的情况，在Android 6.0 sdk版本23 的情况，应如下设置： 12345678Window window = getWindow();if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { window.setStatusBarColor(Color.WHITE); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);}//关于小米魅族状态栏颜色设置暂不考虑 参考文章： Android沉浸式全屏讲解(状态栏、导航栏处理) Android刘海屏适配全方案（华为、小米、Vivo、Oppo)","link":"/2019/06/05/Android开发笔记/Android设置应用界面全屏/"},{"title":"Android软键盘遮挡输入文本框问题","text":"在开发过程中，经常遇到在某个界面有多个文本框时，点击输入会出现软件盘遮挡输入框的情况，或者是类似在登录或注册页面可以输入信息，但是键盘遮挡登录注册按钮的问题，还有遮挡住输入框下面的输入框，用户必须手动收起键盘才可以继续输入的情况。本篇文章介绍如何处理这些问题，首先我们来介绍一下adjustSize和adjustPan属性。 在搜索相关软件盘遮挡问题时，大部分文章都是推荐我们在AndroidManifest文件中的Activity标签中添加 “android:windowSoftInputMode=”adjustResize” 或者是 “android:windowSoftInputMode=”adjustPan”属性，这里我们先来介绍一下 adjustResize 和 adjustPan。官网的描述如下： 值 描述 adjustResize 始终调整Activity主窗口的尺寸，以为屏幕上的软键盘腾出空间 adjustPan 不通过调整Activity主窗口的尺寸为软键盘腾出空间。相反窗口的内容会自动平移，使键盘永远无法覆盖当前焦点，以便用户始终看到自己输入的内容。这通常不如调整窗口尺寸可取，因为用户可能需关闭软键盘才能进入被遮盖的窗口部分，并与之交互。 当设置属性”android:windowSoftInputMode=”adjustResize”时，多文本输入框且根布局为LinearLayout没有使用ScrollView包裹时，点击文本输入7时，主窗口尺寸被调整压缩如下所示： 在设置布局文件根布局为ScrollView时，如下所示： 可以看到当我们设置属性为”android:windowSoftInputMode=”adjustResize”且根布局为ScrollView时，调整窗口尺寸是通过平移ScrollView中的内容来实现的，注意这里的文本标题并没有平移。且ScrollView中的文本内容我们可以滚动到最底部，不会被软键盘遮挡。 当我们设置Activity属性为”android:windowSoftInputMode=”adjustPan”且根布局为LinearLayout时，点击文本输入8可以看到整个窗口包括标题向上平移如下所示： 当我们设置activity属性为adjustPan且根布局为ScrollView，这时候发现当我们点击文本输入8后滑动视图时，始终有部分文本输入框被软键盘遮挡，必须用户手动隐藏软键盘，才可以选择下面的文本输入。如下图所示： 文本输入12下面的文本输入框被键盘遮挡无法滑动。 总结一下，在使用adjustResize属性而根布局不是ScrollView的情况，Activity主窗口会被压缩显示不全，无法看到输入内容，此时使用adjustPan属性会让显示效果更好，不过需要用户手动隐藏软键盘才可以继续输入。在根布局为ScrollView的情况下，Activity使用adjustResize用户体验会更好，因为此时的adjustPan属性始终会使软键盘遮挡部分布局。","link":"/2018/10/29/Android开发笔记/Android软键盘遮挡输入文本框问题/"},{"title":"Android预览pdf文档","text":"谷歌为我们提供了PdfRender工具类对pdf文档进行渲染，首先看一下PdfRender的构造方法： 123456789101112131415161718192021222324/** * Creates a new instance. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; The provided file descriptor must be &lt;strong&gt;seekable&lt;/strong&gt;, * i.e. its data being randomly accessed, e.g. pointing to a file. * &lt;/p&gt; * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; This class takes ownership of the passed in file descriptor * and is responsible for closing it when the renderer is closed. * &lt;/p&gt; * &lt;p&gt; * If the file is from an untrusted source it is recommended to run the renderer in a separate, * isolated process with minimal permissions to limit the impact of security exploits. * &lt;/p&gt; * * @param input Seekable file descriptor to read from. * * @throws java.io.IOException If an error occurs while reading the file. * @throws java.lang.SecurityException If the file requires a password or * the security scheme is not supported. */public PdfRenderer(@NonNull ParcelFileDescriptor input){ //略...} 可以看构造方法中的参数是ParcelFileDescriptor的一个实例，那么ParcelFileDescriptor类是做什么的呢？ParcelFileDescriptor是Android 提供的一种数据结构，支持数据的写入和写出。我们通过ParcelFileDescriptor#open 建立文件和ParcelFileDescriptor的联系 1234567891011121314151617181920/** * Create a new ParcelFileDescriptor accessing a given file. * * @param file The file to be opened. * @param mode The desired access mode, must be one of * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or * {@link #MODE_READ_WRITE}; may also be any combination of * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE}, * {@link #MODE_WORLD_READABLE}, and * {@link #MODE_WORLD_WRITEABLE}. * @return a new ParcelFileDescriptor pointing to the given file. * @throws FileNotFoundException if the given file does not exist or can not * be opened with the requested mode. * @see #parseMode(String) */ public static ParcelFileDescriptor open(File file, int mode) throws FileNotFoundException { final FileDescriptor fd = openInternal(file, mode); if (fd == null) return null; return new ParcelFileDescriptor(fd); } 从该方法中可以看出ParcelFileDescriptor#open实际操作的是FileDescriptor，仔细阅读FileDescriptor的注释，FileDescriptor是文件操作符。FileDescriptor可以用来表示开放文件、开放套接字。以FileDecriptor 表示文件来说，当FileDescroptor表示某文件 时，我们可以通俗的将FileDescriptor看成是该文件。但是，我们不能直接通过FileDescription对该文件进行操作；若需要通过FileDescriptor对该文件进行操作，则需要新创建FileDescriptor对应的FileOutputSteam，再对文件进行操作。这里有对FileDescription的详细描述。 12345678 ParcelFileDescriptor mFileDescriptor; PdfRenderer mPdfRenderer; //根据文件对象创建mFileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY); // This is the PdfRenderer we use to render the PDF. if (mFileDescriptor != null) { mPdfRenderer = new PdfRenderer(mFileDescriptor); } 打开pdf指定页面和生成当前页面的Bitmap展示： 12345678910111213141516171819202122private PdfRenderer.Page mCurrentPage;private void showPage(int index) { if (mPdfRenderer.getPageCount() &lt;= index) { return; } // Make sure to close the current page before opening another one. if (null != mCurrentPage) { mCurrentPage.close(); } // Use `openPage` to open a specific page in PDF. mCurrentPage = mPdfRenderer.openPage(index); // Important: the destination bitmap must be ARGB (not RGB). Bitmap bitmap = Bitmap.createBitmap(mCurrentPage.getWidth(), mCurrentPage.getHeight(),Bitmap.Config.ARGB_8888); // Here, we render the page onto the Bitmap. // To render a portion of the page, use the second and third parameter. Pass nulls to get // the default result. // Pass either RENDER_MODE_FOR_DISPLAY or RENDER_MODE_FOR_PRINT for the last parameter. mCurrentPage.render(bitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY); // We are ready to show the Bitmap to user. mImageView.setImageBitmap(bitmap); updateUi();} 完整实例： 页面R.layout.fragment_pdf_renderer_basic： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".PdfRendererBasicFragment\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:background=\"@android:color/white\" android:scaleType=\"fitCenter\" android:contentDescription=\"@null\"/&gt; &lt;LinearLayout style=\"?android:attr/buttonBarStyle\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:measureWithLargestChild=\"true\" android:orientation=\"horizontal\"&gt; &lt;Button android:id=\"@+id/previous\" style=\"?android:attr/buttonBarButtonStyle\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"@string/previous\" /&gt; &lt;Button android:id=\"@+id/next\" style=\"?android:attr/buttonBarButtonStyle\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"@string/next\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 渲染pdf代码，pdf文档来源于asset目录下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208public class PdfRendererBasicFragment extends Fragment implements View.OnClickListener { /** * Key string for saving the state of current page index. */ private static final String STATE_CURRENT_PAGE_INDEX = \"current_page_index\"; /** * The filename of the PDF. */ private static final String FILENAME = \"sample.pdf\"; /** * File descriptor of the PDF. */ private ParcelFileDescriptor mFileDescriptor; /** * {@link android.graphics.pdf.PdfRenderer} to render the PDF. */ private PdfRenderer mPdfRenderer; /** * Page that is currently shown on the screen. */ private PdfRenderer.Page mCurrentPage; /** * {@link android.widget.ImageView} that shows a PDF page as a {@link android.graphics.Bitmap} */ private ImageView mImageView; /** * {@link android.widget.Button} to move to the previous page. */ private Button mButtonPrevious; /** * {@link android.widget.Button} to move to the next page. */ private Button mButtonNext; /** * PDF page index */ private int mPageIndex; public PdfRendererBasicFragment() { } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_pdf_renderer_basic, container, false); } @Override public void onViewCreated(View view, Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); // Retain view references. mImageView = (ImageView) view.findViewById(R.id.image); mButtonPrevious = (Button) view.findViewById(R.id.previous); mButtonNext = (Button) view.findViewById(R.id.next); // Bind events. mButtonPrevious.setOnClickListener(this); mButtonNext.setOnClickListener(this); mPageIndex = 0; // If there is a savedInstanceState (screen orientations, etc.), we restore the page index. if (null != savedInstanceState) { mPageIndex = savedInstanceState.getInt(STATE_CURRENT_PAGE_INDEX, 0); } } @Override public void onStart() { super.onStart(); try { openRenderer(getActivity()); showPage(mPageIndex); } catch (IOException e) { e.printStackTrace(); Toast.makeText(getActivity(), \"Error! \" + e.getMessage(), Toast.LENGTH_SHORT).show(); } } @Override public void onStop() { try { closeRenderer(); } catch (IOException e) { e.printStackTrace(); } super.onStop(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); if (null != mCurrentPage) { outState.putInt(STATE_CURRENT_PAGE_INDEX, mCurrentPage.getIndex()); } } /** * Sets up a {@link android.graphics.pdf.PdfRenderer} and related resources. */ private void openRenderer(Context context) throws IOException { // In this sample, we read a PDF from the assets directory. File file = new File(context.getCacheDir(), FILENAME); if (!file.exists()) { // Since PdfRenderer cannot handle the compressed asset file directly, we copy it into // the cache directory. InputStream asset = context.getAssets().open(FILENAME); FileOutputStream output = new FileOutputStream(file); final byte[] buffer = new byte[1024]; int size; while ((size = asset.read(buffer)) != -1) { output.write(buffer, 0, size); } asset.close(); output.close(); } mFileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY); // This is the PdfRenderer we use to render the PDF. if (mFileDescriptor != null) { mPdfRenderer = new PdfRenderer(mFileDescriptor); } } /** * Closes the {@link android.graphics.pdf.PdfRenderer} and related resources. * * @throws java.io.IOException When the PDF file cannot be closed. */ private void closeRenderer() throws IOException { if (null != mCurrentPage) { mCurrentPage.close(); } mPdfRenderer.close(); mFileDescriptor.close(); } /** * Shows the specified page of PDF to the screen. * * @param index The page index. */ private void showPage(int index) { if (mPdfRenderer.getPageCount() &lt;= index) { return; } // Make sure to close the current page before opening another one. if (null != mCurrentPage) { mCurrentPage.close(); } // Use `openPage` to open a specific page in PDF. mCurrentPage = mPdfRenderer.openPage(index); // Important: the destination bitmap must be ARGB (not RGB). Bitmap bitmap = Bitmap.createBitmap(mCurrentPage.getWidth(), mCurrentPage.getHeight(), Bitmap.Config.ARGB_8888); // Here, we render the page onto the Bitmap. // To render a portion of the page, use the second and third parameter. Pass nulls to get // the default result. // Pass either RENDER_MODE_FOR_DISPLAY or RENDER_MODE_FOR_PRINT for the last parameter. mCurrentPage.render(bitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY); // We are ready to show the Bitmap to user. mImageView.setImageBitmap(bitmap); updateUi(); } /** * Updates the state of 2 control buttons in response to the current page index. */ private void updateUi() { int index = mCurrentPage.getIndex(); int pageCount = mPdfRenderer.getPageCount(); mButtonPrevious.setEnabled(0 != index); mButtonNext.setEnabled(index + 1 &lt; pageCount); getActivity().setTitle(getString(R.string.app_name_with_index, index + 1, pageCount)); } /** * Gets the number of pages in the PDF. This method is marked as public for testing. * * @return The number of pages. */ public int getPageCount() { return mPdfRenderer.getPageCount(); } @Override public void onClick(View view) { switch (view.getId()) { case R.id.previous: { // Move to the previous page showPage(mCurrentPage.getIndex() - 1); break; } case R.id.next: { // Move to the next page showPage(mCurrentPage.getIndex() + 1); break; } } }}","link":"/2018/04/18/Android开发笔记/Android预览pdf文档/"},{"title":"子线程不可以更新UI吗","text":"子线程不可以更新UI吗？（2019-11-05）这里文章基于Android 系统8.0及以上版本分析子线程更新UI并没有报错的原因，其它版本并没有出现这种情况可以参考这篇文章子线程能更新UI吗。经常看到文章说不要在子线程更新UI，不要在UI线程进行耗时操作。偶然间的尝试发现了一些奇怪的问题，先分析第一个问题子线程中可以更新UI吗？下面是我的代码： 1234567891011121314151617@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); textView = findViewById(R.id.textView3); new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } textView.setText(\"子线程可以更新UI吗？\"); } }).start();} 点击运行之后，并没有出现我们预料中的崩溃和异常信息问题，即便我们在子线程中做了一些耗时操作。首先我们看一下我们希望预料之中出现的错误，然后根据堆栈分析错误信息为什么没有出现。 123android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:7753) at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1225) 根据堆栈信息分析，可以看出错误信息是在 ViewRootImpl.checkThread() 方法中抛出，我们先来看一下 checkThread() 方法： 1234567//ViewRootImpl.javavoid checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); }} 方法很简单判断 mThread（即 View 初始化所在线程）和当先线程比较，不是同一个线程就抛出以上异常信息。很明显我们之前的子线程和主线程的 TextView 并处在同一线程，但是为什么日志中没有看到对应的异常信息了，首先我们看一下 ViewRootImpl 中哪些方法调用了 checkThread() 方法，如下所示： 上述代码我们使用的是TextView，这里我们只分析父类View抛出异常信息的触发条件。我们挑选常见的 ViewRootImpl#requstLayout() 方法来分析具体的原因。我们来看一下 View#requestLayout() 方法： 1234567891011121314151617181920212223242526//View.javapublic void requestLayout() { if (mMeasureCache != null) mMeasureCache.clear(); if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) { // Only trigger request-during-layout logic if this is the view requesting it, // not the views in its parent hierarchy ViewRootImpl viewRoot = getViewRootImpl(); if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) { if (!viewRoot.requestLayoutDuringLayout(this)) { return; } } mAttachInfo.mViewRequestingLayout = this; } mPrivateFlags |= PFLAG_FORCE_LAYOUT; mPrivateFlags |= PFLAG_INVALIDATED; if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) { mParent.requestLayout(); } if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) { mAttachInfo.mViewRequestingLayout = null; }} 看一下第20行 mParent.requestLayout() 方法，其中 mParent 属于ViewParent 接口对象。从这篇文章关于View中mParent的来龙去脉中我们可以知道 mParent 为 ViewRootImpl（实现ViewParent接口）的具体实现，所以当我们调用 view#requestLayout 方法会出现预料之中的错误。其它的触发方法可以由此分析。我的总结是只有触发某些特定方法类似 View#requestLayout 等以及子类View比如TextView#setCompoundDrawables() 方法，才会出现某些异常退出，所以不推荐在子线程更新UI操作。（仅适用于Android 8以上设备。Android 7没有测试，Android 6.0 设备会出现异常信息并崩溃）。而我们上述的TextView#setText方法最终并没有调用checkThread()方法（不是某些文章提出的 ViewRootImpl 在 onResume 方法之前的原因，已验证 ），具体的原因可以对比一下Android6.0和Android8.0版本setText的源码和调试执行。待续…","link":"/2019/11/05/Android开发笔记/子线程不可以更新UI吗/"},{"title":"第2章：BroadcastReceiver广播接收器","text":"常见广播的使用场景： 同一app内有多个进程的不同组件之间的消息通信。 不同app之间的组件之间消息的通信。 有序广播和无序广播区别：无序广播是通过context.sendBroadcast(Intent)方法发送的广播，不可拦截，当然发送的数据接受者是无法进行修改的。 有序广播是通过context.sendOrderBroadcast(Intent)方法发送的广播，可被拦截，而且接受者是可以修改发送的数据的。下一个接受者接受的数据是上一个接受者修改过的。 本地广播123456// 发送本地广播private fun sendLocalBroadcast(context: Context, action: String) { val intent = Intent(action) LocalBroadcastManager.getInstance(context) .sendBroadcast(intent)} 123456// 注册本地广播 val localBroadcastManager = LocalBroadcastManager.getInstance(this) val intentFilter = IntentFilter() intentFilter.addAction(action) val nasbr = NextAndStartBroadcastReceiver() localBroadcastManager.registerReceiver(nasbr, intentFilter) 123456//广播接收器class NextAndStartBroadcastReceiver : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { Toast.makeText(context, \"本地广播测试\", Toast.LENGTH_SHORT).show() }} 广播接收器的静态注册和动态注册静态注册是指在 AndroidManifest.xml 清单文件中声明 receiver 标签并添加意图过滤器。意图过滤器中的 action 属性执行广播接收器接收的广播类型。 12345&lt;receiver android:name=\".StaticRegisterBroadcastReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 动态注册 1234567891011121314151617181920212223242526//网络状态广播接收器class NetworkChangeReceiver : BroadcastReceiver() { @RequiresPermission(Manifest.permission.ACCESS_NETWORK_STATE) override fun onReceive(context: Context?, intent: Intent?) { //获得ConnectivityManager对象 val connMgr = context?.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager //获取ConnectivityManager对象对应的NetworkInfo对象 //获取WIFI连接的信息 val wifiNetworkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI) //获取移动数据连接的信息 val dataNetworkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) if (wifiNetworkInfo.isConnected &amp;&amp; dataNetworkInfo.isConnected) { Toast.makeText(context, \"WIFI已连接,移动数据已连接\", Toast.LENGTH_SHORT).show() } else if (wifiNetworkInfo.isConnected &amp;&amp; !dataNetworkInfo.isConnected) { Toast.makeText(context, \"WIFI已连接,移动数据已断开\", Toast.LENGTH_SHORT).show() } else if (!wifiNetworkInfo.isConnected &amp;&amp; dataNetworkInfo.isConnected) { Toast.makeText(context, \"WIFI已断开,移动数据已连接\", Toast.LENGTH_SHORT).show() } else { Toast.makeText(context, \"WIFI已断开,移动数据已断开\", Toast.LENGTH_SHORT).show() } }} 12345// 注册广播接收器val networkFilter = IntentFilter()networkFilter.addAction(\"android.net.conn.CONNECTIVITY_CHANGE\")networkChangeReceiver = NetworkChangeReceiver();registerReceiver(networkChangeReceiver, networkFilter) 备注：需要在onDestory方法或者在此方法之前调用unregisterReceiver(networkChangeReceiver)解除注册，避免内存泄漏。 本地广播和系统广播源码角度分析本地广播 LocalBroadcastMananger 实现机制是通过 Handler 实现的。 系统广播实现机制和 Binder 有关。 待深入了解…","link":"/2018/11/01/Android开发笔记/第2章：BroadcastReceiver广播接收器/"},{"title":"第4章：Service知识点","text":"1. 什么是ServiceService` 是一种可在后台执行长时间运行操作而不提供界面的应用组件，服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行，此外，组件可通过绑定到服务与之进行交互，甚至是执行进程间通信（IPC）。例如，服务可在后台处理网络事务、播放音乐，执行文件I/O或内容提供程序进行交互。 前台 前台服务执行一些用户能注意到的操作。例如，音频应用会使用前台服务来播放音频曲目。前台服务必须显示通知。即使用户停止与应用的交互，前台服务仍会继续运行。 后台 后台任务执行用户不会直接注意到的操作。例如，如果应用使用某个服务来压缩其存储空间，则此服务通常是后台服务。 绑定 当应用组件通过调用 bindService() 绑定到服务时，服务即处于绑定状态。绑定服务会提供客户端-服务器接口，以便组件与服务进行交互、发送请求、接受结果，甚至是利用进程间通信（IPC）跨进程执行这些操作。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可同时绑定该服务，但全部取消绑定时，该服务即会被销毁。 2. startService() 和 bindService生命周期 3. 基础知识如要创建服务，您必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，您必须重写一些回调方法，从而处理服务生命周期的某些关键方面，并提供一种机制将组件绑定到服务（如适用）。以下是您应重写的最重要的回调方法： onStartCommand() 当另一个组件（如 Activity）请求启动服务时，系统会通过调用 startService() 来调用此方法。执行此方法时，服务即会启动并可在后台无限期运行。如果您实现此方法，则在服务工作完成后，您需负责通过调用 stopSelf() 或 stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。） onBind() 当另一个组件想要与服务绑定（例如执行 RPC）时，系统会通过调用 bindService() 来调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，以供客户端用来与服务进行通信。请务必实现此方法；但是，如果您并不希望允许绑定，则应返回 null。 onCreate() 首次创建服务时，系统会（在调用 onStartCommand() 或 onBind() 之前）调用此方法来执行一次性设置程序。如果服务已在运行，则不会调用此方法。 onDestroy() 当不再使用服务且准备将其销毁时，系统会调用此方法。服务应通过实现此方法来清理任何资源，如线程、注册的侦听器、接收器等。这是服务接收的最后一个调用。 4. Service 和 Thread 的区别简单地说，服务是一种即使用户未与应用交互也可在后台运行的组件，因此，只有在需要服务时才应创建服务。 如果您必须在主线程之外执行操作，但只在用户与您的应用交互时执行此操作，则应创建新线程。例如，如果您只是想在 Activity 运行的同时播放一些音乐，则可在 onCreate() 中创建线程，在 onStart() 中启动线程运行，然后在 onStop() 中停止线程。您还可考虑使用 AsyncTask 或 HandlerThread，而非传统的 Thread 类。如需了解有关线程的详细信息，请参阅进程和线程文档。 请记住，如果您确实要使用服务，则默认情况下，它仍会在应用的主线程中运行，因此，如果服务执行的是密集型或阻止性操作，则您仍应在服务内创建新线程。 5. Service 和 IntentService 区别Service 这是适用于所有服务的基类。扩展此类时，您必须创建用于执行所有服务工作的新线程，因为服务默认使用应用的主线程，这会降低应用正在运行的任何 Activity 的性能。 IntentService 这是 Service 的子类，其使用工作线程逐一处理所有启动请求。如果您不要求服务同时处理多个请求，此类为最佳选择。实现 onHandleIntent()，该方法会接收每个启动请求的 Intent，以便您执行后台工作。 123456789101112131415161718192021222324252627public class HelloIntentService extends IntentService { /** * A constructor is required, and must call the super &lt;code&gt;&lt;a href=\"/reference/android/app/IntentService.html#IntentService(java.lang.String)\"&gt;IntentService(String)&lt;/a&gt;&lt;/code&gt; * constructor with a name for the worker thread. */ public HelloIntentService() { super(\"HelloIntentService\"); } /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ @Override protected void onHandleIntent(Intent intent) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000); } catch (InterruptedException e) { // Restore interrupt status. Thread.currentThread().interrupt(); } }} 6. service 和 activity 之前如何通信startService 启动服务通信 12345678910public class RSSPullService extends IntentService { @Override protected void onHandleIntent(Intent workIntent) { // Gets data from the incoming Intent String dataString = workIntent.getDataString(); ... // Do work here, based on the contents of dataString ... }} bindService 启动服务通信方式 123456789101112131415161718192021222324252627public class LocalService extends Service { // Binder given to clients private final IBinder binder = new LocalBinder(); // Random number generator private final Random mGenerator = new Random(); /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don't need to deal with IPC. */ public class LocalBinder extends Binder { LocalService getService() { // Return this instance of LocalService so clients can call public methods return LocalService.this; } } @Override public IBinder onBind(Intent intent) { return binder; } /** method for clients */ public int getRandomNumber() { return mGenerator.nextInt(100); }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class BindingActivity extends Activity { LocalService mService; boolean mBound = false; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } @Override protected void onStart() { super.onStart(); // Bind to LocalService Intent intent = new Intent(this, LocalService.class); bindService(intent, connection, Context.BIND_AUTO_CREATE); } @Override protected void onStop() { super.onStop(); unbindService(connection); mBound = false; } /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ public void onButtonClick(View v) { if (mBound) { // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. int num = mService.getRandomNumber(); Toast.makeText(this, \"number: \" + num, Toast.LENGTH_SHORT).show(); } } /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName className, IBinder service) { // We've bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; } @Override public void onServiceDisconnected(ComponentName arg0) { mBound = false; } };} 7. Service 保活方法(1) 设置onStartCommand方法返回参数 1START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有待传递的挂起 Intent，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 1START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则其会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务，否则系统会调用包含空 Intent 的 onStartCommand()。在此情况下，系统会传递这些 Intent。此常量适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 1START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则其会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。所有挂起 Intent 均依次传递。此常量适用于主动执行应立即恢复的作业（例如下载文件）的服务。 (2) 提供服务优先级 1234567&lt;service android:name=\"com.dbjtech.acbxt.waiqin.UploadService\" android:enabled=\"true\" &gt; &lt;intent-filter android:priority=\"1000\" &gt; &lt;action android:name=\"com.dbjtech.myservice\" /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 或者设置服务所在进程： 1234561.前台进程( FOREGROUND_APP)2.可视进程(VISIBLE_APP )3.次要服务进程(SECONDARY_SERVER )4.后台进程 (HIDDEN_APP)5.内容供应节点(CONTENT_PROVIDER)6.空进程(EMPTY_APP) 将 service 设置为优先级最高的前台进程 12345678Notification notification = new Notification(R.drawable.ic_launcher, getString(R.string.app_name), System.currentTimeMillis()); PendingIntent pendingintent = PendingIntent.getActivity(this, 0, new Intent(this, AppMain.class), 0); notification.setLatestEventInfo(this, \"uploadservice\", \"请保持程序在后台运行\", pendingintent); startForeground(0x111, notification); (3) 广播唤醒 在 Service#onDestory() 方法中发送服务已终止消息，通过广播接收器来重新启动Service。 注册广播接收器： 1234567&lt;receiver android:name=\"com.dbjtech.acbxt.waiqin.BootReceiver\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;action android:name=\"android.intent.action.USER_PRESENT\" /&gt; &lt;action android:name=\"com.dbjtech.waiqin.destroy\" /&gt;//这个就是自定义的action &lt;/intent-filter&gt; &lt;/receiver&gt; 发送广播： 1234567@Override public void onDestroy() { stopForeground(true); Intent intent = new Intent(\"com.dbjtech.waiqin.destroy\"); sendBroadcast(intent); super.onDestroy(); } 参考文章https://developer.android.google.cn/guide/components/services https://www.cnblogs.com/blosaa/p/9530625.html","link":"/2018/11/01/Android开发笔记/第4章：Service知识点/"},{"title":"第1章：Activity基础知识点","text":"1.1 Activity是什么？Activity是用户与程序的窗口，使用前需要在清单文件中通过Actvity标签的android:name属性声明，Activity清单文件的属性配置可以参考官方说明。 1.2 典型状态下Activity的生命周期 1.3 正常情况下的生命周期分析启动Activity：onCreate –&gt; onStart –&gt; onResume 按下Home键：onPause –&gt; onStop 重新进入Activity ：onRestart –&gt; onStart –&gt; onResume 按下Back键：onPause –&gt; onStop –&gt; onDestroy 用户在重写onBackPress方法时候注意最终退出APP的时候最好还是调用super.onBackPress方法（官方推荐）。 关于onPause状态：Dialog弹出并不会调用该方法，onPause方法只有在Activity离开栈顶才会被调用。常见会出现只调用onPause而不调用onStop方法的两种情形： 第二个Activity的主题为Dialog主题 android:theme=&quot;@android:style/Theme.Dialog&quot; 第二个Activity主题为透明状态 android:theme=&quot;@android:style/Theme.Translucent&quot; 1.4 异常情况下Activity的生命周期&amp;数据如何恢复和保存异常情况下Activity会调用onSaveInstanceState保存当前状态，然后调用onDestory方法。再重新打开异常关闭的Activity，会调用onRestoreInstanceState方法恢复之前保存的状态。大部分View中都有重写这两个方法，无需用户重写保存状态。 1.5 Activity的启动模式及使用场景android:launchMode 共有四种模式，它们与代码中Intent中addFlag方法的标志位协同工作，确定Activity以何种方式启动。这些模式是：standard、singleTop、singleTask 和 singleInstance。 启动模式 多个实例？ 注释 standard 是 默认。系统时钟会在目标任务中创建新的Activity实例，并向其传送Intent。 singleTop 视情况而定 如果目标任务的顶部已存在Activity实例，则系统会通过该实例的onNewIntent()方法向其传送intent，而非&lt;br&gt;创建新的Activity实例。 singleTask 否 系统会在新任务的跟位置创建Activity并向其传送Intent。不过，如果已存在Activity实例，则系统会调用该实例的onNewintent()方法。 singleInstance 否 与“singleTask”相同，只是系统不会将任何其他activity 启动到包含实例的任务中。该Activity始终是其任务中的唯一Activity。 三个启动标志位（Using Intent flags）: FLAG_ACTIVITY_NEW_TASK：与在清单文件中指定的 android:launchMode = &quot;singleTask&quot;行为一致/ FLAG_ACTIVITY_SINGLE_TOP：与在清单文件中指定的 android:launchMode = &quot;singleTop&quot;行为一致。 FLAG_ACTIVITY_CLEAR_TOP：清楚任务栈中目标Activity上面的所有Activity。如果目标Activity的启动模式为Standard，也会将其删除并创建新的实例。因为standard模式始终创建新的实例。 1.6 Activity通信方式Activity之间通信方式： 两个Activity之间的跳转是通过Intent来实现，携带数据可以通过Intent#putExtra(String,String)方法实现 12345val intent = Intent(this,SecondActivity::class.java).apply{ putExtra(key,value); //...}startActivity(intent) 以Bundle的方式，Google推荐以Bundle的方式传递数据，Bundle对数据的编码解码进行了高度的优化 123456val bundle = Bundle().apply { putString(\"key\",\"value\")}val intent = Intent(this,SecondActivity::class.java).apply { putExtras(bundle)} Activity和Fragment之间通信方式 Activity –&gt; Fragment通信 通过setArgument(Bundle bundle)和getArgument方法实现。 Fragment –&gt; Activity通信，推荐回调的方式实现： 1234567891011121314151617181920212223242526272829public class FragmentA : ListFragment() { var listener: OnArticleSelectedListener? = null ... override fun onAttach(context: Context) { super.onAttach(context) listener = context as? OnArticleSelectedListener if (listener == null) { throw ClassCastException(\"$context must implement OnArticleSelectedListener\") } } fun setOnArticleSelectedListener(listener:OnArticleSelectedListener ){ this.listener = listener } override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) { // Append the clicked item's row ID with the content provider Uri val noteUri: Uri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id) // Send the event and Uri to the host activity listener?.onArticleSelected(noteUri) } // Container Activity must implement this interface interface OnArticleSelectedListener { fun onArticleSelected(articleUri: Uri) } ...} 宿主Activity需实现 OnArticleSelectedListener 接口，如未实现，运行时会直接报ClassCastException异常 1.7 Activity的显示启动和隐式启动显示启动这里不做过多介绍，这里讲一下几种隐式启动的常见使用场景： 一、分享相关 12345678910111213 &lt;!--提供外部APP可以调用的分享界面--&gt;&lt;activity android:name=\".ExampleActivity\" android:exported=\"true\" android:launchMode=\"singleTask\" android:taskAffinity=\"com.markzl.android.activitysample\" android:icon=\"@drawable/ic_launcher_foreground\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:mimeType=\"text/plain\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 在另一个APP中我们可以直接使用以下代码来调用该界面： 123456val sendIntent = Intent().apply { action = Intent.ACTION_SEND type = \"text/plain\" putExtra(Intent.EXTRA_TEXT,\"Message\")}startActivity(sendIntent) 隐式启动主要通过Intent Fliter，应用过滤器来实现。 二、通过链接打开APP（官网地址） Android应用链接是指将用户直接转到Android应用内特定内容的HTTP网址。要添加对Android应用链接的支持，请执行以下操作： 在清单中创建 Intent 过滤器。 将代码添加到应用的Activity中处理传入链接 使用Digital Asset Links 将应用与网站相关联 可以直接在清单文件中编辑，也可以通过 Tools &gt; App Links Assistant &gt; Open URL Mapping Editor 来编辑，如下所示： 1⃣️ Host 为输入的地址这里面是包含android:scheme=&quot;http&quot; 和 android:host=&quot;www.recipe-app.com &quot;两种属性的。 2⃣️ Path 主要分为 path、pathPrefix、pathPattern三个选项。区别是path是指定只有当前目录可以访问，pathPrefix是当前目录及当前目录的子目录都可以访问，pathPattern是匹配当前约束条件的都可以访问。 3⃣️ Activity 指定链接指向的Activity。 点击OK之后App Links Assistant 会根据您映射到 AndroidManifest.xml 文件的网址添加 Intent 过滤器： 12345678910&lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt; &lt;data android:host=\"www.recipe-app.com\" android:scheme=\"http\" android:pathPrefix=\"/recipe\" /&gt;&lt;/intent-filter&gt; 如何验证URL地址可以指向我们APP的特定APP？可以通过 Test App Link 选项来验证URL链接是否有效。 如何处理根据URL地址来让APP显示特定内容，即处理链接跳转的响应事件 12345678910111213141516171819202122232425override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) ... handleIntent(intent)}override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) handleIntent(intent)}private fun handleIntent(intent: Intent) { val appLinkAction = intent.action val appLinkData: Uri? = intent.data if (Intent.ACTION_VIEW == appLinkAction) { appLinkData?.lastPathSegment?.also { recipeId -&gt; Uri.parse(\"content://com.recipe_app/recipe/\") .buildUpon() .appendPath(recipeId) .build().also { appData -&gt; showRecipe(appData) } } }} 除此之外如果URL地址中携带参数，例如 scheme://host:port/pathPrefix?key=value 可以通过 intent.data.getQueryParameter(key) 来获取参数value。 将应用与网站相关联 打开 App Link Assistant 中的 Open Digital Links File Genenrator ，然后按照以下步骤操作： 输入您的 Site domain 和 Application ID。 要在 Digital Asset Links 文件中添加 Smart Lock（密码专用）支持，请选择 Support sharing credentials between the app and the website，然后输入网站的登录网址。此操作会将以下字符串添加到声明应用和网站共享登录凭据的 Digital Asset Links 文件中：delegate_permission/common.get_login_creds。详细了解如何在应用中支持 Smart Lock（密码专用）。 指定签名配置或选择密钥库文件。请确保为应用的发布版或调试版选择正确的配置或密钥库文件。如果要设置正式版，请使用版本配置。如果要测试版本，请使用调试配置。 点击 Generate Digital Asset Links file。 Android Studio 生成文件后，点击 Save file 进行下载。 将assetlinks.json文件上传到您的网站并允许所有人读取，网址为 https://&lt;yoursite&gt;/.well-known/assetlinks.json 。 重要提示：系统会通过加密的 HTTPS 协议验证 Digital Asset Links 文件。请确保无论应用的 Intent 过滤器是否包括 https，均可通过 HTTPS 连接访问 assetlinks.json 文件。 点击 Link and Verify 以确认您已将正确的 Digital Asset Links 文件上传到适当的位置。","link":"/2018/11/01/Android开发笔记/第1章：Activity基础知识点/"},{"title":"Java中NIO、BIO和AIO介绍","text":"原文链接：mp.weixin.qq.com BIO、NIO、AIO的基本定义和类比描述： BIO（Blocking I/O）: 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里使用那个经典的烧开水例子，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是，叫一个线程停留在一个水壶那，直到这个水壶烧开，采取处理下一个水壶。但是线程实际上在等待水壶烧开的时间段什么都没有做。 NIO（New I/O）: 同时支持阻塞和非阻塞模式，但这里我们以同步非阻塞来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。 AIO（Asynchronous I/O）:异步非阻塞I/O模型。异步非阻塞和同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。 进程中的IO调用步骤大致可以分为以下四步： 进程向操作系统请求数据； 操作系统把外部数据加载到内核的缓冲区中； 操作系统把内核的缓冲区拷贝到进程的缓冲区； 进程获得数据完成自己的功能； 当操作系统在把外部数据放入进程缓冲区的这段时间（即上述的第二、三步），如果应用进程是挂起等待的，那么就是同步IO，反之，就是异步IO，也就是AIO。 BIO（Blocking I/O）同步阻塞I/O这是最基本与简单的I/O操作方式，其根本特性是做完一件事再去做另一件事，一件事一定要等前一件事做完，这很符合程序员传统的顺序来开发思想，因此BIO模型程序开发起来较为简单，易于把握。 但是BIO如果需要同时做很多事情（例如同时读很多文件，处理很多tcp请求等），就需要系统创建很多线程来完成对应的工作，因为BIO模型下一个线程同时只能做一个工作，如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态，我们知道在整个操作系统中，线程是系统执行的基本单位，在BIO模型下的线程阻塞就会导致系统线程的切换，从而对整个系统性能造成一定的影响。当然如果我们只需要创建少量可控的线程，那么采用BIO模型也是很好的选择，但如果在需要考虑高并发的web或者tcp服务器中采用BIO模型就无法应对了，如果系统开辟成千上万的线程，那么CPU的执行时间都会浪费在线程的切换中，使得线程的执行效率大大降低。此外，关于线程这里说一句题外话，在系统开发中线程的生命周期一定要准确控制，在需要一定规模并发的情形下，尽量使用线程池来确保线程创建数目在一个合理的范围之内，切莫编写线程数量创建上线的代码。 NIO（New I/O）同步非阻塞I/ONIO本身是基于事件驱动的思想来实现的，其目的就是解决BIO的大并发问题，在BIO模型中，如果需要并发处理多个I/O请求，那就需要多线程来支持，NIO使用了多路复用器机制，以socket使用来说，多路复用器通过不断轮询各个连接的状态，只有在socket有流可读或者可写时，应用程序才需要去处理它，在线程的使用上，就不需要一个连接就必须使用一个处理线程了，而是只是有效请求时（确实需要进行I/O处理时），才会使用一个线程去处理，这样就避免了BIO模型下大量线程处于阻塞等待状态的情景。 相对于BIO的流，NIO抽象出了新的通道（Channel）作为输入输出的通道，并且提供了缓存（Buffer）的支持，在进行读操作时，需要使用Buffer分配空间，然后将数据从Channel中读入Buffer中，对于Channel的写操作，也需要先将数据写入Buffer，然后将Buffer写入Channel中。 如下时NIO方式进行文件拷贝操作的示例： 12345678910111213141516171819202122public static void copyFile(String srcFileName,String destFileName) throws IOException { FileInputStream fileInputStream = new FileInputStream(srcFileName); FileOutputStream fileOutputStream = new FileOutputStream(destFileName); FileChannel readChannel = fileInputStream.getChannel(); FileChannel writeChannel = fileOutputStream.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); while(true){ buffer.clear();//清空缓存区 if(readChannel.read(buffer)==-1){ break; } //将缓冲区从写模式切换到读模式 buffer.flip(); writeChannel.write(buffer); } fileInputStream.close(); fileOutputStream.close(); } 通过比较New IO的使用方式我们可以发现，新的IO操作不在面向Stream来进行操作了，改为通道Channel，并且使用了更加灵活的缓存区类Buffer，Buffer只是缓存区定义接口，根据需要，我们可以选择对应类型的缓存区实现类。在java NIO编程中，我们需要理解以下三个对象Channel、Buffer和Selector。 Channel 首先说一下Channel，国内大多翻译成“通道”。Channel和IO中Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream,OutputStream。而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作，NIO中的Channel的主要实现有：FileChannel、DatagranChannel、SocketChannel、ServerSocketChannel。 Buffer NIO中的关键Buffer实现有：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer，分别对应基本数据类型：byte、char、double、int、long、short。当然NIO中还有MappedByteBuffer、HeapByteBuffer、DirectByteBuffer等这里先不具体陈述其具体细节。 说一下DirectByteBuffer与HeapByteBuffer的区别？ 它们ByteBuffer分配内存的两种方式。HeapByteBuffer顾名思义其内存空间在JVM的heap（堆）上分配，可以看作是jdk对于byte[]数组的封装；而DirectByteBuffer则直接利用了系统接口进行内存申请，其内存分配在cheap中，这样就减少了内存之间的拷贝操作，如此一来，在使用DirectByteBuffer时，系统就可以直接从内存将数据写入到Channel中，而无需进行Java堆的内存申请，复制等操作，提高了性能。既然如此，为什么不直接使用DirectByteBuffer，还要来个HeapByteBuffer？原因在于，DirectByteBuffer是通过full gc来回收内存的，DirectByteBuffer会自己检测情况而调用system.gc()，但是如果参数中使用了DisableExplicitGC那么就无法回收该块内存了，-XX:+DisableExplicitGC标志自动将System.gc()调用转换成一个空操作，就是应用中调用System.gc()转换成一个空操作，就是应用中调用System.gc()会变成一个空操作，那么如果设置了就需要我们手动来回收内存了，所以DirectByteBuffer使用起来相对于完全托管于java内存管理的Heap ByteBuffer来说更复杂一些，如果用不好可能会引起OOM。Direct ByteBuffer的内存大小受-XX:MaxDirectMemorySize JVM参数控制（默认大小64M），在DirectByteBuffer申请内存空间达到该设置大小后，会触发Full GC。 Selector Selector是NIO相对于BIO实现多路复用的基础，Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有时间就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。 这里我们再来看一下NIO模型下的TCP服务器的实现，我们可以看到Selector正是NIO模型下TCPServer实现IO复用的关键，请仔细理解下端代码while循环中的逻辑，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private static int TIMEOUT = 3000;public static void nioTcpServer(int listenPort) throws IOException { //创建一个选择器 Selector selector = Selector.open(); //实例化一个信道 ServerSocketChannel listenChannel = ServerSocketChannel.open(); //将该信道绑定到指定端口 listenChannel.socket().bind(new InetSocketAddress(listenPort)); //配置信道为非阻塞模式 listenChannel.configureBlocking(false); //将选择器注册到各个信道 listenChannel.register(selector, SelectionKey.OP_ACCEPT); //不断轮询select方法，获取准备好的信道所关联的Key集 while (true) { //一直等待，直至有信道准备好了I/O操作 if (selector.select(TIMEOUT) == 0) { //在等待信道准备的同时，也可以异步地执行其它任务 continue; } //获取准备好的信道所关联的Key集合的iterator实例 Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator(); //循环取得集合中的每个键值 while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); //如果服务端信道感兴趣的I/O操作为accept if (key.isAcceptable()) { handleAccept(key); } //如果客户端信道感兴趣的I/O操作为read if (key.isReadable()) { handleAccept(key); } //如果该键值有效，并且其对应的客户端信道感兴趣的I/O操作为write if (key.isValid() &amp;&amp; key.isWritable()) { handleWrite(key); } //这里需要手动从键集中移除当前的key keyIterator.remove(); } }} AIO（Asynchronous I/O）异步非阻塞I/OJava AIO就是Java作为对异步IO提供支持的NIO.2，Java NIO2（JSR 203）定义了更多的New I/O APIS，提案2003年提出，知道2011年才发布，最终在JDK7中实现。JSR 203除了提供更多的文件操作系统API（包括可插拔的自定义的文件系统），还提供了对socket和文件的异步I/O操作。同时实现了JSR-51天中的socket channel全部功能，包括对绑定，option配置的支持以及多播multicast的实现。 从编程模式上来看AIO相对于NIO的区别在于，NIO需要使用者线程不停的轮询IO对象，来确定是否有数据准备好可以读了，而AIO则是在数据准备好之后，才会通知数据使用者，这样使用者就不需要不停地轮询了。当然AIO的异步特性并不是Java实现的伪异步，而是使用了系统底层API的支持，在Unix系统下，采用了epoll IO模型，而windows便是使用了IOCP模型。关于Java AIO，本篇只做一个抛砖引玉的介绍，如果你在实际工作中用到了，那么可以参考Netty在高并发下使用AIO的相关技术。 总结 IO实质上与线程没有太多的关系，但是不同的IO模型改变了应用程序使用线程的方式，NIO与AIO的出现解决了很多BIO无法解决的并发问题，当然任何技术抛开使用场景都是耍流氓，复杂的技术往往是为了解决简单技术无法解决的问题而设计的，在系统开发中能用常规技术解决的问题，绝不用复杂技术，否则大大增加系统代码的维护难度，学习IT技术不是为了炫技，而是要实实在在解决问题。","link":"/2018/10/17/Java笔记/Java中NIO、BIO和AIO介绍/"},{"title":"Java基础知识点","text":"面向过程编程和面向对象编程的区别在于：面向过程编程强调的是整个软件系统由一个个函数构成，最小的程序单元是函数，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统的设计。 面向对象的设计是使所需要的对象具备某些功能，强调的是具备某些功能的对象。面向对象主要有三大特征：封装（Encapsulation），继承（Inheritance），多态（Polymorphism）。 面向对象的特征 封装：封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的”高内聚、低耦合“，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。 继承: 继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。 多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行时才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能确定。多态性增强了程序的灵活性和扩展性。 接口和抽象类区别接口的特点： 接口中的方法，永远都被public来修饰 接口中没有构造方法，也不能实例化接口对象 接口中只有方法的声明，没有方法体 接口中只有常量，如果定义变量，在编译的时候会默认加上“public static final” 接口中定义的方法都需要实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需定义为抽象类 静态方法不能被子类覆盖（隐藏），因此接口中不定声明静态方法 使用接口可以实现多继承 抽象类关键字和哪些关键字不能共存？ final：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。 private：抽象类中的私有的抽象方法，不被子类所致，就无法被复写。而抽象方法出现的就是需要被复写。 static：如果static可以修饰抽象方法，直接类名调用就可以了。 抽象类的特点 如果一个类中有抽象方法，那么这个类一定是抽象类 抽象类中不一定有抽象方法 抽象类中的所有抽象方法需要有子类实现，如果子类不实现，则子类也需要定义为抽象的 抽象类不可以用new创建对象，因为调用抽象方法没意义 权限修饰符public: 任何地方都可以访问 protected: 同包中的类和不同包的子类中可以访问，但是protected关键字不可以修饰类名 default：缺省包只有相同包和相同包下的子类可以访问。 private: 本类内可以访问。 对象生命周期创建阶段（Created）、应用阶段（In Use）、不可见阶段（Invisible）、不可达阶段（Unreachable）、收集阶段（collected）、终结阶段（Finalized）、对象空间重分配阶段（De-allocated）。 static 关键字 在静态方法中不能直接访问实例方法和实例变量 在静态方法中不能使用this和super关键字 静态方法不能被abstract修饰 当类被加载时，静态代码块只能被执行一次。 静态属性和静态方法能被继承吗？静态方法是否能被重写呢？ 静态属性和静态方法可以被继承和重写，但无法实现多态。 final 关键字 final 变量必须被显式初始化，并且只能被赋一次值 final 修饰基本类型变量的时候，该变量不能重新赋值 final 修饰引用类型变量的时候，该变量不能重新指向其他对象 final 修饰的方法为最终的方法，该方法不能被重写 private 类型的方法都默认为是final方法，因而也不能被子类重写 final修饰的类为最终的类，不能被继承。 八大基本数据类型&amp;引用类型基本数据类型： 简单类型 boolean byte char short int long float double void 二进制位数 1 8 16 16 32 64 32 64 - 封装器类 Boolean Byte Character Short Integer Long Float Double Void 初始值 false 0 0 0 0 0.0 0.0 - 引用类型： Java有5种引用类型（对象类型）：类 接口 数组 枚举 标注。引用类型的初始值为 null 堆内存和栈内存详解Java 把内存分为两种，一种叫做栈内存，一种叫做堆内存 1String s; 这里创建对象的引用，并非对象。直接使用会报错，因为没有赋值-指向任何对象。 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。 ​ 堆内存：用于存放由new创建的对象或数组。在堆中分配的内存，有java虚拟机自动回收器来管理。在堆中产生一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的别名或者代号。 ​ 栈内存：引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组&amp;对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的对象，这就是Java中的指针。 总结： 栈内存中保存的是对象的引用，而Java对象保存在堆内存上。 参考资料 https://blog.csdn.net/Xk632172748/article/details/51755438 https://www.cnblogs.com/xiaoxi/p/6392154.html https://blog.csdn.net/u014266877/article/details/54374867","link":"/2018/10/10/Java笔记/Java基础知识点/"},{"title":"Java异常详解","text":"摘要 (来自于 Java编程思想) Java 的基本理念是“结构不佳的代码不能运行”。 改进的错误恢复机制是提高代码健壮性的最强有力的方式。错误恢复在我们所编写的每一个程序中都是基本的要素，但是在 Java 中它显得格外重要，因为 Java 的主要目标之一就是创建供他人使用的程序构件。发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。然而，编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。这就需要错误源能通过某种方式，把适当的信息传递给某个接受者–该接受者将知道如何正确处理这个问题。 异常往往能降低错误代码的复杂度的。如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它。而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误。总结，与普通的错误处理方法相比，异常处理方式使程序更加简洁、清晰，同时方便我们定位错误和处理错误。 Java 异常分类 所有异常的父类都是Throwable。 Error表示Java系统中出现了一个非常严重的异常错误，并且这个错误可能是应用程序所不能恢复的，例如LinkageError，或 ThreadDeath 等。 Java Exception和Error区别Exception: 可以是可被控制（checked）或者不可控制（unchecked）； 表示一个由程序员导致的错误； 应该在应用程序级被处理； Error: 总是不可控制的（unchecked）； 经常用来表示系统错误或者底层资源错误； 如果可能的话，应该系统级被捕捉； Java 检查异常、非检查异常、运行时异常、非运行时异常的区别Java的异常（Throwable，Exception和Error的父类）分为检查异常和非检查的异常。 检查异常： 就是编译器要求你必须处理的异常。比如我们在编程某个文件的读写时，编译器要求你必须对某段代码进行try…catch…或者throws exception，这就是检查异常。即在程序运行之前，编译器就会要求处理的异常被称为检查异常。 检查异常包括除了RuntimeException与其派生类（子类），以及错误（Error）之外，其它差不多都是检查异常。 非检查异常： 编译器不要求强制处置的异常，虽然可能出现错误，但是我不会在编译的时候检查。这类异常我们一般是不处理的，因为很难判断会出现什么问题，而且有些异常你也无法在编译时处理，比如空指针。 非检查异常包括 RuntimeException及其子类，以及错误（Error） Exception异常进行划分，它可分为运行时异常和非运行时异常 运行时异常： 都是RuntimeException类及其子类异常，如NullpointerException(空指针异常)、IndexArrayOutRangeException(下标越界异常)等，这些异常都是非检查异常，程序可以选择捕获处理，也可以不处理。这些异常一般有程序逻辑错误引起，程序应该尽可能从逻辑角度避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现运行时异常，即使没有try…catch…捕获它，也没有throws声明抛出它，也会编译通过。 常见的运行时异常：NullPointerException、ArrayIndexOutOfBoundsException、IndexOutOfBoundsException、ArrayIndexOutOfBoundsException、NumberFormatException、IllegalArgumentException等等。 非运行时异常： 是RuntimeException意外的异常，类型上都属于Exception类及其子类。属于必须在编译时处理的异常，否则就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况不要自定义检查异常。 Java 自定义异常用户自定义异常属于非运行时异常，需要在程序编译时处理。 1234567891011121314151617181920212223242526272829public class Main { public static void main(String[] args) { try { new Main().age(16); } catch (IllegalAgeException e) { e.printStackTrace(); } } private void age(int age) throws IllegalAgeException{ if (age &lt; 18) { throw new IllegalAgeException(\"\"); } System.out.println(\"age = [\" + age + \"]\"); }}class IllegalAgeException extends Exception { public IllegalAgeException() { this(\"\"); } public IllegalAgeException(String message) { super(\"年龄不合法\"); }} Java throw关键字和throws关键字区别 throws抛出的是可能出现的异常，需要用户手动处理异常，throw是明确程序这个地方需要抛出指定的异常对象。 throws出现在方法函数头；而throw出现在函数体。 throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定报出了某种异常。 两种都是消极处理异常的方式，这里的消极并不是说这种方式不好，只是抛出或者可能抛出异常，但是不会有函数本身去处理异常，真正的处理异常由函数的上层调用处理。12345678throw 语法： throw 异常对象 throw new IllegalArgumentException(\" u can't ...\");throws 是方法可能会抛出的异常的声明。throws 语法： [(修饰符)(返回值)(方法名)([参数列表])[thows (异常类)]{...} public void doA(int a) throws ExceptionA{....} 捕获异常try{}catch{}finally{} 常见使用形式： 12345try{} catch{}try{} finally{}try{} catch{} finally{} finally 关键字的特点及作用 特点被 finally 控制的语句一定会执行。特殊情况：在执行到finally之前jvm推出了（比如System.exit(0)），finally块语句将不会被执行 作用 一般在IO流操作或者数据库操作最后释放资源。 即使有return关键字，程序也会在返回之前执行finally代码块。 123456789101112 public static void main(String[] args) { try { System.out.println(1/0); }catch (Exception e){ System.out.println(\"除数不可以为0\");// System.exit(0);//退出JVM虚拟机 return; }finally { System.out.println(\"看看执行了没有\"); } } 打印结果： 除数不可以为0 看看执行了没有 Process finished with exit code 0 参考资料https://www.cnblogs.com/yiwangzhibujian/p/7141390.html https://www.cnblogs.com/sishuiliuyun/p/4421767.html https://www.cnblogs.com/oukele/p/10035238.html 《Java编程思想》","link":"/2018/10/17/Java笔记/Java异常详解/"},{"title":"Java线程详解","text":"并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务（也被称为子任务）中的每一个都将执行线程来驱动。一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以用于多个并发执行的任务，但是你的程序使得每个任务都好像有自己的CPU一样。其底层机制是切分CPU时间，但通常你不需要考虑它。 1. 线程的生命周期线程的生命周期主要有五种状态：新建（New）、就绪（Runable）、运行（Running）、阻塞（Blocking）和死亡（Death）。 线程在运行过程中，不可能一直占用CPU，CPU会在多个线程之前来回切换，所以线程的状态也会随时在运行和阻塞状态切换： 新建状态，使用 New 关键字创建线程对象，线程就处于新建状态。此时仅由JVM分配内存空间，初始化其变量。 就绪状态，调用Thread#start方法，线程处于就绪状态。JVM虚拟机会为其创建方法调用栈和程序计数器，等待CPU调度进入运行状态。 运行状态，CPU准备就绪，调用Thread#run方法执行方法体，此时线程处于运行状态。 阻塞状态，处于运行状态的线程失去CPU为其分配的资源，线程进入阻塞状态。 死亡状态，线程执行正常结束或因抛出Exception或Error而终止，线程进入死亡状态。 2. 终止线程的三个方法 通过线程run方法中标志位实现 使用Thread#stop方法实现，这个方法不推荐使用。（因为与suspend、resume一样可能出现意料以外的情况。 使用Thread#interrupt方法终止线程 3. 线程池（ExecutorService Executors）Thread.yield() 线程调度器（Java线程机制的一部分，可以将CPU从一个线程转移到另一个线程的一种建议），它在声明“我已执行完生命周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机” CacheThreadPool：为每一个任务都创建一个线程。 1ExecutorService executor = Executors.newCachedThreadPool(); FixedThradPool：创建有限的线程集执行任务。 1ExecutorService executor = Executors.newFixedThreadPool(5); 使用FixedThreadPool，可以限制线程的数量，不必为每个任务都固定地付出创建线程的开销。 SingleThreadExecutor：是线程数量为1的FixedThreadPool。 1ExecutorService executor = Executors.newSingleThreadExecutor(); 即便向SingleThreadExecutor中提交了多个任务，这些任务依旧会排队执行，每个任务都会在下一个任务之前运行结束，所有的任务都使用相同的线程。 如何使用线程池执行任务？调用 ExecutorService#execute(Runable) 执行任务， ExecutorService#shutdown() 方法可以防止新任务提交给Executor，当前线程将继续执行 shutdown 方法被调用之前提交的任务，在任务完成时退出。 3.1 ThreadFactory 和 ThreadPoolExecutor 的概念123456789// 创建线程的工厂public class DaemonThreadFactory implements ThreadFactory { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.setDaemon(true); return thread; }} 1234567public class DaemonThreadPoolExecutor extends ThreadPoolExecutor { public DaemonThreadPoolExecutor(){ super(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;(),new DaemonThreadFactory()); }} 3.2 执行任务的返回值 Callable&lt;T&gt;其实Callable 和 Runnable 的区别就是多一个返回值，看一下Callable类: 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;} 执行任务的返回值调用 ExecutorService#submit(Callable)方法而不是 execute(Runable) 方法，返回值类型如下： 1&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); 3.3 设置线程的优先级1Thread.currentThread().setPriority(priority); 常用 Thread.MIN_PRIORITY、Thread.NORM_PRIORITY 和 Thrad.MAX_PRIORITY。 ###3.4 让步 Thread.yield() 方法是线程调度机制的一个暗示，表示所在线程的工作已经做得差不多了，可以让别的线程使用CPU了。这个暗示将通过调用yield()方法来作出（不过这只是一个暗示，没有任何机制保证它将会被采纳）。 3.5 后台线程后台（daemon）线程是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序不可或缺的部分。因此，当所有非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。 123Thread daemon = new Thread(new SimpleDaemons());daemon.setDaemon(true);// Must call before start()daemon.start(); 如果一个线程是后台线程，那么由这个线程创建的所有线程都属于后台线程。 后台线程中不执行 finally 语句的情况下就会终止其 run() 方法。 1234567891011121314151617181920class ADaemon implements Runnable{ @Override public void run() { System.out.println(\"Starting ADaemon\"); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { System.out.println(\"Exiting via InterruptException\"); }finally { System.out.println(\"This should always run?\"); } }}public class DaemonsDontRunFinally { public static void main(String[] args) { Thread thread = new Thread(new ADaemon()); thread.setDaemon(true); thread.start(); }} 3.6 join() 方法当一个线程例如 Joiner 线程中调用另一个线程 Sleeper#join() 方法，那么 Joiner 线程将会被挂起，知道目标线程 Sleeper 执行完毕才恢复（即 Sleeper#isAlive() 方法返回值为 false ）。join() 方法可以携带一个超时参数，若指定时间内目标线程没有执行完毕，会返回挂起的线程内执行。调用Thread#interrupt() 方法同样可以中断目标线程回到挂起线程。 3.7 线程的应用Java使用线程的应用之一就是实现响应式界面，一边可以在线程中计算，一边可以响应用户输入或者操作界面。如下所示： 12345678910111213141516171819202122232425262728class UnresponsiveUI{ private volatile double d = 1; public UnresponsiveUI() throws IOException { while (d&gt;0) d = d+(Math.PI+Math.E)/d; System.in.read(); }}public class ResponsiveUI extends Thread { private static volatile double d = 1; public ResponsiveUI(){ setDaemon(true); start(); } @Override public void run() { while (true){ d = d +(Math.PI + Math.E) /d; } } public static void main(String[] args) throws IOException { new ResponsiveUI(); System.in.read(); System.out.println(d); }} 如果使用 UnresponsiveUI 类，那么界面会进入死循环，无法响应用户输入。而对于 ResponsiveUI 类来说，计算耗时操作会放在后台线程中，main 方法负责响应用户输入，在控制台输入任意字符，按下回车程序将自动退出。 3.8 线程异常捕获线程异常无法通过 try…catch… 语句捕获，线程中的异常会直接输入到控制台，例如 12345678910111213141516171819202122232425public class ExceptionThread implements Runnable { @Override public void run() { throw new RuntimeException(); } public static void main(String[] args) { try { ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(new ExceptionThread()); } catch (Exception e) { System.out.println(\"Exception has been handled!\"); } }}/* outputsException in thread \"pool-1-thread-1\" java.lang.RuntimeException at concurrency.ExceptionThread.run(ExceptionThread.java:9) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)Process finished with exit code 0*/ 可以通过 Thread#setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler) 方法实现对异常的捕获 123456789101112class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler { @Override public void uncaughtException(Thread t, Throwable e) { System.out.println(\"caught \" + e); }}public static void main(String[] args) { ... thread.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler()); ...} 4. 共享受限资源Java的自增运算符自身需要多个步骤，并且在递增过程中任务可能会被线程机制挂起——也就是说 Java 的自增运算符不是原子性的操作。 4.1 线程锁声明 synchronized 方法的方式： 12synchronized void f(){/* ... */}synchronized void g(){/* ... */} 所有的对象对自动含有单一的锁。当在对象上调用任意 synchronized 方法的时候，此对象会被加锁，这时该对象上的其他 synchronized 方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。对于前面的方法，如果某个任务对象调用了 f() ，对于同一个对象而言，就只有等到 f() 调用结束并释放了锁之后，其他任务才能调用 f() 和 g() 。所以，对于某个特定对象而言，其所有 synchronized 方法共享一个锁，这可以被用来防止多个任务同时访问被编码为对象内存。 注意，在使用并发时，将域设置为 private 是非常重要的，否则，synchronized 关键字就不能防止其他任务直接访问，这样就会产生冲突。 123456789101112131415public class EventGenerator extends IntGenerator { private int currentEventValue = 0; @Override public synchronized int next() { ++currentEventValue; ++currentEventValue; return currentEventValue; } public static void main(String[] args) { EvenChecker.test(new EventGenerator()); }} synchronized 同步控制块，在调用synchronized控制代码段时，必须获取到syncObject对象的锁。如果其他线程已经得到这个锁，那么就得等到这个锁释放之后才可以继续调用。 123synchronized(syncObject){ // This code can be accessed by only one task at one time} 使用同步控制块而不是对整个方法进行同步的原因是，同步代码块对象不加锁时间更长，使得其他线程更多地访问（在安全的情况下尽可能多）。 4.2 使用显式的 Lock 对象Java SE5的java.util.concurrent类库还包含有定义在java.util.concurrent.locks中的显式的互斥机制。Lock对象必须被显式地创建、锁定和释放。 1234567891011121314151617181920212223public class MutexEventGennerator extends IntGenerator { private int currentEventValue = 0; private Lock lock = new ReentrantLock(); @Override public int next() { lock.lock(); try { ++currentEventValue; Thread.yield(); ++currentEventValue; return currentEventValue; } finally { // 在执行完return语句之后执行 lock.unlock(); } } public static void main(String[] args) { EvenChecker.test(new MutexEventGennerator()); }} 注意在使用synchronized关键字时不能尝试获取锁且最终会获取失败。 4.3 原子性与易变性关于Java线程，经常的错误性认知“ 原子操作不需要进行同步控制 ”。原子操作是不能被线程调度机制中断的操作。 volatile关键字确保了应用的可见性，如果你将一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作都可以看到这个修改。volatile 域会立即被写入到主存中（而不是各个线程的工作线程），而读取操作就发生在主存中。非volatile域上的原子操作不必刷新到主存中去，因此其他读取该域的任务看不到这个新值。同步操作synchronized也会导致在主存中刷新，因此如果一个域完全由synchronized方法或语句来防护，那就不必将其设置为volatile。 volatile 关键字不适用的场景： 当一个域的值依赖于它之前的值时（例如递增一个计数器） 当一个域的值受其他域的值的限制（例如Range类的lower和upper边界就必须遵循lower&lt;=upper的限制） 推荐使用synchronized关键字保证并发的正确性，使用volatile关键字并不能保证所有操作的原子性。 4.4 原子类AtomicInteger、AtomicLong、AtomicReference，可以通过使用AtomicInteger而消除synchronized 关键字。 1234567891011121314151617181920212223242526272829303132333435public class AtomicIntegerTest implements Runnable { private AtomicInteger i = new AtomicInteger(0); private int getValue(){return i.get();} private void evenIncrement(){ i.addAndGet(2); } @Override public void run() { while (true) evenIncrement(); } public static void main(String[] args) { new Timer().schedule(new TimerTask() { @Override public void run() { System.err.println(\"Aborting\"); System.exit(0); } },5000); ExecutorService executorService = Executors.newCachedThreadPool(); AtomicIntegerTest at = new AtomicIntegerTest(); executorService.execute(at); while (true){ int val = at.getValue(); if(val%2 !=0){ System.out.println(val); System.exit(0); } } }} 4.5 线程本地存储防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。因此，如果你有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储块。主要是，它们使得你可以将状态与线程关联起来。创建和管理线程本地存储可以由java.lang.ThreadLocal类来实现，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Accessor implements Runnable{ private final int id; public Accessor(int id){ this.id = id; } @Override public void run() { while(!Thread.currentThread().isInterrupted()){ ThreadLocalVariableHolder.increment(); System.out.println(this); Thread.yield(); } } @Override public String toString() { return \"#\"+id+\": \"+ThreadLocalVariableHolder.get(); }}public class ThreadLocalVariableHolder { private static ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;(){ private Random random = new Random(47); protected synchronized Integer initialValue() { return random.nextInt(10000); } }; public static void increment(){ value.set(value.get()+1); } public static int get(){return value.get();} public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.newCachedThreadPool(); for(int i = 0; i&lt;5;i++){ executorService.execute(new Accessor(i)); } TimeUnit.SECONDS.sleep(3); executorService.shutdownNow(); }} ThreadLocal对象通常用作静态域存储。在创建ThreadLocal时，你只能通过get() 和 set() 来访问该对象的内容。 5 终结任务5.2 在阻塞时终结线程状态：新建、就绪、阻塞、死亡 参考资料 https://www.cnblogs.com/sunddenly/p/4106562.html https://www.cnblogs.com/sunrunzhi/p/3930297.html","link":"/2018/10/21/Java笔记/Java线程详解/"},{"title":"Java内部类详解","text":"内部类的定义：一个定义在另一个类中的类，叫做内部类。内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性。然而必须要了解，内部类与组合是完全不同的概念，这一点很重要。在最初，内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。但是，你将会了解到，内部类远不止如此，它了解外部类，并能与之通信，而且你用内部类写出的代码更加更加优雅而清晰，尽管并不总是这样（而且Java8的Lambda表达式和方法引用减少了编写内部类的需求）。 成员内部类成员内部类是最普通的内部类，它的定义是位于另外一个类的内部，如下所示： 123456789101112class Outer{ private Inner inner = null; public Outer(){} class Inner{ public Inner(){ } }} 这里，类Outer被称为外部类，Inner就是我们通常称呼的成员内部类。成员内部类可以无条件访问外部类中的所有成员属性和成员方法（包括private成员和静态成员）。不过要注意的是当成员内部类出现和外部类相同名称的成员变量或方法时，默认使用的内部类中定义的成员变量或方法。如果要使用外部类中的属性和方法，可以通过以下方式访问： 12外部类.this.成员变量外部类.this.方法 在外部类中如果想要访问内部类中的成员变量或方法，必须创建一个成员内部类对象，再通过指向这个对象的引用来访问。 成员内部类是依靠外部类而存在的，所以说要想生成成员内部类的对象，必须先创建外部类对象。 1234567891011121314151617181920public class Main { public static void main(String[] args) { Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); }}class Outer{ private Inner inner = null; public Outer(){} class Inner{ public Inner(){ } }} 内部类可以拥有private访问权限、protext访问权限、public访问权限以及包访问权限。而外部类只能被public和包访问两种权限修饰。 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它与成员内部类的区别在于局部内部类的访问仅限于该方法内或该作用域内。 1234567891011121314151617class People { public People() { }}class Man { public Man() { } public People getWomen() { class Women extends People { int age = 11; } return new Women(); }} 匿名内部类匿名内部类的使用一般是用来编写事件监听代码。同样匿名内部类不能有访问修饰符和static修饰符。匿名内部类主要用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或重写。 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类名前面添加了static关键字，静态内部类是不需要依赖外部类的。并且它不能使用外部类的非static成员变量或方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员变量必须依赖于具体的对象。 123456789101112131415161718192021public class Main { public static void main(String[] args) { Outer.Inner inner = new Outer.Inner(); }}class Outer { private Inner inner = null; public Outer() { } static class Inner { public Inner() { } }} 闭包（closure）和回调 闭包的价值在于可以作为函数对象或者匿名函数，持有上下文数据，作为第一级对象进行传递和保存。 闭包广泛用于回调函数、函数式编程中。 Java中，闭包是通过“接口+内部类”实现，Java内部类也可以有匿名内部类。 闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部类对象（创建内部类的作用域）的信息，还自动拥有指向外部类对象的引用，在此作用域内，内部类有权操作所有的成员。 12345678910111213141516171819202122232425262728293031323334class Writer{ void work(){};}interface programmer{ void work();}class WriterProgrammer extends Writer{ @Override void work() { super.work(); } void code(){ // } programmer getProgrammer(){ return new ProgrammerInner(); } public static void main(String[] args) { WriterProgrammer writerProgrammer = new WriterProgrammer(); writerProgrammer.getProgrammer().work(); } class ProgrammerInner implements programmer{ @Override public void work() { code(); } }} 参考资料https://www.cnblogs.com/dolphin0520/p/3811445.html https://www.cnblogs.com/tiancai/p/7350464.html","link":"/2018/10/16/Java笔记/Java内部类详解/"},{"title":"Java运行环境","text":"操作系统（OS）是管理计算机硬件和软件资源的系统软件，为计算机程序提供公共服务。分时操作系统可以有效地使用系统，还可以包括处理器处理器事件、海量存储、打印和其他资源的成本分配的会计软件。对于诸如输入输出和内存分配这样的硬件功能，操作系统充当了程序和计算机硬件之间的中介，尽管应用程序代码通常是由硬件直接执行的，并且常常使系统调用一个OS函数或被它中断。在许多设备上都有操作系统，这些设备包括电脑—-从手机和视频游戏机到网络服务器和超级计算机。Android是一种基于Linux的自由及开发源代码的操作系统。 什么是线程，什么是进程？进程是系统进行资源分配的独立单元，它的特点如下： 进程是程序的一次执行过程。若程序执行两次甚至多次，则需要两个甚至多个进程。进程是正在运行程序的抽象。它代表运行的CPU，也称进程是对CPU的抽象（虚拟技术的支持，将一个CPU变换为多个虚拟的CPU）。系统资源（如内存、文件）以进程为单位分配，操作系统为每个进程分配了独立的地址空间，操作系统通过”调用”把控制权交给进程，线程是CPU调度的基本单元。 线程和进程的区别： 定义方面：进程是程序在某个数据集合上的一次运行活动；线程是进程中的一个执行路径。（进程可以创建多个线程） 角色方法：在支持线程机制的系统中，进程是系统资源分配的单位，线程是CPU调度的单位 资源共享方面：进程之间不能共享资源，而线程共享所在进程的地址空间和其他资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。 独立性方面：进程有自己独立的地址空间，而线程没有，线程必须依赖进程而存在。 开销方面。进程切换的开销较大。线程相对较小。（引入线程的原因是处于系统进程开销的考虑） JDK&amp;JVM&amp;JRE分别是什么以及他们的区别？JDK：JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。JDK中包含了JRE，在JDK安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib目录下则是jvm虚拟机工作所需要的类库，而jvm和lib和起来就称为jre。JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（java/java/jdb等）和Java基础的类库（即Java API包括rt.jar）。 JRE：是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将开发的程序发布到用户手中，让用户使用。JRE中包含了Java virtual machine(JVM)，runtime class libraries和Java application launcher，这些都是运行Java程序的必要组件。与大家熟悉的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对使用Java程序的用户。 JVM：就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有java程序会受限编译为.class的类文件，这种类文件可以在虚拟机上运行。也就是说class并不直接机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包包含lib类库。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行上的目标代码（字节码），就可以在多个平台上不加修改地运行。 三者的关系：JDK&gt;JRE&gt;JVM","link":"/2018/10/01/Java笔记/Java运行环境/"},{"title":"Java集合详解","text":"通常，程序总是根据运行时才知道的某些条件去创建新的对象。在此之前，无法知道所需对象的数量甚至确切类型。为了解决这个普遍的编程问题，需要在任一时刻和任意位置创建任意数量的对象。因此，不能依靠创建命名的引用来持有每一个对象：MyType aReference ，因为从来不会知道实际需要多少个这样的引用。Java 中有多种方式保存对象（准确来说是对象的引用）。数据是 Java 中保存一组对象最有效的方式，如果想要保存一组基本类型数据，也推荐使用数组。但是数组具有固定的大小尺寸，而且在更一般的情况下，在写程序的时候并不知道需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制就显得太过受限了。 *java.util * 库提供了一套相对完整的集合类（collection classes）来解决这个问题，其中基本类型有 List、Set、Queue 和 Map。这些类型也被称作容器类（container classes）。Set 对于每个值都只保存一个对象，Map 是一个关联数组，允许将某些对象和其他对象关联起来。Java 集合类都可以自动调整自己的大小。 基本概念Java集合分类体系图（包括抽象类和遗留构件，不包括Queue）： Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口： 集合（Collection）：一个独立元素的序列，这些元素都服从一条或多条规则。List 必须以插入的顺序保存元素，Set 不能包含重复元素，Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。 映射（Map）：一组成对的“键值对”对象，允许使用键来查找值。ArrayList 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 map 允许我们使用一个对戏那个来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起；或者称作字典（dictionary），因此可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。Map 是强大的编程工具。 Collection&amp;Map区别 Collection 和 Map 接口之间的主要区别在于：Collection中存储了一组对象，而 Map 中存储关键字键/值对。Collection 接口，包含 list 和 set 子接口；继承 Map 的类有HashMap，HashTable。Map 中每一个关键字最多有一个关联的值。不能包括两个相同的键，一个键最多能绑定一个值。null可以作为键，这样的键值可以有一个。当get()方法返回null值时，即可以表示Map中没有该键，也可以表示该键对应的值为null。所以不可以通过get()方法判断Map中的某个键是否存在，而应该通过containsKey()方法来判断。Map中提供三种集合的视图，Map的内容可以被当作一组key集合，一组value集合和一组key-value的映射。 浅拷贝&amp;深拷贝浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。 深拷贝的实现方式：使用JSON拷贝、序列化或者重写clone方法并遍历。","link":"/2018/10/24/Java笔记/Java集合详解/"},{"title":"Java面试知识点","text":"continue、break和return区别 continue：仅推出本次循环，剩下循环和方法继续执行。 break：终止循环，但是继续执行方法 return：终止循环和方法。 赋值操作符 “=” 在基本类型和对象引用中区别 对基本数据类型的肤质是很简单的。基本类型存储了实际的数值而非指向一个对象的引用，所以在为其赋值的时候，是直接将一个地方的内容复制到另一个地方。例如，对基本数据类型使用 a=b，那么b的内容就复制给a。若接着又修改了a，而b根本不会受这种修改的影响。 但是在为对象 “赋值” 的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是对象的引用。所以倘若 “将一个对象赋值给另一个对象”，实际是将 “引用” 从一个地方复制到另一个地方。这意味着假若 c=d ，这样c和d都会指向原本只有d指向的那个对象。 操作符 “==” 和 equals() 方法的区别 “==” 对于非基本类型而言，比较的是对象的引用，对于基本类型比较的是值。较特殊的地方是String equals() 在Object类中的实现是比较对象的引用，但是大多数Java类都覆盖了equals() 方法，使之实现内容值的比较，比如 Interger 类，String 类。 1234// Object 类中的equals方法public boolean equals(Object obj) { return (this == obj);} 12345678910111213141516171819202122// String 类中的equals方法public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} 逻辑操作符中的短路概念 即已经确定结果的逻辑表达式不会执行之后的逻辑判断，例如：if( test1() || test2() ) 如果 test1() 返回值为 true，那么 test2() 方法不会被执行，因为逻辑表达式的值已经确定，没必要继续执行剩余的逻辑判断。这就是短路概念。 字符串操作符 + 和 += 字符串操作符有一些很有趣的行为。如果表达式以一个字符串开头，那么后续所有操作必须是字符串型： 1234int x = 0, y = 1, z=2;String s = \"sum = \"System.out.println(s+x+y+z) // output：sum = 012System.out.println(s+(x+y+z)) // output：sum = 3 注意第一个输出语句打印的是 sum = 012 ，而不是 sum = 3。之所以会出现这种情况，是因为Java编译器会将x，y和z转换成它们的字符串形式，然后连接这些字符串，而不是先把它们加到一起。 finalize() 的作用 程序员都了解初始化的重要性，但常常会忘记同样也重要的清理工作。毕竟，谁需要清理一个int呢？但在使用程序库时，把一个对象用完后就“弃之不顾”的做法并不总是安全的。当然，Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：假定你的对象（并非使用new）获得了一块“特殊”内存。为了应对这种情况，Java允许在类中定义一个名为finalize() 的方法。它的工作原理“假定”是这样的：一旦垃圾回收器准备好时放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。 特殊情况例如 Java中调用非Java方法分配内存，在非Java代码中，也许会调用C的 malloc() 函数序列来分配存储空间，而且除非调用了 free() 函数，否则存储空间将得不到释放，从而造成内存泄漏。当然，free() 是C和C++中的函数，所以需要在 finalize() 中用本地方法（是指非Java代码）调用它。","link":"/2018/10/25/Java笔记/Java面试知识点/"},{"title":"Rxjava操作符：第1篇 Creating Observables","text":"本文基于Rxjava 2.x版本,介绍用于创建 Observable 对象的操作符。 Operators that originate new Observables. Create — create an Observable from scratch by calling observer methods programmatically Defer — do not create the Observable until the observer subscribes, and create a fresh Observable for each observer Empty/Never/Throw — create Observables that have very precise and limited behavior From — convert some other object or data structure into an Observable Interval — create an Observable that emits a sequence of integers spaced by a particular time interval Just — convert an object or a set of objects into an Observable that emits that or those objects Range — create an Observable that emits a range of sequential integers Repeat — create an Observable that emits a particular item or sequence of items repeatedly Start — create an Observable that emits the return value of a function Timer — create an Observable that emits a single item after a given delay create 操作符通过 create 方法构造 Observable 对象，通过被观察者的 subcribe 方法建立起观察者与被观察者的联系。 create example 123456789Observable&lt;String&gt; observable = Observable.create(emitter -&gt; { emitter.onNext(\"Hello\"); emitter.onNext(\"World\"); emitter.onComplete(); emitter.onError(new NullPointerException());});observable.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(\"onComplete\")); defer 操作符一个允许延迟操作的操作符，直到 ObservableSource 订阅了观察者 Observer，发射源 emitting item 才会发射数据。defer会为每一个 Observer 观察者对象创建新的 Observable ，所以下面两次打印数据是不同的。而 create 操作符观察者对象无论被订阅多少次，数据都是相同的。 defer example 123456789Observable&lt;Long&gt; observable = Observable.defer(() -&gt; { long time = System.currentTimeMillis(); return Observable.just(time);});observable.subscribe(time -&gt; System.out.println(time));Thread.sleep(1000);observable.subscribe(time -&gt; System.out.println(time));//print 1562638410886 1562638411891 empty 操作符这个操作符会生成一个没有发射数据的 Observable 对象，只会且直接调用 Observer#onComplete 方法。 empty example 1234567Observable&lt;String&gt; empty = Observable.empty();empty.subscribe( v -&gt; System.out.println(\"This should never be printed!\"), error -&gt; System.out.println(\"Or this!\"), () -&gt; System.out.println(\"Done will be printed.\"));//print Done will be printed. never 操作符never 操作符不会调用观察者对象的 onNext、onComplete 或者 onError 方法，它主要用来测试或者禁用组合操作符中的某些 Observable 对象。 never example 123456Observable&lt;String&gt; never = Observable.never();never.subscribe( v -&gt; System.out.println(\"This should never be printed!\"), error -&gt; System.out.println(\"Or this!\"), () -&gt; System.out.println(\"This neither!\")); error 操作符error 操作符只会调用 Observer#error 方法，常见 error 使用场景： error example 123456789101112131415161718Observable&lt;String&gt; results = Observable.fromCallable((Callable&lt;String&gt;) () -&gt; { if (Math.random() &lt; 0.5) { throw new IOException(); } throw new IllegalArgumentException();}).onErrorResumeNext(error -&gt; { if (error instanceof IllegalArgumentException) { return Observable.empty(); } return Observable.error(error);});for (int i = 0; i &lt; 10; i++) { results.subscribe( v -&gt; System.out.println(\"This should never be printed!\"), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\"));} from 操作符fromIterable 操作符根据 Iterable （类似 List，Set，Collection 等） 对象创建可观察者模型。 fromIterable example 123456List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));Observable&lt;Integer&gt; observable = Observable.fromIterable(list);observable.subscribe(item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\")); fromArray 操作符根据数组创建可观察者模型。 123456789Integer[] array = new Integer[10];for (int i = 0; i &lt; array.length; i++) { array[i] = i;}Observable&lt;Integer&gt; observable = Observable.fromArray(array);observable.subscribe(item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\")); fromCallable 操作符当订阅事件发生，Callable中的方法会被调用，返回值会转发至观察者。 12345678910Callable&lt;String&gt; callable = () -&gt; { System.out.println(\"Hello World!\"); return \"Hello World!\";};Observable&lt;String&gt; observable = Observable.fromCallable(callable);observable.subscribe(item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\"));//print Hello World! Hello World! Done fromAction 操作符//待验证… 12345Action action = () -&gt; System.out.println(\"Hello World!\");Completable completable = Completable.fromAction(action);completable.subscribe(() -&gt; System.out.println(\"Done\"), error -&gt; error.printStackTrace()); fromRunnable 操作符//待验证… 12345Runnable runnable = () -&gt; System.out.println(&quot;Hello World!&quot;);Completable completable = Completable.fromRunnable(runnable);completable.subscribe(() -&gt; System.out.println(&quot;Done&quot;), error -&gt; error.printStackTrace()); fromFuture 操作符给定预先存在的，已经运行或已经完成的java.util.concurrent.Future，等待Future正常完成或以阻塞方式使用异常并将生成的值或异常转发给使用者。 123456789101112ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();//延迟1秒Future&lt;String&gt; future = executor.schedule(() -&gt; \"Hello world!\", 1, TimeUnit.SECONDS);Observable&lt;String&gt; observable = Observable.fromFuture(future);observable.subscribe( item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\"));executor.shutdown(); from{reactive type} 操作符//待验证… 12345678Flux&lt;Integer&gt; reactorFlux = Flux.fromCompletionStage(CompletableFuture.&lt;Integer&gt;completedFuture(1));Observable&lt;Integer&gt; observable = Observable.fromPublisher(reactorFlux);observable.subscribe( item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\")); generate 操作符//待验证… 12345678int startValue = 1;int incrementValue = 1;Flowable&lt;Integer&gt; flowable = Flowable.generate(() -&gt; startValue, (s, emitter) -&gt; { int nextValue = s + incrementValue; emitter.onNext(nextValue); return nextValue;});flowable.subscribe(value -&gt; System.out.println(value)); interval 操作符interval操作符指定定时发送发出数据的时间间隔，interval 有多个重载方法，最终都会调用下面的方法： 123456789101112131415/** * @param initialDelay 发射第一条数据的延迟时间 * @param period 其它数据的延迟发射周期 * @param unit 时间单位 * @param scheduler 任务调度器 */@CheckReturnValue@NonNull@SchedulerSupport(SchedulerSupport.CUSTOM)public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) { ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); return RxJavaPlugins.onAssembly(new ObservableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));} interval()的其它重载方法默认不设置 initialDleay 值时，initialDelay 的值将和 period 值保持一致，默认的调度器 Schedulers.computation()。在 java 中使用默认调度器的时候，interval 方法不会正常执行，程序会自动退出。interval 方法指定线程是未阻塞的，并不会阻止 JVM 退出程序。指定调度器 trampoline() 延长程序存活时间，interval 方法会正常执行。在Android中程序是在活跃的，不需要指定调度器。问题详情见 Rxjava issue interval example 12345678Observable&lt;Long&gt; clock = Observable.interval(1, TimeUnit.SECONDS, Schedulers.trampoline());clock.subscribe(time -&gt; { if (time % 2 == 0) { System.out.println(\"Tick\"); } else { System.out.println(\"Tock\"); }}); just 操作符根据 just 方法中顺序依次发射数据到下游观察者对象，just 方法可定义 1~9 个参数，但参数类型应保持一致。 just example 12345Observable&lt;Object&gt; observable = Observable.just(\"1\", \"A\", \"3.2\", \"def\"); observable.subscribe(item -&gt; System.out.print(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println());//print 1A3.2def range 操作符发出指定范围的整数队列值，调用的是 onNext 方法。 range example 123456789String greeting = \"Hello World!\";Observable&lt;Integer&gt; indexes = Observable.range(0, greeting.length());Observable&lt;Character&gt; characters = indexes .map(index -&gt; greeting.charAt(index));characters.subscribe(character -&gt; System.out.print(character), error -&gt; error.printStackTrace(), () -&gt; System.out.println()); timer 操作符timer(long, TimeUnit) 方法指定延迟时间发射出指定数据，不重复发出。 timer example 123Observable&lt;Long&gt; eggTimer = Observable.timer(5, TimeUnit.MINUTES);eggTimer.blockingSubscribe(v -&gt; System.out.println(&quot;Egg is ready!&quot;)); 参考文章： https://github.com/ReactiveX/RxJava/wiki/Creating-Observables","link":"/2019/06/18/Rxjava笔记/第1篇 Creating Observables/"},{"title":"Android中查看启动或方法耗时的技巧","text":"如何查看启动耗时 在AndroidStudio的Logcat窗口输入Displayed 关键字过滤，如下所示： 12020-01-03 10:53:02.804 1402-1479/? I/ActivityManager: Displayed com.markzl.android.simpleapplication/.HelloActivity: +509ms 通过指令 adb shell am start -W packagename/LaunchActivityName执行： 123456789zhoudeMacBook-Pro:SimpleApplication markzl$ adb shell am start -W com.markzl.android.simpleapplication/.HelloActivityStarting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.markzl.android.simpleapplication/.HelloActivity }Status: okActivity: com.markzl.android.simpleapplication/.HelloActivityThisTime: 509TotalTime: 509WaitTime: 530CompletezhoudeMacBook-Pr ThisTime：一般和TotalTime时间一样。除非在应用启动时开了一个透明的Activity预先处理一些事再显示出主Activity，这样将比TotalTime小。 TotalTime：应用的启动时间。包含创建进程+Application初始化+Activity初始化到界面显示。 WaitTime：一般比TotalTime大点，包含系统影响的耗时。 如何计算方法耗时使用aspect面向切面，计算方法耗时 定义切点： 12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface BehaviorTrace { String value();} 定义切面： 123456789101112131415161718192021222324252627282930313233@Aspectpublic class BehaviorAspect { private static final String POINTCUT_METHOD = \"execution(@com.markzl.android.aspectj.BehaviorTrace * *(..))\"; private static final String POINTCUT_CONSTRUCTOR = \"execution(@com.markzl.android.aspectj.BehaviorTrace *.new(..))\"; @Pointcut(POINTCUT_METHOD) public void methodAnnotationWithBehaviorTrace() { } @Pointcut(POINTCUT_CONSTRUCTOR) public void constructorAnnotationWithBehaviorTrace() { } @Around(\"methodAnnotationWithBehaviorTrace()||constructorAnnotationWithBehaviorTrace()\") public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable { MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); String className = methodSignature.getDeclaringType().getSimpleName(); String methodName = methodSignature.getName(); BehaviorTrace behaviorTrace = methodSignature.getMethod().getAnnotation(BehaviorTrace.class); String value = behaviorTrace.value(); StopWatch stopWatch = new StopWatch(); stopWatch.start(); Object result = joinPoint.proceed(); stopWatch.stop(); Log.d(className, buildLogMessage(methodName, stopWatch.getTotalTimeMillis())); Log.d(className, value); return result; }} AOP 特性无侵入性且修改方便。 启动速度分析工具 —— TraceView使用方式1: 在方法执行开始处添加： 1Debug.startMethodTracing(\"simple.trace\"); 在方法执行终止处添加： 1Debug.stopMethodTracing(); 执行完毕会自动将方法执行信息写入外部存储Android/data/包名/file目录下。 启动速度分析工具 —— Systrace生成Html分析文件 12Trace.beginTrace.end","link":"/2020/03/23/Android面试/Android中查看启动或方法耗时的技巧/"},{"title":"Rxjava操作符：第3篇 Flitering Observable","text":"本文基于Rxjava 2.x版本,介绍用于 Observable 过滤发射项目的操作符。 Operators that selectively emit items from a source Observable. Debounce — only emit an item from an Observable if a particular timespan has passed without it emitting another item 如果特定的时间跨度已经过去而没有发出另一个项目，则只从Observable中发出一个项目 Distinct — suppress duplicate items emitted by an Observable 过滤重复发射源 ElementAt — emit only item n emitted by an Observable 仅发出方法中指定的发射源 Filter — emit only those items from an Observable that pass a predicate test 仅发出符合过滤条件的发射源 First — emit only the first item, or the first item that meets a condition, from an Observable 仅保留发射序列的第一个发射源 IgnoreElements — do not emit any items from an Observable but mirror its termination notification 忽略发射序列的所有元素，只会响应 onComplete 方法 Last — emit only the last item emitted by an Observable 仅保留发射序列的最后一个发射源 Sample — emit the most recent item emitted by an Observable within periodic time intervals 取每个时间周期内的最后一个发射源。 Skip — suppress the first n items emitted by an Observable 跳过起始位置的 n 个发射源 SkipLast — suppress the last n items emitted by an Observable 跳过终点位置的 n 个发射源 Take — emit only the first n items emitted by an Observable 保留起始位置的 n 个发射源 TakeLast — emit only the last n items emitted by an Observable 保留终点位置的 n 个发射源 debounce 操作符当发射源 Emitter#onNext 方法发射间隔小于 debounce 方法指定间隔，取时间间隔有交集的最后一个发射源。在当前指定时间周期内只有一个发射源的时候，直接发出该发射源，如果指定时间周期出现多个发射源，取周期内最后一个发射源发出，其他的发射源过滤掉。根据下面的 debounce 图解可以得知，debounce 周期随发射源发出开始计算。注意和 sample 操作符区别 1234567891011121314151617181920212223242526272829303132333435363738// Diagram:// -A--------------B----C-D-------------------E-|----&gt;// a---------1s// b---------1s// c---------1s// d---------1s// e-|----&gt;// -----------A---------------------D-----------E-|--&gt;Observable&lt;String&gt; source = Observable.create(emitter -&gt; { emitter.onNext(\"A\"); Thread.sleep(1_500); emitter.onNext(\"B\"); Thread.sleep(500); emitter.onNext(\"C\"); Thread.sleep(250); emitter.onNext(\"D\"); Thread.sleep(2_000); emitter.onNext(\"E\"); emitter.onComplete();});source.subscribeOn(Schedulers.io()) .debounce(1, TimeUnit.SECONDS) .blockingSubscribe( item -&gt; System.out.println(\"onNext: \" + item), Throwable::printStackTrace, () -&gt; System.out.println(\"onComplete\"));// prints:// onNext: A// onNext: D// onNext: E// onComplete distinct 操作符过滤重复的发射项目 123456789Observable.just(2, 3, 4, 4, 2, 1) .distinct() .subscribe(System.out::println);// prints:// 2// 3// 4// 1 elementAt 操作符获取指定发射序列上某条数据 12345678910Observable&lt;Long&gt; source = Observable.&lt;Long, Long&gt;generate(() -&gt; 1L, (state, emitter) -&gt; { emitter.onNext(state); return state + 1L;}).scan((product, x) -&gt; product * x);Maybe&lt;Long&gt; element = source.elementAt(5);element.subscribe(System.out::println);// prints 720 filter 操作符过滤非函数判断指定的发射序列 12345678Observable.just(1, 2, 3, 4, 5, 6) .filter(x -&gt; x % 2 == 0) .subscribe(System.out::println);// prints:// 2// 4// 6 first 操作符取发射序列的第一个发射源，和 last 操作符对应。first 方法中参数为指定默认值。 123456Observable&lt;String&gt; source = Observable.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);Single&lt;String&gt; firstOrDefault = source.first(&quot;D&quot;);firstOrDefault.subscribe(System.out::println);// prints A ignoreElement 操作符忽略被观察者发射序列携带的数据，返回值为 Completable&lt;T&gt; ，只调用 onComplete 方法 12345678Observable&lt;Long&gt; source = Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS);Completable completable = source.ignoreElements();completable.doOnComplete(() -&gt; System.out.println(\"Done!\")) .blockingAwait();// prints (after 5 seconds):// Done! last 操作符去发射序列最后一个发射源，last 方法参数为默认值 123456Observable&lt;String&gt; source = Observable.just(\"A\", \"B\", \"C\");Single&lt;String&gt; lastOrDefault = source.last(\"D\");lastOrDefault.subscribe(System.out::println);// prints C sample 操作符从指定的时间周期中取最后一个发射源。与 debounce 操作符的区别是，sample 操作符的时间周期是独立的。 123456789101112131415161718192021222324252627282930313233// Diagram:// -A----B-C-------D-----E-|--&gt;// -0s-----c--1s---d----2s-|--&gt;// -----------C---------D--|--&gt;Observable&lt;String&gt; source = Observable.create(emitter -&gt; { emitter.onNext(\"A\"); Thread.sleep(500); emitter.onNext(\"B\"); Thread.sleep(200); emitter.onNext(\"C\"); Thread.sleep(800); emitter.onNext(\"D\"); Thread.sleep(600); emitter.onNext(\"E\"); emitter.onComplete();});source.subscribeOn(Schedulers.io()) .sample(1, TimeUnit.SECONDS) .blockingSubscribe( item -&gt; System.out.println(\"onNext: \" + item), Throwable::printStackTrace, () -&gt; System.out.println(\"onComplete\"));// prints:// onNext: C// onNext: D// onComplete skip 操作符指定从起始位置跳过 n 个发射源后继续发射 123456789101112Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.skip(4) .subscribe(System.out::println);// prints:// 5// 6// 7// 8// 9// 10 skipLast 操作符指定跳过终点位置的 n 个发射源 123456789101112Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.skipLast(4) .subscribe(System.out::println);// prints:// 1// 2// 3// 4// 5// 6 take 操作符和 skip 操作符相反操作，指定保留从起始位置发射的 n 个发射源 12345678910Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.take(4) .subscribe(System.out::println);// prints:// 1// 2// 3// 4 takeLast 操作符和 skipLast操作符相反，保留从终点位置发射的 n 个发射源 12345678910Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.takeLast(4) .subscribe(System.out::println);// prints:// 7// 8// 9// 10 参考文章： https://github.com/ReactiveX/RxJava/wiki/Filtering-Observables","link":"/2019/06/20/Rxjava笔记/第3篇 Flitering Observables/"},{"title":"Rxjava操作符：第2篇 Transforming Observable","text":"本文基于Rxjava 2.x版本,介绍用于变换 Observable 对象的操作符。 Operators that transform items that are emitted by an Observable. Buffer — periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time 定期将Observable中的项目收集到包中并发出这些包，而不是一次发送一个项目 FlatMap — transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable 将Observable发出的项目转换为Observables，然后将这些项目的排放量变为单个Observable GroupBy — divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key 将一个Observable划分为一组Observable，每个Observable从原始Observable中发出一组不同的项目，按键组织 Map — transform the items emitted by an Observable by applying a function to each item 通过将函数应用于每个项目来转换Observable发出的项目 Scan — apply a function to each item emitted by an Observable, sequentially, and emit each successive value 将函数应用于Observable发出的每个项目，按顺序发出每个连续的值 Window — periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time 定期将Observable中的项目细分为Observable窗口并发出这些窗口，而不是一次发出一个项目 buffer 操作符 buffer 操作符是缓存多个 emiter.onNext 事件，一次发出。buffer 方法有多个重载方法，可以仔细阅读源码注释。Buffer 方法的返回值是 Observable&lt;List&lt;T&gt;&gt; 类型。 12345678Observable.range(0, 10) .buffer(4) .subscribe((List&lt;Integer&gt; buffer) -&gt; System.out.println(buffer));// prints:// [0, 1, 2, 3]// [4, 5, 6, 7]// [8, 9] cast 操作符将被观察者传递的数据转换成指定类型。注意使用 fliter 操作符过滤非指定类型数据，以避免 Java 类型转换错误 ClassCastException 。 1234567891011Observable&lt;Number&gt; numbers = Observable.just(1, 4.0, 3f, 7, 12, 4.6, 5);numbers.filter((Number x) -&gt; Integer.class.isInstance(x)) .cast(Integer.class) .subscribe((Integer x) -&gt; System.out.println(x));// prints:// 1// 7// 12// 5 concatMap 操作符ConcatMap 操作符还有很多扩展方法，concatMapCompletable、 concatMapCompletableDelayError、concatMapDelayError、 concatMapEager、concatMapEagerDelayError、concatMapIterable、 concatMapMaybe、concatMapMaybeDelayError、 concatMapSingle、concatMapSingleDelayError 等，这里主要介绍 concatMap 和 concatMapIterable 操作符。 ConcatMap 操作的是 Observable 对象，根据初始被观察者传递的数据转换成新的 Observable 向下传递。注意 ConcatMap 操作符是按照发射顺序执行的。 12345678Observable.range(0, 5) .concatMap(i -&gt; { long delay = Math.round(Math.random() * 2); return Observable.timer(delay, TimeUnit.SECONDS).map(n -&gt; i); }) .blockingSubscribe(System.out::print);// prints 01234 concatIterable 操作符concatIterable 操作符会将转换生成的 Iterable 列表数据中的每一项单独从发射源发出，且发射源数据是按照顺序发出的。 12345Observable.just(\"A\", \"B\", \"C\") .concatMapIterable(item -&gt; Arrays.asList(item,item,item)) .subscribe(System.out::println);//print AAABBBCCC flatMap 操作符作用和 concatMap 操作符类似。flatMap 操作符与 concatMap 操作符区别：flatMap 操作符不是按照发射顺序执行。这种操作符主要是需要通过源 Observable 数据 获取新的 Observable 数据时使用。例如从某请求地址获取到参数，然后根据获取到的参数请求另一地址获取最终我们需要的数据。 1234567891011121314151617Observable.just(\"A\", \"B\", \"C\") .flatMap(a -&gt; { return Observable.intervalRange(1, 3, 0, 1, TimeUnit.SECONDS) .map(b -&gt; '(' + a + \", \" + b + ')'); }) .blockingSubscribe(System.out::println);//打印顺序有可能不同//(A, 1)//(B, 1)//(C, 1)//(B, 2)//(A, 2)//(C, 2)//(B, 3)//(A, 3)//(C, 3) flatMapIterable 操作符作用和 concatMapIterable 操作符相同，会将 Iterable 列表中的值生成 Observable&lt;T&gt; 发射源。 123456789101112131415Observable.just(1, 2, 3, 4) .flatMapIterable(x -&gt; { switch (x % 4) { case 1: return Arrays.asList(\"A\"); case 2: return Arrays.asList(\"B\", \"B\"); case 3: return Arrays.asList(\"C\", \"C\", \"C\"); default: return Arrays.asList(); } }) .subscribe(System.out::print);//print ABBCCC groupBy 操作符类似 butter 操作符打包多个发射项目，但是是根据 group(key,value) 来分包的。注意groupBy操作符返回值类型是 Observable&lt;GroupedObservable&lt;K, V&gt;&gt; ，发射源 onNext方法中传递的将会是 GroupedObservable&lt;K, V&gt; 类型，而我们需要的值在每个 GroupeObservable 中，这里我们使用 concatMapSingle 操作符将每个中的数据合并生成新的 Single&lt;List&lt;T&gt;&gt; 向下传递。 123456789101112Observable&lt;String&gt; animals = Observable.just( \"Tiger\", \"Elephant\", \"Cat\", \"Chameleon\", \"Frog\", \"Fish\", \"Turtle\", \"Flamingo\");animals.groupBy(animal -&gt; animal.charAt(0), String::toUpperCase) .concatMapSingle(Observable::toList) .subscribe(System.out::println);//println//[TIGER, TURTLE]//[ELEPHANT]//[CAT, CHAMELEON]//[FROG, FISH, FLAMINGO] map 操作符直接操作发射数据，返回变换后的数据并向下游传递。 12345678Observable.just(1, 2, 3) .map(x -&gt; x * x) .subscribe(System.out::println);// prints:// 1// 4// 9 scan 操作符scan操作符实现的是一种类似累加器的功能，如下所示 partialSum 参数为之前发射数据的和。 1234567891011Observable.just(5, 3, 8, 1, 7) .scan(0, (partialSum, x) -&gt; partialSum + x) .subscribe(System.out::println);// prints:// 0// 5// 8// 16// 17// 24 window 操作符window 操作符作用和 buffer 类似，不过 window 方法的返回值是 Observable&lt;Observable&lt;T&gt;&gt; 对象，直接传递的是Observable&lt;T&gt; 对象，在订阅方法中打印的是 Observable 对象，而不是其中传递的值。通过 flatMap 方法或者其扩展方法，既可处理按照 window(connt , skip) 设置打包数据的传递。而 buffer 方法的操作符返回值类型是 Observable&lt;List&lt;T&gt;&gt;。 123456789101112131415Observable.range(1, 10) // Create windows containing at most 2 items, and skip 3 items before starting a new window. .window(2, 3) .flatMapSingle(window -&gt; { return window.map(String::valueOf) .reduce(new StringJoiner(\", \", \"[\", \"]\"), StringJoiner::add); }) .subscribe(System.out::println);// prints:// [1, 2] window 中 emitter.onNext(1); emitter.onNext(2);// [4, 5]// [7, 8]// [10] 按照参数指定的数据打包为 Observable&lt;T&gt; 对象，参数 Observable 中会调用 onNext 方法来处理每一个集合数据。因为参数类型为 Observable&lt;T&gt; , 所有订阅方法中 onNext 方法只会调用4次。 参考文章： https://github.com/ReactiveX/RxJava/wiki/Transforming-Observables","link":"/2019/06/19/Rxjava笔记/第2篇 Transforming Observable/"},{"title":"Rxjava操作符：第4篇 Combining Observables","text":"本文基于Rxjava 2.x版本,介绍用于操作多个 Observable 对象的操作符。 Operators that work with multiple source Observables to create a single Observable And/Then/When — combine sets of items emitted by two or more Observables by means of Patternand Plan intermediaries CombineLatest — when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function Join — combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable Merge — combine multiple Observables into one by merging their emissions StartWith — emit a specified sequence of items before beginning to emit the items from the source Observable Switch — convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables Zip — combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function startWith操作符在 Observable 序列发送之前添加起始位置指定发送的 Observable startWith Example 1234Observable&lt;String&gt; names = Observable.just(\"Spock\", \"McCoy\");names.startWith(\"Kirk\").subscribe(item -&gt; System.out.println(item));// prints Kirk, Spock, McCoy merge 操作符merge 操作符 merge 操作符在用来合并多个 Observable 操作，合并的序列依次调用 Emitter#onNext() 方法执行，遇到错误序列将不继续执行。 merge Example 12345Observable.just(1, 2, 3) .mergeWith(Observable.just(4, 5, 6)) .subscribe(item -&gt; System.out.println(item));// prints 1, 2, 3, 4, 5, 6 mergeDelayError 操作符 和 merge 操作符类似，不过遇到错误会保存下来，等所有 Observable 执行完毕，再处理出现错误的Observable。注意 mergeDelayError 是静态泛型方法，只可以通过类名访问。 mergeDelayError Example 1234567Observable&lt;String&gt; observable1 = Observable.error(new IllegalArgumentException(\"\"));Observable&lt;String&gt; observable2 = Observable.just(\"Four\", \"Five\", \"Six\");Observable.mergeDelayError(observable1, observable2) .subscribe(item -&gt; System.out.println(item));// emits 4, 5, 6 and then the IllegalArgumentException (in this specific// example, this throws an `OnErrorNotImplementedException`). zip 操作符将多个 Observable 发射的数据合并起来，并生成一个Observable根据合并后的数据继续向下传递。onNext 方法只会调用一次。zip 、zipArray、zipIterable、zipWith zip Example 123456Observable&lt;String&gt; firstNames = Observable.just(\"James\", \"Jean-Luc\", \"Benjamin\");Observable&lt;String&gt; lastNames = Observable.just(\"Kirk\", \"Picard\", \"Sisko\");firstNames.zipWith(lastNames, (first, last) -&gt; first + \" \" + last) .subscribe(item -&gt; System.out.println(item));// prints James Kirk, Jean-Luc Picard, Benjamin Sisko zip 操作符 会将对应 Observable 对应的 Emitter onNext 的数据合并最后通过新生成的 Observable 发射调整后的数据。 combineLatest 操作符让两个 Obserable 序列按照最新发出的数据组合在一起生成一个 Observable 序列向下传递。 combineLatest Example 1234567891011121314151617Observable&lt;Long&gt; newsRefreshes = Observable.interval(100, TimeUnit.MILLISECONDS);Observable&lt;Long&gt; weatherRefreshes = Observable.interval(50, TimeUnit.MILLISECONDS);Observable.combineLatest(newsRefreshes, weatherRefreshes, (newsRefreshTimes, weatherRefreshTimes) -&gt; \"Refreshed news \" + newsRefreshTimes + \" times and weather \" + weatherRefreshTimes) .subscribe(item -&gt; System.out.println(item));// prints:// Refreshed news 0 times and weather 0// Refreshed news 0 times and weather 1// Refreshed news 0 times and weather 2// Refreshed news 1 times and weather 2// Refreshed news 1 times and weather 3// Refreshed news 1 times and weather 4// Refreshed news 2 times and weather 4// Refreshed news 2 times and weather 5// ... switchOnNext 操作符switchOnNext Example 12345678910111213141516171819202122Observable&lt;Observable&lt;String&gt;&gt; timeIntervals = Observable.interval(1, TimeUnit.SECONDS) .map(ticks -&gt; Observable.interval(100, TimeUnit.MILLISECONDS) .map(innerInterval -&gt; \"outer: \" + ticks + \" - inner: \" + innerInterval));Observable.switchOnNext(timeIntervals) .subscribe(item -&gt; System.out.println(item));// prints:// outer: 0 - inner: 0// outer: 0 - inner: 1// outer: 0 - inner: 2// outer: 0 - inner: 3// outer: 0 - inner: 4// outer: 0 - inner: 5// outer: 0 - inner: 6// outer: 0 - inner: 7// outer: 0 - inner: 8// outer: 1 - inner: 0// outer: 1 - inner: 1// outer: 1 - inner: 2// outer: 1 - inner: 3// ... 参考文章： https://github.com/ReactiveX/RxJava/wiki/Combining-Observables","link":"/2019/06/21/Rxjava笔记/第4篇 Combining Observables/"},{"title":"Activity启动流程分析","text":"本文基于Android 28 版本 Activity 的启动过程是从 startActivity 方法开始的，在Activity类中该方法最终调用 startActivityForResult 方法，如下所示： 1234567891011121314151617public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) { ... if (mParent == null) { options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } } ...} 在该方法中，通过Instrumentation的execStartActivity 方法执行启动流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Intrumentation.javapublic ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) { intent.putExtra(Intent.EXTRA_REFERRER, referrer); } if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) { final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) { result = am.onStartActivity(intent); } if (result != null) { am.mHits++; return result; } else if (am.match(who, null, intent)) { am.mHits++; if (am.isBlocking()) { return requestCode &gt;= 0 ? am.getResult() : null; } break; } } } } try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(\"Failure from system\", e); } return null;} 接着上面分析 ActivityManager.getService().startActivity，方法内容如下： 1234567891011121314151617// ActivityManager.java/** * @hide */public static IActivityManager getService() { return IActivityManagerSingleton.get();}private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() { @Override protected IActivityManager create() { final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; } }; Android 8.0 以上版本使用AIDL方式实现与ActivityManagerServicer 通信，Android 8.0 一下版本是通过Binder方式实现，详情请查看 ActivityManagerNative 方法。两种方式其实一样，不过使用AIDL 简化了代码结构。Android 中 ActivityManageService 负责系统中所有 Activity 启动和执行，启动 Activity 流程最终是调用ActivityManagerService的startActivity 方法： 12345678@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());} Activity startActivity startActivityForResult Instrumentation execStartActivity checkStartActivityResult ActivityManangerService startActivityAsUser obtainStarter ActivityStartController execute startActivity startActivityUnchecked ActivityStack startActivityLocked","link":"/2019/08/23/Android面试/Activity启动流程分析/"},{"title":"Android中注解的使用","text":"元注解@Target：这个注解的取值是一个 ElementType 类型的数组，用来指定注解所使用的对象范围，总共有十种不同的类型，根据定义的注解进行灵活的组合，如下所示： 元素类型 适用于 ANNOTATION_TYPE 注解类型声明 CONSTRUCTOR 构造函数 FIELD 实例变量 LOCAL_VARIABLE 局部变量 METHOD 方法 PACKAGE 包 PARAMETER 方法参数或者构造方法参数 TYPE 类（包括ENUM）和接口（包含注解类型） TYPE_PARAMETER 类型参数 TYPE_USE 类型的用途 同时支持多种类型的注解定义如下： 12@Target({ElementType.TYPE,ElementType.PACKAGE})public @interface CrashReport @Retention：用来指明注解的访问范围，也就是在什么级别下保留注解，主要有下面三种类型： 源码级注解（SOURCE）：在定义注解接口时，使用@Retention(RetentionPolicy.SOURCE)修饰的注解，该类型的注解信息只保留在 .java 源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的 .class 文件中。 编译时注解（CLASS）：在定义注解接口时，使用@Retention(RetentionPolicy.CLASS)修饰的注解，该类型的注解信息只保留在 .java 源码里和 .class 文件里，在执行的时候会被Java 虚拟机丢弃，不会加载到虚拟机里。 运行时注解（RUNTIME）：在定义注解接口时，使用@Retention(RetentionPolicy.CLASS)修饰的注解，Java 虚拟机在运行期间也保留注解信息，也可以通过反射机制读取注解的信息。（ .java 源码、.class 文件和执行的时候都有注解的信息 ） @Documented：表示被修饰的注解应该被包含在被注解项的文档中（例如用JavaDoc生成的文档）。 @Inherited：表示该注解可以被子类继承的。 @Repeatable：表示这个注解可以在同一个项上面应用多次，不过这个注解是 Java8 中才引入的，前面的4个注解都是在 Java 5 中引入的。","link":"/2018/03/23/Android面试/Android中注解的使用/"},{"title":"Android中的AOP面向切面编程","text":"AOP 的应用场景日志记录、性能统计、埋点统计、安全控制和异常处理。 AOP 的常见框架hugo AOP 的基本概念 横切关注点（Cross-cutting concerns） 连接点（Joint point） 通知（Advice） 切入点（Pointcut） 切面（Aspect） 织入（Weaving） 常见AOP 的实现方式 APTAPT（Annotation Processing Tool）即注解处理器。在编译期生成.java文件，使用的 Annotation 类型是 SOURCE. 代表框架：DataBinding、Dagger2、ButterKnife、EventBus3、DBFlow、AndroidAnnotation 特点： 只能生成.java文件，而不能在现有类中插入代码 可以通过javapoet来简化.java的生成操作 会在运行时产生一些代理类的缓存，增加内存的负担。 AspectJJavassistAspectJ简单使用AspectJ 相关注解 @Aspect：声明切面，标记类 @Pointcut(切点表达式)：定义切点，标记方法 @Before(切点表达式)： 切点之前执行 @Around(切点表达式)：切点之前之后执行（切点执行 oinPoint.proceed） @After(切点表达式)：后置通知，切点之后执行 @AfterReturning(切点表达式)：返回通知，切点方法返回结果之后执行 @AfterThrowing(切点表达式)：异常通知，切点抛出异常时执行 切点表达式1execution(&lt;修饰符模式&gt;? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?) 参考文章书籍：《Android高级进阶》 文章：https://www.jianshu.com/p/8582f896d136?utm_source=desktop&amp;utm_medium=timeline 文章：https://www.jianshu.com/p/890dd0b77ded 文章：https://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/","link":"/2019/11/23/Android面试/Android中的AOP面向切面编程/"},{"title":"Android冷热启动优化","text":"1、冷启动与热启动简介冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。 热启动：当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。 两者之间的特点如下： 冷启动:系统会重新创建一个新的进程分配给该应用，从Application创建到UI绘制等相关流程都会执行一次。 热启动：应用还在后台，因此该启动方式不会重建Application，只会重新绘制UI等相关流程。 冷启动流程分析： 创建进程：启动APP、加载空白Window、创建进程 启动应用：创建Application、启动ActivityThread、创建Activity 开启绘制 2、计算启动时间Activity启动事件计算指令（适用于线下）： 1adb shell am start -W [packageName]/[packageName.XxxActivity] 输出参数： 123456Status: okActivity: com.markzl.android.simpleapplication/.HelloActivityThisTime: 426TotalTime: 426WaitTime: 444Complete 1、ThisTime:一般和TotalTime时间一样。除非在应用启动时开了一个透明的Activity预先处理一些事再显示出主Activity，这样将比TotalTime小。 2、TotalTime:应用的启动时间。包含创建进程+Application初始化+Activity初始化到界面显示。 3、WaitTime:一般比TotalTime大点，包含系统影响的耗时。 TraceView(可埋点) 123Debug.startMethodTracing(\"simple.trace\");...Debug.stopMethodTracing(); 文件目录 Android/data/包名/files 优化通过设置在window空白时添加主题 123456789&lt;activity android:name=\".HelloActivity\" android:theme=\"@style/Splash\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 1234&lt;style name=\"Splash\" parent=\"AppTheme\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/splash&lt;/item&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;&lt;/style&gt; 在 HelloActivity 的Activity方法之前重新设置回原主题。","link":"/2019/03/23/Android面试/Android冷热启动优化/"},{"title":"Android单元测试框架","text":"建议各类测试所占比例如下：小型测试（单元测试）占 70%，中型测试（集成测试）占 20%，大型（端到端）测试占 10%。 单元测试分为： 本地单元测试，始终在JVM驱动的开发计算机上运行的测试，使用robolectric框架。Robolectric 支持Android 的以下几个方面 组件生命周期 事件循环 所有资源 插桩单元测试，在物理设备或者模拟设备上面运行测试，使用AndroidX Test API 主线程，也称为”界面线程“或”Activity 线程“。 插桩线程，大多数测试都在此线程上运行。 1. 本地单元测试单元测试编写目录对应test目录 1.1 Java 中的 JUnit 测试框架AndroidStudio 新建项目会自动配置 JUnit 测试框架 12345dependencies { ... testImplementation 'junit:junit:4.12' ...} 简单的测试案例： 123456class ExampleUnitTest { @Test fun addition_isCorrect() { assertEquals(4, 2 + 2) }} JUnit 中的常用注解： @Before：执行每个@Test方法之前调用 @After：执行每个@Test方法之后调用 @Test： @BeforeClass：在执行一个测试类的所有测试方法之前 @AfterClass：在执行一个测试类的所有测试方法之后 @Ignore：测试类中某些测试方法可能暂时处于不可测试阶段，那么为了保证这个测试类的正常运行，可以使用@Ignore标记这些测试方法。 1.2 单元测试框架RobolectricRobolectric 的设计思想是通过 JVM 运行Android代码，从而实现脱离Android环境进行测试。Robolectric 框架依赖于 JUnit，所以需要同时添加两个框架依赖： 12345678910111213141516android { // ... testOptions { unitTests { // 设置单元测试可以访问编译版本的资源 includeAndroidResources = true } }}dependencies { ... testImplementation 'junit:junit:4.12' testImplementation 'org.robolectric:robolectric:4.3' ...} 1234567891011121314151617181920212223@RunWith(RobolectricTestRunner.class)public class MainActivityTest { // 测试Activity标题是否与期望值一致 @Test public void titleIsCorrect() { MainActivity activity = Robolectric.setupActivity(MainActivity.class); assertEquals(\"TestingSample\", activity.getTitle()); } // 测试生命周期 @Test public void testLifecycle(){ ActivityController&lt;MainActivity&gt; controller = Robolectric.buildActivity(MainActivity.class) .create().start(); Activity activity = controller.get(); TextView textView =activity.findViewById(R.id.login); assertEquals(\"onCreate()\",textView.getText().toString()); controller.resume(); assertEquals(\"onResume()\",textView.getText().toString()); }} 1.3 插桩测试（Mockito）Mockito 环境配置： 1234567891011121314151617android { // ... testOptions { unitTests { // 设置单元测试可以访问编译版本的资源 includeAndroidResources = true } }}dependencies { ... testImplementation 'junit:junit:4.12' testImplementation 'org.robolectric:robolectric:4.3' testImplementation 'org.mockito:mockito-core:2.19.0' ...} 123456789101112131415161718192021222324252627282930313233public class ExampleUnitTest { @Test public void mockTest(){ // 创建接口 List 的 mock 对象 List mockedList = Mockito.mock(List.class); // 使用 mock 对象执行操作 mockedList.add(\"one\"); mockedList.clear(); //验证对应的操作是否执行过 Mockito.verify(mockedList).add(\"one\"); Mockito.verify(mockedList).clear(); LinkedList linkedList = Mockito.mock(LinkedList.class); // 在mock对象执行某个操作时，插入桩函数 when(linkedList.get(0)).thenReturn(\"first\"); when(linkedList.get(1)).thenReturn(new RuntimeException()); // 打印 first System.out.println(linkedList.get(0)); // 打印 java.lang.RuntimeException System.out.println(linkedList.get(1)); // 打印 null System.out.println(linkedList.get(999)); }} 2. 界面测试界面测试编写目录对应androidTest目录。 2.1 单个应用的界面测试（Espresso）添加Espresso依赖 12345dependencies { ... androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0' ...} 1234567891011121314151617181920212223242526@RunWith(AndroidJUnit4.class)public class ChangeTextBehaviorTest { private String stringToBetyped; // 需要添加依赖：implementation 'androidx.test:rules:1.2.0' @Rule public ActivityTestRule&lt;MainActivity&gt; activityTestRule = new ActivityTestRule&lt;&gt;(MainActivity.class); @Before public void initValidString() { // Specify a valid string. stringToBetyped = \"Espresso\"; } @Test public void changeText_sameActivity() { onView(withId(R.id.editTextUserInput)).perform(typeText(stringToBetyped), ViewActions.closeSoftKeyboard()); onView(withId(R.id.changeTextBt)).perform(click()); onView(withId(R.id.textToBeChanged)) .check(matches(withText(stringToBetyped))); }} 2.2 多个应用的界面测试（UIAutomator）添加UIAutomator依赖： 12345dependencies { ... androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0' ...} 设计测试案例之前，需要确保UI Anutomator可以访问你的组件，即组件是否具有可见性或是否设置 android:contentDescription 属性。 2.2.1 uiautomatorviewer 工具使用 uiautomatorviewer 的步骤： 在你模拟器或者测试设备上打开要测试的应用，并连接到AndroidStudio 前往 Android/sdk/tools/bin 目录打开 uiautomatorviewer 工具。 在 uiautomatorviewer 界面选择 device screenshot ，在右侧即可看见组件具体信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@RunWith(AndroidJUnit4.class)@SdkSuppress(minSdkVersion = 18)public class UIAutomatorChangeTextBehaviorTest { private static final String BASIC_SAMPLE_PACKAGE = \"com.markzl.android.testingsample\"; private static final int LAUNCH_TIMEOUT = 5000; private static final String STRING_TO_BE_TYPED = \"UiAutomator\"; private UiDevice mDevice; @Before public void startMainActivityFromHomeScreen() { mDevice = UiDevice.getInstance(getInstrumentation()); mDevice.pressHome(); final String launcherPackage = getLauncherPackageName(); assertThat(launcherPackage, notNullValue()); mDevice.wait(Until.hasObject(By.pkg(launcherPackage).depth(0)), LAUNCH_TIMEOUT); // Launch the blueprint app Context context = getApplicationContext(); final Intent intent = context.getPackageManager() .getLaunchIntentForPackage(BASIC_SAMPLE_PACKAGE); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK); context.startActivity(intent); mDevice.wait(Until.hasObject(By.pkg(BASIC_SAMPLE_PACKAGE).depth(0)), LAUNCH_TIMEOUT); } @Test public void checkPreconditions(){ assertThat(mDevice,notNullValue()); } @Test public void testChangeText_sameActivity(){ mDevice.findObject(By.res(BASIC_SAMPLE_PACKAGE,\"editTextUserInput\")) .setText(STRING_TO_BE_TYPED); mDevice.findObject(By.res(BASIC_SAMPLE_PACKAGE,\"changeTextBt\")) .click(); UiObject2 changedText = mDevice.wait(Until.findObject(By.res(BASIC_SAMPLE_PACKAGE,\"textToBeChanged\")), 500); assertThat(changedText.getText(),is(equalTo(STRING_TO_BE_TYPED))); } @Test public void testChangeText_newActivity(){ mDevice.findObject(By.res(BASIC_SAMPLE_PACKAGE,\"editTextUserInput\")) .setText(STRING_TO_BE_TYPED); mDevice.findObject(By.res(BASIC_SAMPLE_PACKAGE,\"activityChangeTextBtn\")) .click(); UiObject2 changedText = mDevice.wait(Until.findObject(By.res(BASIC_SAMPLE_PACKAGE,\"show_text_view\")), 500); assertThat(changedText.getText(),is(equalTo(STRING_TO_BE_TYPED))); } private String getLauncherPackageName() { final Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_HOME); PackageManager packageManager = getApplicationContext().getPackageManager(); ResolveInfo resolveInfo = packageManager.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY); return resolveInfo.activityInfo.packageName; }} UIAutomator API： UiCollection UiObject UiScrollable UiSelector Configurator","link":"/2019/03/23/Android面试/Android单元测试框架/"},{"title":"Android触摸事件传递机制","text":"触摸事件的类型触摸事件对应的是Android中的MotionEvent类，主要分为三种 ACTION_DOWN：用户按下屏幕触发 ACTION_MOVE： 用户手指在屏幕移动一定距离 ACTION_UP：用户抬起手指，一般代表整个触发事件结束 事件传递的三个阶段Android系统中拥有事件传递处理能力的只有三种：Activity、ViewGroup、View，其中ViewGroup处理较为特殊，多了拦截（Intercept）方法，Activity和View只具备分发和消费。结下来介绍事件传递的三个阶段分发、拦截和消费。 分发（Dispatch）：用户在按下屏幕，系统会首先调用 Activity#dispatchTouchEvent 方进行事件分发 1public boolean dispatchTouchEvent(MotionEvent ev) 拦截（Intercept）: 对应方法 ViewGroup#onInterceptTouchEvent(MotionEvent ev) 可以设置拦截事件 1public boolean onIterceptTouchEvent(MotionEvent ev) 该方法的返回值如果是true表示拦截此事件，交由当前ViewGroup#onTouchEvent消费该事件，不传递给子视图，返回false表示不对事件进行拦截，继续传递给子视图。 消费（Consume）：事件的消费对应着 onTouchEvent 方法 1public booelan onTouchEvent(MotionEvent ev) View 中事件传递分析 总结：用户点击View 首先会调用 Activity中的dispatchTouchEvent方法，如果返回 super.dispatchTouchEvent方法，用户点击事件会继续传递至 View#dispatchTouchEvent 方法，如果返回 true或false 方法是无法向下传递的，且不会触发 View#onClick 事件。 View/ViewGroup 中 dispatchTouchEvent 方法返回值问题，当返回父类默认方法 super.dispatchTouchEvent 方法，事件正常向下传递。返回值 true 或者 false 区别：返回 true 时，代表 View/ViewGroup 的 dispatchTouchEvent 方法可以处理该事件可以响应 ACTION_DOWN、ACTION_MOVE、ACTION_UP等，返回 false 时，只响应 ACTION_DOWN事件。 ViewGroup 中事件传递从Activity –&gt; ViewGroup –&gt; View 角度分析。用户触发 ACTION_DOWN 事件，首先调用 Activity#dispatchTouchEvent 方法，如果返回值为 true或false ，ACTION_DOWN事件将停止传递。如果返回 super.dispactchTouchEvent 默认值，将继续传递到 ViewGroup#dispatchTouchEvent , 如果返回 true 或 false， Android 事件分发机制源码分析我们都知道分析事件传递是ACTION_DOWN、ACTION_MOVE和ACTION_UP事件在Activity、ViewGroup 和View 中的传递过程，主要是依赖下面的三个方法(分发、拦截、消费)： 1public boolean diapatchTouchEvent(MotionEvent event) 用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View 的 onTouchEvent 和下级 View 的 dispatchTouchEvent 方法的影响，表示是否消耗当前事件。 1public boolean onIterceptTouchEvent(MotionEvent event) 只存在于 ViewGroup中，用于判断是否拦截某个事件，如果当前 ViewGroup 拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 1public boolean onTouchEvent(MotionEvent event) 用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次收到事件。 我们先由 Activity#dispatchTouchEvent() 方法开始分析，如下所示： 12345678910// Activity.javapublic boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev);} 我们可以看调用的是 Window#superDispatchTouchEvent() 方法，我们都知到Window接口的唯一实现是PhoneWindow类，方法如下所示： 12345// PhoneWindow.java@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event);} 其中mDecor 为 DecorView实例，Activity的结构是：Activity -&gt; PhoneWindow -&gt; DecorView -&gt; titleView+contentView。DecorView#superDispatchTouchEvent 如下所示： 1234// DecorView.javapublic boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event);} 该方法最终是调用 ViewGroup#dispatchTouchEvent() ，所以我们最终是分析ViewGroup -&gt; View 的事件传递过程。先看一下ViewGroup#dispatchTouchEvent() 中的部分代码： 1234567891011121314151617181920// ViewGroup.java@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) { // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; }} 先分析一下不通过调用拦截方法直接设置 intercepted = true 的情况，mFirstTouchTarget == null 且 事件是除了ACTION_DOWN 以外的事件，从后续的代码中我们可以知道 mFirstTouchTarget 参数的赋值是在ViewGroup的子元素成功处理ACTION_DOWN的时候，所以一旦我们在ViewGroup中拦截此事件，那么ViewGroup 不会再调用拦截方法而直接设置 intercepted = true。 在此方法内部，还有一个特殊值 diallowIntercepte 参数，这个参数由 mGroupFlags这个参数决定，可以通过requestDisallowInterceptTouchEvent方法这个参数： 1234567891011121314151617181920@Overridepublic void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { ... if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) { // We're already in this state, assume our ancestors are too return; } if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; } // Pass it up to our parent if (mParent != null) { mParent.requestDisallowInterceptTouchEvent(disallowIntercept); } ...} 一般由子元素设置解决事件冲突的。可以认为默认为false，当子元素设置这个参数为true时，ViewGroup会默认不拦截除了ACTION_DOWN以外的其他事件。为什么说是除了ACTION_DOWN以外的事件，因为ACTION_DOWN事件会重置mGroupFlags 这个参数。 接下来看一下 mFirstTouchTarget的赋值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// ViewGroup#requestDisallowInterceptTouchEvent(boolean disallowIntercept)...if (!canceled &amp;&amp; !intercepted) { // If the event is targeting accessibility focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } }}... 此方法中遍历子元素，判断子元素是否能够接收到点击事件。是否能够接收点击事件主要由两点来衡量：子元素是否在播动画和点击事件的坐标是否落在子元素的区域，如果子元素满足这两个条件，那么事件就会传递给它来处理。子元素处理事件是通过dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)，而该方法的主要内容如下所示： 1234567...if (child == null) { handled = super.dispatchTouchEvent(event);} else { handled = child.dispatchTouchEvent(event);}... mFirstTouchTarget 的赋值是在 dispatchTransformedTouchEvent() 返回值为true，即子元素成功处理了这个事件之后调用 addTouchTarget(child, idBitsToAssign) 方法时赋值，addTouchTarget 方法如下所示： 123456private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) { final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;} 如果mFirstTarget 为 null ，这有两种可能，第一种是ViewGroup没有子元素，第二种是子元素没有处理这个事件（返回值 false），在这种情况下一般有ViewGroup自己的onTouchEvent() 方法来处理： 123456// Dispatch to touch targets.if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);} View 对点击事件的处理12345678910111213141516171819202122public boolean dispatchTouchEvent(MotionEvent event) { boolean result = false; ... if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } ... return result;} OnTouchListener 方法发生在 onTouchEvent之前，如果OnTouchListener#onTouch 方法返回值为true，将不会调用onTouchEvent() 方法，onClick事件是发生在onTouchEvent方法中的，因此也不会调用。 View 事件冲突的解决办法外部拦截法 例如水平方向的ScrollView内部嵌套ListView，重写ScrollerView的onInterceptTouchEvent方法， 内部拦截法 ViewGroup#requestDisallowIntercept()","link":"/2019/03/23/Android面试/Android触摸事件传递机制/"},{"title":"","text":"View 事件体系 1. View 的基础知识View 的基础知识有：View 的位置参数、MotionEvent 和 TouchSlop 对象、VelocityTracker、GestureD etector 和 Scroller 对象。 1.1 View 的位置参数View 的位置主要由它的四个顶点来决定，分别对应于View的四个属性：top、left、right、bottom，其中top、left为左上角坐标，right和bottom为右下角坐标。 1234left = getLeft();top = getTop();right = getRight();bottom = getBottom(); View 中的其他参数如 x、y、transitionX 和 transitionY，其中x，y为View相对于父容器左上角的坐标，transitionX和transitionY为相对于View左上角坐标的偏移量，初始值为0。几个参数的换算关系为： 12x = left+transitionX ;y = top+transitionY 如果为当前View执行补间动画，View的实际位置不会发生变化即left等四个属性不会改变，此时改变的是x、y、transitionX和transitionY四个变量。注意事项： Event#getRawX() ：获取的是相对于屏幕的坐标 Event#getX()：获取相对于当前View左上角的坐标 View#getX()：获取的是相对于父容器的坐标。 1.2 MotionEvent 和 TouchSlopMotionEvent 产生的典型事件类型如下： ACTION_DOWN 手指接触屏幕 ACTION_MOVE 手指在屏幕上移动 ACTION_UP 手指抬起 每一次点击事件都会触发ACTION_DOWN和ACTION_UP事件，如果有滑动的话也会触发ACTION_MOVE。从ACTION_DOWN 到 ACTION_UP 事件是一次完整的点击的事件流程，当然其中也会有事件分发。 TouchSlop 是系统所能识别的被认为是滑动的最小距离，如果滑动的距离小于这个常量，系统就不会下发ACTION_MOVE 这个事件，可以通过 ViewConfiguration.get(this).getScaledTouchSlop() 方法获取这个常量。 1.3 VelocityTracker、GestureDetector 和 Scroller VelocatiyTracker 速度追踪，用于追踪手指在滑动过程中的速度，包括水平速度和垂直速度，速度是可能为负值的。 12345678VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event);// 设置事件间隔velocityTracker.computeCurrentVelocity(1000);int xVelocity = (int) velocityTracker.getXVelocity();int yVelocity = (int) velocityTracker.getYVelocity();velocityTracker.clear();velocityTracker.recycle(); GestureDetector 手势检测，用于辅助检测用户的单机、滑动、长按、双击等行为。 1234GestureDetector gestureDetector = new GestureDetector(this);// 解决长按无法滑动问题gestureDetector.setIsLongpressEnabled(false);return gestureDetector.onTouchEvent(event); Scroller 主要用来实现View的滑动，当使用 View 的 scrollTo/scrollBy 方法来进行滑动时，其过程是瞬间完成的，没有过渡效果这样用户体验不好。使用Scroller可以实现View滚动时候的过渡效果，其过程不是瞬间完成的，而是在设置的时间间隔内完成。Scroller 本身无法让View实现弹性滑动，需要配合 View#computerScroll 方法。 12345678910111213141516private Scroller scroller;public void smoothScrollTo(int destX, int destY) { int scrollX = getScrollX(); int delta = destX - scrollX; scroller.startScroll(scrollX, 0, delta, 0, 1000); invalidate();}@Overridepublic void computeScroll() { if (scroller.computeScrollOffset()) { scrollTo(scroller.getCurrX(), scroller.getCurrY()); postInvalidate(); }} 2. View绘制的整体流程Android 中 Activity 是作为应用程序的载体存在的，它代表一个完整的用户界面，提供了一个窗口来绘制各种视图，PhoneWindow 是 Activity 和 View 交互的窗口。DecorView 本质上是 FrameLayout ，包含 TitleView 和ContentView，TitleView是我们设置的ActionBar，ContentView是我们在 onCreate 方法中调用 setContentView 时候定义的。 2.1 绘制的整体流程当Activity启动时，绘制会从根视图 ViewRootImpl 的 performTraversals() 方法开始，从上到下遍历整个视图，每个View 控件负责绘制自己，而 ViewGroup 还需要负责通知自己的子 View 进行绘制操作。视图的绘制过程分为三个步骤，分别是测量（Measure）、布局（Layout）和绘制（Draw）。performTraversals() 方法的核心代码如下： 12345678910111213141516private void performTraversals() { ... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ... // 执行测量流程 // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... //执行布局流程 performLayout(lp, mWidth, mHeight); ... //执行绘制流程 performDraw();} 2.2 Measure MeasureSpec 表示的是一个32位的整形值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小 SpecSize。MeasureSpec 是View的一个静态内部类，用来说明应该如何测量这个View。 MeasureSpec 的三种测量模式： UNSPECIFIED：不指定测量模式，父视图没有限制子视图的大小，子视图可以是想要的任何尺寸，通常用于系统内部，应用开发中很少使用到。 EXACTLY：精确测量模式，当前视图的 layout_width 或者 layout_height 指定为具体数值或者match_parent 时生效，表示父视图已经决定了子视图的精确大小，这种模式下View 的测量值就是SpecSize的值。 AT_MOST：最大值模式，当该视图的 layout_width 或 layout_height 指定为wrap_content时生效，此时子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。 对于普通View，其MeasureSpec由父容器的测量模式和自身的LayoutParam 决定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// ViewGroup.javapublic static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode);} 2.3 LayoutLayout 过程用来确定View在父容器中的布局位置，它是由父容器获取子View的位置参数后，调用子View 的layout 方法并将位置参数传入实现的。 2.4. Draw2.4.1 View 绘制顺序 super.onDraw() 方法 12345678public class AppImageView extends ImageView { protected void onDraw(Canvas canvas) { // 如果有背景图片，绘制在背景图片之下 super.onDraw(canvas); // 绘制在背景图片之上 }} super.dispatchDraw() 方法，只存在于 ViewGroup 对象中。每一个 ViewGroup 在绘制时会先调用 onDraw 方法绘制完自己的主体之后才去绘制它的子View。 12345678public class SpottedLinearLayout extends LinearLayout { ... // 把 onDraw() 换成了 dispatchDraw() protected void dispatchDraw(Canvas canvas) { super.dispatchDraw(canvas); //绘制在完成ViewGroup中子View绘制之前 }} super.onDrawForeground() 绘制前景方法，要求 minSdk 版本达到23，不然低版本手机没有效果。 123456789public class AppImageView extends ImageView { ... public void onDrawForeground(Canvas canvas) { // 会被xml设置的 foreground 属性遮住 super.onDrawForeground(canvas); ... // 绘制「New」标签 }} super.draw() 方法 1234567891011public AppEditText extends EditText { ... public void draw(Canvas canvas) { // 绘制在所有绘制发生之前，包括背景 canvas.drawColor(Color.parseColor(\"#66BB6A\")); // 涂上绿色 super.draw(canvas); // View 绘制总调度方法 // 绘制在所有绘制之后 }} draw() 方法是绘制过程的调度方法。一个View的绘制过程都发生在 draw() 方法里，包括绘制背景、主体、子View、滑动相关以及前景的绘制。 123456789101112// View.java 的 draw() 方法的简化版大致结构（是大致结构，不是源码哦）：public void draw(Canvas canvas) { ... drawBackground(Canvas); // 绘制背景（不能重写） onDraw(Canvas); // 绘制主体 dispatchDraw(Canvas); // 绘制子 View onDrawForeground(Canvas); // 绘制滑动相关和前景 ...} 关于绘制方法，有两点需要注意一下： 出于效率的考虑，ViewGroup 默认会绕过 draw() 方法，换而直接执行 dispatchDraw()，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 dispatchDraw() 以外的任何一个绘制方法内绘制内容，你可能会需要调用 View.setWillNotDraw(false) 这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过 setWillNotDraw(false) 了的，例如 ScrollView）。 有的时候，一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在 onDraw() 里，也可以写在其他绘制方法里，那么优先写在 onDraw() ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 onDraw() 的重复执行，以提升开发效率。享受这种优化的只有 onDraw() 一个方法。 3. View 的事件分发机制事件分发机制即 MotionEvent 对象在Activity、ViewGroup、View之间的传递，分发过程主要由三个方法共同完成：dispatchTouchEvent、onInterceptTouchEvent 和 onTouchEvent。 1public boolean diapatchTouchEvent(MotionEvent event) 用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View 的 onTouchEvent 和下级 View 的 dispatchTouchEvent 方法的影响，表示是否消耗当前事件。 1public boolean onIterceptTouchEvent(MotionEvent event) 只存在于 ViewGroup中，用于判断是否拦截某个事件，如果当前 ViewGroup 拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 1public boolean onTouchEvent(MotionEvent event) 用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次收到事件。 当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window (PhoneWindow -&gt; DecorView ) -&gt; ViewGroup -&gt;View，实际上的传递方式是 ViewGroup -&gt; View。这里我们先由ViewGroup 的 dispatchTouchEvent 方法开始分析，ViewGroup#dispatchTouchEvent() 的部分代码逻辑如下所示： 123456789101112131415161718192021// ViewGroup.java@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) { ... // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } ...} 这里可以看到ViewGroup会在如下两种情况下会判断是否拦截当前事件：事件类型为 ACTION_DOWN 或者mFirstTouchTarget != null。从后续的代码中，我可以看到当 ACTION_DOWN 事件被ViewGroup的子元素成功处理时，mFirstTouchTarget 会被赋值指向并指向子元素。所以当ViewGroup中拦截当前事件，此时mFirstTouchTarget参数为空，此时的 ACTION_MOVE 和 ACTION_UP 也无法向下传递且不会再调用ViewGroup#onInterceptTouchEvent 方法。对于参数 disallowIntercept（不允许拦截） 指定true时，intercept为false，这个参数可由ViewGroup某些方法设置，解决ViewGroup和View的事件冲突。 总结： 注意 Activity#dispatchTouchEvent() 方法在返回值为true或false，事件不会继续向下传递且不会触发Activity#onTouchEvent() 方法和View#onClick()方法。 当ACTION_DOWN事件被在ViewGroup#onInterceptTouchEvent() 拦截后，ACTION_MOVE和ACTION_UP事件无法继续传递，且onInterceptTouchEvent() 不再被调用。 某个View如果不消耗ACTION_DOWN事件，那么后续的事件不会交给它处理，并将事件交与它的父View处理。 正常处理顺序优先级 View#onTouchListener &gt; View#onTouchEvent &gt; View#onClickListener。 可以通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干涉父元素的事件分发过程，但是ACTION_DOWN事件触发。例如调用此方法可以处理EditText内容滚动和ScrollView滚动冲突的问题。","link":"/2018/03/23/Android面试/Android自定义View/"},{"title":"Android部分-11：ListView和RecyclerView","text":"1.ListView是什么？如何使用？ 注意ViewHolder复用机制。 2.RecyclerView是什么？如何使用？如何返回不一样的Item。 关键方法：onCreateViewHolder 和 getItemViewType。 3.ListView和RecyclerView的区别是什么？ RecyclerView更具灵活性可自定义设置layoutmanager，itemanimator，itemdivider 4.分别讲讲你对ListView &amp; RecyclerView的优化经验。 使用Constrainlayotu介绍布局层级 可以的话设置，设置RecyclerView等高，然后设置setHasFixedSize(true)，避免重绘Item时重新测量宽高。 根据需求修改RecyclerView默认的缓存选项 123recyclerView.setItemViewCacheSize(20); recyclerView.setDrawingCacheEnabled(true); recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH); onBindViewHolder减少View重复创建，逻辑判断，临时变量创建，复用事件监听而不是重复创建事件监听器，ViewHolder中通过SparseArray保存view引用。 避免刷新整个列表notifyItemRange、notifyItemInsert。 5.给我说说RecyclerView的回收复用机制。 CacheView ViewPool 6.说说你是如何给ListView &amp; RecyclerView加上拉刷新 &amp; 下拉加载更多机制。 7.谈谈你是如何对ListView &amp; RecycleView进行局部刷新的？ 8.谈谈如何进行分页加载？ 9.ScrollView下嵌套一个ListView通常会出现什么问题？ 10.一个ListView或者一个RecyclerView在显示新闻数据的时候，出现图片错位，可能的原因有哪些 &amp; 如何解决？","link":"/2019/03/23/Android面试/Android部分-11：ListView和RecyclerView/"},{"title":"Android部分-10：文件存储","text":"1.说说Android中数据持久化的方式 &amp; 使用场景。 SharedPrefence、Internal Storage、External Storage、SQLite Database、Network Connection 2.接触过MMKV吗？说说SharedPreference和它的区别。 MMKV是基于mmap内存映射的移动端key-value组件，底层序列化/反序列化使用protobuf实现。 3.第三方数据库框架用过哪些？有没有自己封装过一个SQLite的库？ 4.SQLite是线程安全的吗 &amp; SharedPreference是线程安全的吗？ 是 5.请简单的给我说说什么是三级缓存？ 网络缓存、内存缓存（LruCache）、磁盘缓存（DiskCache） 6.SharedPreference的apply和commit的区别。 apply是异步任务，无返回值 commit是同步操作，有返回值 7.谈谈你对SQLite事务的认识。 原子性、一致性、隔离性、持久性 8.千奇百怪的SQL语句考察。 9.SharedPreference跨进程使用会怎么样？如何保证跨进程使用安全？ 不支持跨进程。 12345678910111213141516171819202122232425262728293031// SharedPrefenceImpl.java@Overridepublic SharedPreferences getSharedPreferences(File file, int mode) { SharedPreferencesImpl sp; synchronized (ContextImpl.class) { final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked(); sp = cache.get(file); if (sp == null) { checkMode(mode); if (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) { if (isCredentialProtectedStorage() &amp;&amp; !getSystemService(UserManager.class) .isUserUnlockingOrUnlocked(UserHandle.myUserId())) { throw new IllegalStateException(\"SharedPreferences in credential encrypted \" + \"storage are not available until after user is unlocked\"); } } sp = new SharedPreferencesImpl(file, mode); cache.put(file, sp); return sp; } } if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) { // If somebody else (some other process) changed the prefs // file behind our back, we reload it. This has been the // historical (if undocumented) behavior. sp.startReloadIfChangedUnexpectedly(); } return sp;} 源码分析 SharedPreference类：SharedPrefence先从内存中获取实例，如果内存不存在，从磁盘中读取， 123456789101112131415161718192021222324252627282930@Overridepublic SharedPreferences getSharedPreferences(File file, int mode) { SharedPreferencesImpl sp; synchronized (ContextImpl.class) { final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked(); sp = cache.get(file); if (sp == null) { checkMode(mode); if (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) { if (isCredentialProtectedStorage() &amp;&amp; !getSystemService(UserManager.class) .isUserUnlockingOrUnlocked(UserHandle.myUserId())) { throw new IllegalStateException(\"SharedPreferences in credential encrypted \" + \"storage are not available until after user is unlocked\"); } } sp = new SharedPreferencesImpl(file, mode); cache.put(file, sp); return sp; } } if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) { // If somebody else (some other process) changed the prefs // file behind our back, we reload it. This has been the // historical (if undocumented) behavior. sp.startReloadIfChangedUnexpectedly(); } return sp;} 10.谈谈SQLite升级要注意哪些地方？","link":"/2019/03/23/Android面试/Android部分-10：文件存储/"},{"title":"Android部分-12：图片编程","text":"1.你对Bitmap了解吗？它在内存中如何存在？Bitmap位图包括像素以及长、宽、颜色等描述信息。长宽和像素位数是用来描述图片的，可以通过这些信息可以计算图片所占内存大小。位图可以理解为一个画架，把图放在上面然后可以对图片做一系列的处理。位图文件图像显示效果好，但是非压缩格式，需要占用较大的内存空间。 Config：表示图片像素类型，包括ALPHA_8、RGB565、ARGB_4444、ARGB_8888 ARGB_8888：4个通道都是8位，每个像素占用4个字节，图像效果最好，但占用内存较大 ARGB_4444：4个通道都是4位，每个像素占用2个字节，图像失真较为严重 RGB565：没有A通道，3个通道，每个像素占用2个字节，图像失真小，但是没有透明度。 ALPHA_8：只有A通道，每个像素占用1个字节，只有透明度，没有颜色值 压缩格式CompressFormat：CompressFormat.JPEG、CompressFormat.PNG和CompressFormat.WEBP JPEG：一种有损压缩（JPEG2000即可以有损也可以无损），文件后缀 .jpg 和 .jpeg；采用直接色，有丰富的色彩适合存储图片和生动效果图像；缺点：有损，不适合存储logo或线框图等等。 PNG：一种无损压缩，文件后缀.png；优点：支持透明，无损，主要用于小图标，透明背景等；缺点：若色彩复杂，则图片生成后文件很大。 WEBP：以WebP算法进行压缩；Google开发的新的图片格式，同时支持无损和有损压缩，使用直接色。无损压缩，相同质量的webp比PNG小大约26%；有损压缩，相同质量的webp比JPEG小25%-34% 支持动图，基本取代gif 2.有关Bitmap导致OOM的原因知道吗？如何优化？ 采样压缩 1234567891011BitmapFactory.Options options = new BitmapFactory.Options();//inJustDecodeBounds为true，不返回bitmap，只返回这个bitmap的尺寸options.inJustDecodeBounds = true;BitmapFactory.decodeResource(getResources(), imgResId, options);//利用返回的原图片的宽高，我们就可以计算出缩放比inSampleSize（只能是2的整数次幂）options.inSampleSize = calculateSampleSize(options, reqWidth, reqHeight);options.inPreferredConfig = Bitmap.Config.RGB_565;//inJustDecodeBounds为false，返回bitmapoptions.inJustDecodeBounds = false;Bitmap bitmap = BitmapFactory.decodeResource(getResources(),imgResId,options); 1234567891011private int calculateSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) { int width = options.outWidth; int height = options.outHeight; int halfWidth = width / 2; int halfHeight = height / 2; int inSampleSize = 1; if ((halfWidth / inSampleSize) &gt;= reqWidth &amp;&amp; (halfHeight / inSampleSize) &gt;= reqHeight) { inSampleSize *= 2; } return inSampleSize;} 缓存策略 LruCache 和 DiskLruCache 异步加载 Handler 和 线程池 3.给我谈谈图片压缩。 质量压缩 1234567891011121314/** * 质量压缩 * * @param srcBitmap 源bitmap * @param compressFormat 图片压缩格式 * @param quality 压缩质量 * @return 返回压缩之后的bitmap */public static Bitmap compressByQuality(Bitmap srcBitmap, Bitmap.CompressFormat compressFormat, int quality) { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); srcBitmap.compress(Bitmap.CompressFormat.WEBP, quality, byteArrayOutputStream); byte[] bytes = byteArrayOutputStream.toByteArray(); return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);} 采样压缩 1234567891011121314151617181920/** * 采样压缩 * * @param context 上下文 * @param resId 资源文件id * @param reqWidth 设置的图片宽度 * @param reqHeight 设置的图片高度 * @return 返回采样后的Bitmap */public static Bitmap compressBySampleSize(Context context, int resId, int reqWidth, int reqHeight) { BitmapFactory.Options options = new BitmapFactory.Options(); // 仅获取尺寸信息 options.inJustDecodeBounds = true; BitmapFactory.decodeResource(context.getResources(), resId, options); options.inSampleSize = calculateSampleSize(options, reqWidth, reqHeight); options.inPreferredConfig = Bitmap.Config.RGB_565; options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(context.getResources(), resId, options);} 4.LruCache &amp; DiskLruCache原理。12345678910111213141516171819202122public final V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException(\"key == null || value == null\"); } V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } trimToSize(maxSize); return previous;} 12345678//在LruCache构造方法中通过maxsize指定最大内存，通过重写sizeOf方法指定添加的数据占用内存大小private int safeSizeOf(K key, V value) { int result = sizeOf(key, value); if (result &lt; 0) { throw new IllegalStateException(\"Negative size: \" + key + \"=\" + value); } return result;} 5.说说你平常会使用的一些第三方图片加载库,最好给我谈谈它的原理。6.如果让你设计一个图片加载库，你会如何设计？缓存，压缩。 7.有一张非常大的图片,你如何去加载这张大图片？BitmapRegionDecoder，按照区域进行加载。BitmapRegionDecoder.newInstance。 8.你知道Android中处理图片的一些库吗(OpenCv &amp; GPUImage …)？9.如何计算一张图片在内存中占用的大小？查看详情","link":"/2019/03/23/Android面试/Android部分-12：图片编程/"},{"title":"Android部分-13：WebView","text":"1.WebView是什么？ WebViewSetting、WebViewClient、WebViewChromeClient。 2.WebView会导致内存泄露吗？原因是什么？解决方式有哪些? 3.你知道Hybrid开发吗？说说你的相关经验。 4.说说WebSettings &amp; WebViewClient &amp; WebChromeClient这三个类的作用 &amp; 用法。 5.说说你了解的Hybrid框架。 6.如何提高原生的WebView加载速度？ 7.谈谈你对webView工作机制的认识,你在项目中优化过它吗？说说是从哪些方面着手的？","link":"/2019/03/23/Android面试/Android部分-13：WebView/"},{"title":"Android部分-1：Activity答案","text":"1.Activity是什么？ 加载View同时负责处理用户的交互 2.典型情况下的Activity生命周期？(校招&amp;实习) onCreate onStart onResume onPause onStop onDestory (onRestart 从不可见状态到可见状态调用) 3.异常情况下的Activity的生命周期 &amp; 数据如何保存和恢复？ 异常情况下的生命周期主要有两种情况： 横竖屏切换即关于configChange属性的分析 系统资源内存不足导致优先级低的Activity被回收（优先级：前台Activity、可见非前台、后台Activity） 生命周期：异常情况出现 -&gt;onPause-&gt; onSaveInstanceState -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt;onRestoreInstanceState -&gt; onResume。 4.从Activity A跳转到Activity B之后，然后再点击back建之后，它们的生命周期调用流程是什么？ 执行完 Activity A的onPause方法之后，即执行ActivityB的onCreate、onStart、onResume，然后执行 Activity A的 onStop 方法。所以onPause方法不推荐执行耗时操作，会影响下一个Activity的启动。原因请见Activity 启动流程源码分析。 5.如何统计Activity的工作时间？ onResume onPause 方法。 6.给我说说Activity的启动模式 &amp; 使用场景。 standard（标准模式） singleTop（栈顶复用） singleTask（栈内复用）知识点包括 clearTop、onNewIntent。通过TaskAffinity 属性指定Activity所属任务栈以及 allowTaskReparenting 属性（是否添加到所属应用的任务栈） singleInstance（单任务栈单实例） 7.如何在任意位置关掉应用所有Activity &amp; 如何在任意位置关掉指定的Activity？ 集合 List&lt;Activity&gt; 8.Activity的启动流程(从源码角度解析)？ 启动APP的流程会由 Instrumentation 来处理，然后它通过Binder 向 AMS（ActivitManagerService） 发送请求，AMS内部维护着一个 ActivityStack 并负责栈内的 Activity 的状态同步，AMS 通过 ActivityThread 去同步 Activity 的状态从而完成生命周期方法的调用。 9.启动一个其它应用的Activity的生命周期分析 即启动不同任务栈的Activity 10.Activity任务栈是什么？在项目中有用到它吗？说给我听听 TaskAffinity 属性 11.什么情况下Activity不走onDestory? 在Activity A中打开Activity B ，这时候走后台杀掉进程，不会调用 Activity B 的onDestory 方法。 12.什么情况下Activity会单独执行onPause? Activity 位于可见但不位于前台（栈顶）（例如打开一个透明主题的Activity） 13.a-&gt;b-&gt;c界面，其中b是SingleInstance的，那么c界面点back返回a界面，为什么？ 与SingleTask指定其他任务栈模式一样，ac在同一任务栈，b在单独任务栈 14.如果一个Activity弹出一个Dialog,那么这个Acitvity会回调哪些生命周期函数呢？ Dialog（非Dialog样式的Activity） 不会影响Activity的生命周期 15.Activity之间如何通信 &amp; Activity和Fragment之间通信 &amp; Activity和Service之间通信？ Activity之间如何通信: Intent Bundle Activity和Fragment之间通信：setArgument、 回调 Activity和Service之间通信：IPC(Messagener、 aidl） 16.说说Activity横竖屏切换的生命周期。 1234567D/MainActivity: onPauseD/MainActivity: onSaveInstanceStateD/MainActivity: onStopD/MainActivity: onDestroyD/MainActivity: onStartD/MainActivity: onRestoreInstanceStateD/MainActivity: onResume 17.前台切换到后台，然后在回到前台时Activity的生命周期。 Home 键按下的生命周期分析 onPause() -&gt; onStop -&gt; onReStart -&gt; onStart -&gt; onResume 18.下拉状态栏时Activity的生命周期？ 不影响生命周期 19.Activity与Fragment的生命周期比较？ Fragment 生命周期 onAttach -&gt; onCreate -&gt; onCreateView -&gt; onActivityCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestoryView -&gt; onDestory -&gt; onDetach 20.了解哪些Activity常用的标记位Flags？ FLAG_SINGLE_TOP、FLAG_NEW_TASK、FLAG_CLEAR_TOP 21.谈谈隐式启动和显示启动Activity的方式？ IntentFilter、action、category、data（scheme协议） 22.Activity用Intent传递数据和Bundle传递数据的区别？为什么不用HashMap呢？ Android 28 版本中 Intent.putExtra 中最后是调用 Bundle 传递。A 通过 B 传递给 C ，直接传Bundle即可，而不需要一个个取出再传递。为什么不用HashMap呢？Bundle 底层实现是通过ArrayMap，ArrayMap在数据量相对小的时候性能优于HashMap。 23.在隐式启动中Intent可以设置多个action,多个category吗 &amp; 顺便讲讲它们的匹配规则？ 可以。满足action中的一个选项和category的一个选项即可 24.Activity可以设置为对话框的形式吗？ 可以。指定对话框主题即可 25.如何给Activity设置进入和退出的动画？ overridePendingTransition 或 设置主题。查看详情 26.Activity使用Intent传递数据是否有限制 &amp; 如果传递一个复杂的对象，例如一个复杂的控件对象应该怎么做？ 有限制。Intent 传递数据是通过 Binder 实现，Binder 的缓冲区大小只有1M。（Activity 之间传递数据需要考虑到跨进程的问题）。传输数据序列化和 Bundle 没有关系，只与 Binder 的跨进程通信有关。 例如 Fragment 的 setArgument(Bundle) 方法传递对象无需序列化（Fragment 本身是不涉及跨进程的）。查看详情 RemoteViews 27.在Activity中可以多次调用setContentView方法吗？说说不同时机第二次调用setContentView会发生什么？ 可以。移除第一次设置的布局，保留第二次设置布局 28.说说分别在Activity里每一个生命周期函数里调用finish方法后，接下来Activity的生命周期如何回调？ onCreate 方法中调用 onCreate -&gt; onDestory onStart 方法中调用 onCreate -&gt; onStart -&gt; onStop -&gt; onDestory onResume 方法中调用 onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory 29.有什么方法可以启动一个没有在AndroidManifest.xml中注册过的Activity?查看详情 链接文章仅供参考，Android 28 已移除 ActivityManagerNative类。 30.在Activity进行配置时，category和action的区别是什么？ action 声明接受Intent的操作 category 声明接受Intent的类别 （data中mime 声明的是接受的数据类型） 31.activity中分别在onCreate，onStart，onResume中调用finish后的生命周期如何回调？ 见问题28. 32.锁定屏与解锁屏幕，Activity 生命周期？ 锁定屏幕：onPause -&gt; onSaveInstance -&gt; onStop 解锁屏幕：onRestart -&gt; onStart -&gt; onResume 33.如何设置Activity进入和退出的动画？ 见问题25. 34.谈谈你对Activity中onNewIntent()方法的认识？ singleTop 位于栈顶 ，singleTask，singleInstance。 36.Activity之间传递数据的方式Intent是否有大小限制，如果传递的数据量偏大，有哪些方案？ 有见问题26。SQLite 或者文件存储。 37.了解scheme跳转协议吗？谈一谈 scheme host pathPrefix pathPattern。如何创建链接跳转，查看详情 38.谈谈你对Activity的Context的认识？ Activity 是继承关系 ContextThemeWrapper -&gt; ContextWrapper 的，ContextWrapper 是继承Context，所以Context 对象可以使用子类中的所有方法。Context 中提供了关于应用环境全局的接口，允许获取以应用为特征的资源和类型。查看详情 39.如何在Application中获取当前Activity实例？查看详情 在BaseActivity 中当Activity 创建时保存当前Activity实例，需要的时候取出使用即可。 在Application 中 使用registerActivityLifecycleCallbacks( ActivityLifecycleCallbacks) 回调方法中保存当前Activity实例。 通过反射的方法取ActivityThread中非 paused 状态的Activity即为当前Activity（不可靠，源码有可能会修改） 40.Activity进程优先级？ 前台、可见非前台、后台 41.Activity出现ANR的条件有哪些 &amp; 解决方案？查看详情 ANR（Application Not Responding）。Android中，在主线程（UI 线程）没有按规定时间没有处理完相应工作就会出现 ANR 异常。出现 ANR 的条件： Activity 中触摸和点击事件5秒内没有相应 BroadCastReceiver 的时间（前台广播 10s，后台广播 60s） service 前台20s后台200s未完成启动 ContentProvider 的publish在10s内未完成 解决方案： 避免在四大组件生命周期内执行耗时操作。例如数据库操作，或者本地存储文件读取等。 避免主线程某些操作被锁定，引发死锁操作触发ANR异常。","link":"/2019/03/23/Android面试/Android部分-1：Activity答案/"},{"title":"Android部分-3：ContentProvider","text":"1.什么是内容提供者？ 内容提供程序有助于管理应用其自身和其他应用所存储数据的访问，并提供与其他应用共享数据的方法。 2.说说如何创建自己应用的内容提供者 &amp; 使用场景。 我们一般用内容提供者都是用来查询数据的： Cursor cursor = getContentResolver().query(final Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, CancellationSignal cancellationSignal) uri，指定查询某一个程序下的某一张表 projection，指定查询的列名 selection，指定查询条件，相当于sql语句中where后面的条件 selectionArgs，给selection中的占位符提供具体的值 orderBy，指定查询结果排序方式 cancellationSignal，取消正在进行操作的信号量 3.说说ContentProvider的原理 Binder + 存储（SQLite或其他存储） 4.ContentProvider,ContentResolver,ContentObserver之间的关系？ 5.说说ContentProvider的权限管理。 android:grantUriPermssions:临时许可标志。 android:permission:Provider读写权限。 android:readPermission:Provider的读权限。 android:writePermission:Provider的写权限。 android:enabled:标记允许系统启动Provider。 android:exported:标记允许其他应用程序使用这个Provider。 android:multiProcess:标记允许系统启动Provider相同的进程中调用客户端。","link":"/2019/03/23/Android面试/Android部分-3：ContentProvider/"},{"title":"Android部分-2：BroadcastReceiver答案","text":"1.广播是什么？ 基于发布订阅模式，用于系统或者app之间交流的组件 2.广播的注册方式有哪些？ 静态注册，在AndroidManifest.xml 文件中声明 123456&lt;receiver android:name=\".MyBroadcastReceiver\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\"/&gt; &lt;action android:name=\"android.intent.action.INPUT_METHOD_CHANGED\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 动态注册，在代码调用 registerReceiver(BroadcastReceiver,IntentFliter) 1234IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(Intent.ACTION_BOOT_COMPLETED);intentFilter.addAction(Intent.ACTION_INPUT_METHOD_CHANGED);context.registerReceiver(receiver,intentFilter); 3.广播的分类(发送广播方式) &amp; 特性 &amp; 使用场景？ 无序广播 sendBroadcast(Intent) context.sendBroadcast(Intent)方法发送的广播，不可被拦截，当然发送的数据，接收者是不能进行修改的。 有序广播 sendOrderedBroadcast(Intent,String) 方法一次将广播发送到一个接收器。当每个接收器轮流执行时，它可以将结果传播到下一个接收器，或者可以完全中止广播，从而不会将其传递给其他接收器。可以使用匹配的intent-filter的android：priority属性控制接收者的运行顺序；具有相同优先级的接收器将以任意顺序运行。可被拦截，而且接收者是可以修改其中要发送的数据，修改和添加都是可以的，这就意味着优先接收者对数据修改之后，下一个接收者接受的数据是上一个接收者已经修改了的 本地广播 LocalBroadcastManager.sendBroadcast(Intent) 仅在APP内部传递的广播，无需处理跨进程通信。 4.说说系统广播和本地广播的原理 &amp; 区别 &amp; 使用场景。 本地广播基于Handler实现，使用场景是仅在APP应用内通信 系统广播基于Binder机制向AMS发送广播，AMS查找符合条件（IntentFliter/Permission等）的BroadcastReceiver，将广播发送到相应的BroadcastReceiver的消息队列。 参考资料：常见系统广播 监听网络变化 android.net.conn.CONNECTIVITY_CHANGE 关闭或打开飞行模式 Intent.ACTION_AIRPLANE_MODE_CHANGED 充电时或电量发生变化 Intent.ACTION_BATTERY_CHANGED 电池电量低 Intent.ACTION_BATTERY_LOW 电池电量充足（即从电量低变化到饱满时会发出广播 Intent.ACTION_BATTERY_OKAY 系统启动完成后(仅广播一次) Intent.ACTION_BOOT_COMPLETED 按下照相时的拍照按键(硬件按键)时 Intent.ACTION_CAMERA_BUTTON 屏幕锁屏 Intent.ACTION_CLOSE_SYSTEM_DIALOGS 设备当前设置被改变时(界面语言、设备方向等) Intent.ACTION_CONFIGURATION_CHANGED 插入耳机时 Intent.ACTION_HEADSET_PLUG 未正确移除SD卡但已取出来时(正确移除方法:设置–SD卡和设备内存–卸载SD卡) Intent.ACTION_MEDIA_BAD_REMOVAL 插入外部储存装置（如SD卡） Intent.ACTION_MEDIA_CHECKING 成功安装APK Intent.ACTION_PACKAGE_ADDED 成功删除APK Intent.ACTION_PACKAGE_REMOVED 重启设备 Intent.ACTION_REBOOT 屏幕被关闭 Intent.ACTION_SCREEN_OFF 屏幕被打开 Intent.ACTION_SCREEN_ON 关闭系统时 Intent.ACTION_SHUTDOWN 重启设备 Intent.ACTION_REBOOT ……","link":"/2019/03/23/Android面试/Android部分-2：BroadcastReceiver答案/"},{"title":"Android部分-4：Service","text":"1.什么是Service? Service 是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。此外，组件可通过绑定到服务与之进行交互，甚至是执行进程间通信（IPC）。例如，服务可在后台处理网络事务、播放音乐，执行文件I/O或与内容提供程序进行交互。 2.说说Service的生命周期 startService()：由 startService 方法启动的服务，在服务内任务执行完成，需要通过 stopService 或者 stopSelf 方法停止这个服务。 首次创建 onCreate() 、onStartComand() 、onDestory() bindService()：与Activity的生命周期所绑定。 onCreate()、onBind()、onUnBind()、onDestory() 3.Service和Thread的区别？ 如果可以Activity onPause之前处理耗时操作，无需创建线程。 Service 无法直接处理耗时操作，需要开启子线程来处理。（例外，如IntentService） Thread 的处理场景是用户与应用直接交互的场景，直接开启线程来执行异步任务。 4.Android 5.0以上的隐式启动问题及其解决方案。 123456789101112private void validateServiceIntent(Intent service) { if (service.getComponent() == null &amp;&amp; service.getPackage() == null) { if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) { IllegalArgumentException ex = new IllegalArgumentException( \"Service Intent must be explicit: \" + service); throw ex; } else { Log.w(TAG, \"Implicit intents with startService are not safe: \" + service + \" \" + Debug.getCallers(2, 3)); } } } Android 5.0 中源码判断Service是否显示启动。若要绕过这些判断，可以设置intent的component或者package属性，例如： 1234Intent intent = new Intent(); ComponentName componentName = new ComponentName(pkgName,serviceName); intent.setComponent(componentName); context.startService(intent); 1234Intent mIntent = new Intent(); mIntent.setAction(\"XXX.XXX.XXX\");//你定义的service的action mIntent.setPackage(getPackageName());//这里你需要设置你应用的包名 context.startService(mIntent); 5.给我说说Service保活方案。 onStartComand 返回值设置START_STICKTY、START_NOT_STICKTY、START_REDELIVER_INTENT Service的onDestory方法中设置广播唤醒 Service的优先级设置和前台Service 6.IntentService是什么 &amp; 原理 &amp; 使用场景。 IntentService 内部使用HandlerThread处理异步任务，handlerIntent所在线程为子线程。处理耗时操作 7.创建一个独立进程的Service应该怎样做？ android:process = &quot;&quot; 8.Service和Activity之间如何通信？ 文件存储、Messager、AIDL、Socket、ContentProvider 9.说说你了解的系统Service。 ActivityManagerService、WindowManagerService、PowerManagerService… 10.谈谈你对ActivityManagerService的理解。 系统是通过ActivityManagerService 管理Activity相关组件的启动执行。 11.在Activtiy中创建一个Thread和在一个Service中创建一个Thread的区别？ Activity 和 Service 中创建的Thread一般来说必须在组件的生命周期中执行，Service的生命周期相对比较长。","link":"/2019/03/23/Android面试/Android部分-4：Service/"},{"title":"Android部分-5：Handler","text":"1.子线程一定不能更新UI吗？ 子线程更新UI的检测异常是在ViewRootImpl的checkThread方法，而ViewRootImpl是在onResume方法之后创建的，所以在Android的onResume生命周期之前是可以在子线程更新UI。 SurfaceView 2.给我说说Handler的原理。 Message(单向链表) MessageQueue（延时，线程的阻塞和唤醒） Looper ThreadLocal 3.Handler导致的内存泄露你是如何解决的？ 静态类和弱引用（WeakReference） 4.如何使用Handler让子线程和子线程通信？ HandlerThread 或者 调用Looper.prepare()和Looper.loop()创建子线程的Looper对象; 5.你能给我说说Handler的设计原理？ 见Question 2 6.HandlerThread是什么 &amp; 原理 &amp; 使用场景？ 子线程之间通信。重写run方法实现创建Looper轮询。（Looper.prepare() 和 Looper.loop()） 7.IdleHandler是什么？ 消息轮询空闲时间执行的消息处理任务。 123456Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() { @Override public boolean queueIdle() { return false; }}); 12345678910111213141516171819202122232425262728293031323334353637383940Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { ... // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, \"IdleHandler threw exception\", t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; }} 8.一个线程能否创建多个Handler,Handler和Looper之间的对应关系？ 一个Looper，一个MessageQueue，多个Handler 9.为什么Android系统不建议子线程访问UI？ UI控件不是线程安全的，子线程访问UI会造成不可预期的状态 为什么不使用加锁机制 加锁会很大程度上降低UI的访问效率。 10.Looper死循环为什么不会导致应用卡死？ Activity的执行过程本就应该在死循环中运行，便于接受生命周期切换的消息。在消息队列为空的情况下，该线程会进入休眠状态，CPU也会释放相应资源。 11.使用Handler的postDealy后消息队列有什么变化？ 线程会阻塞设置的延迟时间，在此时间段内如果有新的消息被发出且时间小于上次消息执行时间，消息将会被唤醒。 12.可以在子线程直接new一个Handler出来吗？ 可以，但是需要调用Handler带有Looper实例的构造方法。 13.Message对象创建的方式有哪些 &amp; 区别？ Mesage.obtain() 从Messsage对象池中获取。 12345678910111213public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; } } return new Message();} 14.ANR和Handler存在什么联系吗？ 使用异步任务消息处理机制可以避免ANR异常产生 15.子线程的Looper和主线程的Looper有什么区别？ 属于各自线程的Looper循环 16.说说Handler为什么不能进行跨进程通信？ Handler用于可以共享内存的同一进程 17.Handler的消息延时是如何实现的？ 线程的阻塞和唤醒 18.什么是消息屏障？查看详情 通过设置同步屏障，可以使Handler优先处理异步任务。 19.假设主线程new了Handler A和Handler B以及Handler C,现在有个子线程，在子线程中通过Handler C发送了一条消息，那么Handler A和Handler B能接收到吗？为什么？ 不可以，Message的target参数指定了接受消息的Handler实例","link":"/2019/03/23/Android面试/Android部分-5：Handler/"},{"title":"Android部分-6：AsyncTask","text":"1.AsyncTask是什么？能解决什么问题 处理异步任务 2.给我谈谈AsyncTask的三个泛型参数作用 &amp; 它的一些方法作用。 AsyncTask&lt;params,progress,result&gt; 输入参数类型，进度参数类型，返回参数类型 方法作用： onPreExecute：任务执行之前调用 doInBackground：任务执行在子线程 onProgressUpdated：进度更新提示 onPostResult：返回值参数处理 3.给我说说AsyncTask的原理。 线程池和Handler的封装 4.你觉得AsyncTask有不足之处吗？ 内存泄漏：静态类、弱引用 生命周期：onDestory中调用AsyncTask中的cancel方法。 结果丢失：Actvity回收之后，AsyncTask持有的Actvity对象为无效引用 并行和串行：3.0 之后默认是顺序执行，通过调用executeOnExecutor(Executor)设置可以并行执行。","link":"/2019/03/23/Android面试/Android部分-6：AsyncTask/"},{"title":"Android部分-7：Fragment","text":"《Android Fragment 非常详细的一篇》 1.Android中v4包下Fragment和app包下Fragment的区别是什么？ v4 包下的Fragment是兼容到Android1.6版本的。 2.Fragment的生命周期 &amp; 请结合Activity的生命周期再一起说说。 onAttach onCreate onCreateView onActivityCreate onStart onResume onPause onStop onDestoryView onDestory onDetach 3.说说Fragment如何进行懒加载。 关键方法：setUserVisibleHint()是否对用户可见，onViewCreate：View是否创建完毕 4.ViewPager + Fragment结合使用会出现内存泄漏吗 &amp; 如何解决？ ViewPager在使用FragmentPagerAdapter时候，当Fragment被销毁而List集合仍然持有Fragment的引用。1. List集合中保存Fragment的Class List&lt;Class&gt; ，通过反射Class的newInstance创建新的Fragment实例。List引用对象为强引用。 5.Fragment如何和Activity进行通信 &amp; Fragment之间如何进行通信？ Fragment如何和Activity进行通信： setArgument(Bundle) 和 接口回调 Fragment之间如何进行通信：通过宿主Activity实现或者ViewModel+LiveData。 6.给我谈谈Fragment3种切换的方式以及区别 &amp; 使用场景。 add() &amp; remove()：replace()实际上是调用 add() 和 remove() 方法remove 如果Fragment没有被加入回退栈中，Fragment实例会直接被销毁。add 方法向Activity添加Fragment实例 show() &amp; hide()：hide() 和 show() 不会重新创建Fragment，保留Fragment引用。 attach() &amp; detach：调用detach是从ViewTree删除视图，Fragment的状态由FragmentManager保存，在使用attach方法会重新调用onCreateView重绘视图。使用此方法注意重复创建View造成的滑动卡顿问题，可通过view的parent的removeView删除与当前view的关联来解决。 remove 和 detach 区别在于： remove：onPause-&gt;onStop-&gt;onDestroyView-&gt;Destory-&gt;onDetach detach：onPause-&gt;onStop-&gt;onDestroyView 7.getFragmentManager,getSupportFragmentManager,getChildFragmentManager之间的区别？ getFragmentManager和getSupportFragmentManager主要区别在于V4包中默认兼容1.6以上的版本。 getChildFragmentManager属于Fragment中： 8.FragmentPagerAdapter和FragmentStatePagerAdapter区别？ 区别在于onDestroyItem方法中。FragmentPagerAdapter会调用detach方法移除Fragment视图，但是List集合中仍然持有Fragment的引用。FragmentStatePagerAdapter调用remove方式销毁Fragment实例，在销毁Fragment之前会保存当前Fragment的操作状态saveInstance，再次创建时根据保存的操作状态创建新的Fragment。 9.Fragment如何实现类似Activity栈的压栈和出栈效果的？ FragmentManager实现压栈出栈效果。FragmentTransition记录每一次操作轨迹，通过是否调用addToBackStack设置标识位mAddToBackStack来判断是否要将此次操作加入返回栈。 addToBackStack相对操作。popBackStack","link":"/2019/03/23/Android面试/Android部分-7：Fragment/"},{"title":"Android部分-8：序列化","text":"1.什么是序列化 &amp; 能用来干什么？ 持久化存储，深拷贝。 2.Android中序列化方式有几种？说说它们的区别。 Serializable 持久化存储，IO流读写，磁盘存储，序列化过程中会产生大量的临时变量（原理是使用反射机制），频繁调用GC回收机制。 Parcelable 无法持久化存储，通过内存读写，通过IBinder作为信息载体，在内存上的开销较小，因此在内存之间进行数据传递时，推荐使用Parcelable。 3.如果想要序列化的类中某些字段不序列化，那么应该怎么做？ transient","link":"/2019/03/23/Android面试/Android部分-8：序列化/"},{"title":"Android部分-9：IPC","text":"1.说说你对Android多进程开发的认识？Android多进程 进程时资源分配的最小单位，线程是任务调度的最小单位。 每个进程都有独立的资源和存储空间 其他进程不能任意访问当前进程的资源 系统给每个进程分配的内存都有限制 2.Android中进程间通信的方式有哪些？ 文件存储、SQLite、ContentProvier、Socket、AIDL、Messenger 3.什么是AIDL?如何创建一个AIDL。","link":"/2019/03/23/Android面试/Android部分-9：IPC/"},{"title":"Dagger2使用详解","text":"注解分类：@Inject、@Module、@Provides、@Component、@Qualifier、@Scope、@Singleten。 1. 通过@Inject生成实例生成，并通过@Inject注入。 @Inject 有两个作用，一是通过Moudle中@Provider定义方法提供实例，二是当@Inject标记构造方法时会提供依赖，注入到@Inject 注解的变量当中，如下所示： 12345678910111213public class Car { @Inject Engine engine; public Car() { DaggerCarComponent.builder().build().inject(this); } public Engine getEngine() { return this.engine; }} @Inject 注解同样可以实现不带参数构造方法生成实例 123456789public class Engine { @Inject Engine(){} public void run(){ System.out.println(\"引擎转起来了~~~\"); }} @Component 1234@Component(modules = {CarModule.class})public interface CarComponent { void inject(Car car);} 2. 通过@Module和@Providers提供实例，@Inject实现注入。@Module：@Module用于标注提供依赖的类。你可能会有点困惑，上面不是提到用@Inject标记构造函数就可以提供依赖了么，为什么还需要@Module？很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果我们只简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。 @Module 和 @Provides，@Inject 注释的参数类型和Module中方法的返回值相关联。在方法中要使用@Qualifier注解区分相同返回类型的方法。 1234567891011121314public class Engine { private String name; public Engine(String name) { System.out.println(\"Create Engine\"); this.name = name; } public void run() { System.out.println(name + \" 引擎转起来了~~~\"); }} @Provides：@Provides用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值； 12345678910111213141516171819202122@Modulepublic class CarModule { public CarModule() {} @Provides Engine providerEngine() { return new Engine(\"gear\"); } @QualifierA @Provides Engine provideEngineA(){ return new Engine(\"gearA\"); } @QualifierB @Provides Engine provideEngineB(){ return new Engine(\"gearB\"); }} @Qualifier 实现指定注入的方法 123456789@Qualifier@Retention(RetentionPolicy.RUNTIME)public @interface QualifierA {}@Qualifier@Retention(RetentionPolicy.RUNTIME)public @interface QualifierB {} 3. 通过@Scope和@Singleton实现局部或全局单例 @Scope 12345// 局部单例元注解@Scope@Retention(RetentionPolicy.RUNTIME)public @interface CarScope {} @Binds 主要作用就是确定接口与具体的具体实现类，这样说得比较抽象，我们还是看看例子吧。在DishesFragment中有这么一句代码： Dagger2 错误提示1错误: [Dagger/MissingBinding] com.markzl.android.githubclient.ui.welcome.WelcomeViewModel cannot be provided without an @Inject constructor or an @Provides-annotated method. 提示缺少部分注入数据，如 ViewModel 是通过 ViewModelFactory 创建返回，如果ViewModelFactory没有被注入数据，那么控制台会打印上述错误信息。","link":"/2019/04/23/Android面试/Dagger2使用详解/"},{"title":"Gradle 配置常见问题","text":"常见gradle配置记录，如输出应用包名，相关debug和release版本信息分开配置等，对于gradle中常见问题如版本重复依赖版本冲突等问题的处理记录。 输出包名配置 12345678910111213141516171819202122232425static def releaseTime() { return new Date().format(\"yyyyMMdd_hhmm\")}android{ ... //修改apk包名 android.applicationVariants.all { variant -&gt; variant.outputs.all { if (outputFileName != null &amp;&amp; outputFileName.endsWith(\".apk\")) { def endStr = outputFileName if (outputFileName.contains(\"debug\")) { endStr = \"debug.apk\" } if (outputFileName.contains(\"release\")) { endStr = \"release.apk\" } outputFileName = \"app\" + \"_${releaseTime()}_${defaultConfig.versionName}_${defaultConfig.versionCode}_\" + endStr } } } ...} 对于项目中出现重复依赖且版本冲突处理方式 参考资料链接 对于出现项目依赖 Rxjava 3.x 版本，而同时使用 RxAndroid 2.x 版本（RxAndroid 2.x 版本内部依赖 Rxjava 2.x 版本）出现的 Rxjava 版本冲突最终处理如下：统一项目使用的 Rxjava 版本。 全局替换重复依赖 123456configurations.all { resolutionStrategy.dependencySubstitution { // Substitute one module dependency for another substitute module(\"io.reactivex.rxjava2:rxjava:2.2.0\") with module(\"io.reactivex.rxjava3:rxjava:3.0.0-RC0\") }} 全局排除重复依赖 1234567891011121314151617181920configurations { compile.exclude group: 'io.reactivex.rxjava2', module: 'rxjava' all { resolutionStrategy { eachDependency { details -&gt; if (details.requested.group == 'io.reactivex.rxjava3' &amp;&amp; details.requested.name == 'rxjava') { details.useVersion '3.0.0-RC0' details.because 'Unified the version of RxJava3.' } } } }}dependencies { // ... implementation rootProject.ext.dependencies['rxjava3'] implementation rootProject.ext.dependencies['rxandroid']} 指定重复依赖项单独配置排除（不推荐）： 123implementation ('io.reactivex.rxjava2:rxandroid:2.1.0') { exclude group: 'io.reactivex.rxjava2', module: 'rxjava'} 替换本地与远程依赖（可以在开发 Library 时使用，方便切换本地库和在线库）： 123456configurations.all { resolutionStrategy.dependencySubstitution { substitute module(\"org.utils:api\") because \"we work with the unreleased development version\" with project(\":api\") substitute module(\"org.utils:util:2.5\") with project(\":util\") }} 通用配置1234567891011121314151617181920212223242526272829303132333435363738394041// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript { ext { // SDK and tools compileSdkVersion = 28 minSdkVersion = 21 targetSdkVersion = 28 // App dependencies appCompatVersion = '1.0.2' cardVersion = '1.0.0' materialVersion = '1.0.0' recyclerViewVersion = '1.0.0' androidXAnnotations = '1.0.1' timberVersion = '4.7.1' } repositories { google() jcenter() } dependencies { classpath 'com.android.tools.build:gradle:3.5.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files }}allprojects { repositories { google() jcenter() }}task clean(type: Delete) { delete rootProject.buildDir} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149apply plugin: 'com.android.application'// app_icondef debugIcon = \"@mipmap/ic_launcher\"def betaIcon = \"@mipmap/ic_launcher\"def prodIcon = \"@mipmap/ic_launcher\"// Create a variable called keystorePropertiesFile, and initialize it to your// keystore.properties file, in the rootProject folder.def keystorePropertiesFile = rootProject.file(\"keystore.properties\")// 根目录文件def jksFile = rootProject.file(\"markzl.jks\")def keystoreProperties = new Properties()keystoreProperties.load(new FileInputStream(keystorePropertiesFile))android { compileSdkVersion rootProject.compileSdkVersion defaultConfig { applicationId \"com.markzl.android.gradlesetting\" minSdkVersion rootProject.minSdkVersion targetSdkVersion rootProject.targetSdkVersion versionCode 1 versionName \"1.0\" testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" } signingConfigs { release { storeFile jksFile storePassword keystoreProperties.getProperty(\"storePassword\") keyAlias keystoreProperties.getProperty(\"keyAlias\") keyPassword keystoreProperties.getProperty(\"keyPassword\") } } buildTypes { release { signingConfig signingConfigs.release buildConfigField(\"String\", \"URL_HOST\", \"\\\"正式环境地址\\\"\") minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } debug { buildConfigField(\"String\", \"URL_HOST\", \"\\\"测试环境地址\\\"\") } } flavorDimensions 'default' productFlavors { dev { dimension = 'default' applicationIdSuffix = '.dev' resValue(\"string\", \"app_title\", \"应用名_测试版\") resValue(\"string\", \"baidu_api_key\", \"测试版key\") manifestPlaceholders = [app_icon: debugIcon] } beta { dimension = 'default' applicationIdSuffix = '.beta' resValue(\"string\", \"app_title\", \"应用名_线上测试版\") resValue(\"string\", \"baidu_api_key\", \"线上测试版key\") manifestPlaceholders = [app_icon: betaIcon] } prod { dimension = 'default' resValue(\"string\", \"app_title\", \"应用名_线上测试版\") resValue(\"string\", \"baidu_api_key\", \"正式版key\") manifestPlaceholders = [app_icon: prodIcon] } } android.variantFilter { variant -&gt; def flavors = variant.getFlavors() if (!flavors.isEmpty()) { def flavorName = flavors.get(0).name def buildTypeName = variant.buildType.name def ignoreVariant = true switch (buildTypeName) { case \"release\": switch (flavorName) { case \"prod\": case \"beta\": ignoreVariant = false break } break case \"debug\": switch (flavorName) { case \"dev\": ignoreVariant = false break } break } variant.setIgnore(ignoreVariant) } } android.applicationVariants.all { variant -&gt; variant.outputs.all { output -&gt; def flavorName = variant.getFlavorName() def buildType = variant.buildType.getName() def versionCode = defaultConfig.versionCode outputFileName = \"应用名-${flavorName}-${buildType}.${versionCode}.apk\" } }}dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) // App dependencies implementation \"androidx.appcompat:appcompat:$appCompatVersion\" implementation 'androidx.constraintlayout:constraintlayout:1.1.3' implementation \"androidx.cardview:cardview:$cardVersion\" implementation \"com.google.android.material:material:$materialVersion\" implementation \"androidx.recyclerview:recyclerview:$recyclerViewVersion\" implementation \"androidx.annotation:annotation:$androidXAnnotations\" implementation \"com.jakewharton.timber:timber:$timberVersion\" // Architecture Components // Dependencies for local unit tests testImplementation 'junit:junit:4.12' androidTestImplementation 'androidx.test.ext:junit:1.1.1' androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'}/** * @return The most recent git tag to be used as version name for the app. */def getGitVersion() { def cmd = \"git describe --tag\" try { def proc = cmd.execute() return proc.text.trim() } catch (IOException e) { //Unable to find 'git' return \"please update version name manually\" }}def releaseTime() { return new Date().format(\"yyyyMMdd_hhmm\")}","link":"/2019/07/31/gradle配置笔记/Android Gradle配置/"}],"tags":[{"name":"混淆","slug":"混淆","link":"/tags/混淆/"},{"name":"Handler","slug":"Handler","link":"/tags/Handler/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Android开发艺术探索","slug":"Android开发艺术探索","link":"/tags/Android开发艺术探索/"},{"name":"adjustResize","slug":"adjustResize","link":"/tags/adjustResize/"},{"name":"adjustPan","slug":"adjustPan","link":"/tags/adjustPan/"},{"name":"软键盘遮挡","slug":"软键盘遮挡","link":"/tags/软键盘遮挡/"},{"name":"BroadcastReceiver","slug":"BroadcastReceiver","link":"/tags/BroadcastReceiver/"},{"name":"启动模式","slug":"启动模式","link":"/tags/启动模式/"},{"name":"生命周期","slug":"生命周期","link":"/tags/生命周期/"},{"name":"App Links","slug":"App-Links","link":"/tags/App-Links/"},{"name":"NIO","slug":"NIO","link":"/tags/NIO/"},{"name":"BIO","slug":"BIO","link":"/tags/BIO/"},{"name":"AIO","slug":"AIO","link":"/tags/AIO/"},{"name":"特征","slug":"特征","link":"/tags/特征/"},{"name":"接口","slug":"接口","link":"/tags/接口/"},{"name":"抽象","slug":"抽象","link":"/tags/抽象/"},{"name":"堆栈","slug":"堆栈","link":"/tags/堆栈/"},{"name":"基本类型","slug":"基本类型","link":"/tags/基本类型/"},{"name":"引用类型","slug":"引用类型","link":"/tags/引用类型/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"throw","slug":"throw","link":"/tags/throw/"},{"name":"throws","slug":"throws","link":"/tags/throws/"},{"name":"线程","slug":"线程","link":"/tags/线程/"},{"name":"内部类","slug":"内部类","link":"/tags/内部类/"},{"name":"闭包","slug":"闭包","link":"/tags/闭包/"},{"name":"操作系统","slug":"操作系统","link":"/tags/操作系统/"},{"name":"进程","slug":"进程","link":"/tags/进程/"},{"name":"jdk","slug":"jdk","link":"/tags/jdk/"},{"name":"jre","slug":"jre","link":"/tags/jre/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"List","slug":"List","link":"/tags/List/"},{"name":"Set","slug":"Set","link":"/tags/Set/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"Rxjava操作符","slug":"Rxjava操作符","link":"/tags/Rxjava操作符/"},{"name":"View","slug":"View","link":"/tags/View/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"}],"categories":[{"name":"Android开发笔记","slug":"Android开发笔记","link":"/categories/Android开发笔记/"},{"name":"Android面试","slug":"Android面试","link":"/categories/Android面试/"},{"name":"Android开发艺术探索笔记","slug":"Android开发艺术探索笔记","link":"/categories/Android开发艺术探索笔记/"},{"name":"java笔记","slug":"java笔记","link":"/categories/java笔记/"},{"name":"Rxjava笔记","slug":"Rxjava笔记","link":"/categories/Rxjava笔记/"},{"name":"gradle配置笔记","slug":"gradle配置笔记","link":"/categories/gradle配置笔记/"}]}