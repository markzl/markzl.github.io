{"pages":[{"title":"about","text":"这是关于的页面，可以在这里向世界介绍你！","link":"/about/index.html"},{"title":"photos","text":"","link":"/photos/index.html"}],"posts":[{"title":"Android软键盘遮挡输入文本框问题","text":"在开发过程中，经常遇到在某个界面有多个文本框时，点击输入会出现软件盘遮挡输入框的情况，或者是类似在登录或注册页面可以输入信息，但是键盘遮挡登录注册按钮的问题，还有遮挡住输入框下面的输入框，用户必须手动收起键盘才可以继续输入的情况。本篇文章介绍如何处理这些问题，首先我们来介绍一下adjustSize和adjustPan属性。 在搜索相关软件盘遮挡问题时，大部分文章都是推荐我们在AndroidManifest文件中的Activity标签中添加 “android:windowSoftInputMode=”adjustResize” 或者是 “android:windowSoftInputMode=”adjustPan”属性，这里我们先来介绍一下 adjustResize 和 adjustPan。官网的描述如下： 值 描述 adjustResize 始终调整Activity主窗口的尺寸，以为屏幕上的软键盘腾出空间 adjustPan 不通过调整Activity主窗口的尺寸为软键盘腾出空间。相反窗口的内容会自动平移，使键盘永远无法覆盖当前焦点，以便用户始终看到自己输入的内容。这通常不如调整窗口尺寸可取，因为用户可能需关闭软键盘才能进入被遮盖的窗口部分，并与之交互。 当设置属性”android:windowSoftInputMode=”adjustResize”时，多文本输入框且根布局为LinearLayout没有使用ScrollView包裹时，点击文本输入7时，主窗口尺寸被调整压缩如下所示： 在设置布局文件根布局为ScrollView时，如下所示： 可以看到当我们设置属性为”android:windowSoftInputMode=”adjustResize”且根布局为ScrollView时，调整窗口尺寸是通过平移ScrollView中的内容来实现的，注意这里的文本标题并没有平移。且ScrollView中的文本内容我们可以滚动到最底部，不会被软键盘遮挡。 当我们设置Activity属性为”android:windowSoftInputMode=”adjustPan”且根布局为LinearLayout时，点击文本输入8可以看到整个窗口包括标题向上平移如下所示： 当我们设置activity属性为adjustPan且根布局为ScrollView，这时候发现当我们点击文本输入8后滑动视图时，始终有部分文本输入框被软键盘遮挡，必须用户手动隐藏软键盘，才可以选择下面的文本输入。如下图所示： 文本输入12下面的文本输入框被键盘遮挡无法滑动。","link":"/2018/10/29/Android软键盘遮挡输入文本框问题/"},{"title":"Java面试知识点","text":"continue、break和return区别 continue：仅推出本次循环，剩下循环和方法继续执行。 break：终止循环，但是继续执行方法 return：终止循环和方法。","link":"/2018/10/25/Java面试知识点/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2016/10/16/hello-world/"},{"title":"Android okhttp使用详解","text":"Get 请求1234567Request request = new Request.Builder() .url(url) .build();OkHttpClient client = new OkHttpClient();try (Response response = client.newCall(request).execute()) { return response.body().string();} 通过Request构建请求体，然后由 client 执行。这里 Request 默认请求类型是Get。注意这个是SynchronousGet是同步执行的。在Android UI线程直接运行会报错提示：==android.os.NetworkOnMainThreadException==。 异步Get请求 AsynchronousGet1234567891011121314Request request = new Request.Builder() .url(\"http://publicobject.com/helloworld.txt\") .build();client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { e.printStackTrace(); } @Override public void onResponse(Call call, Response response) throws IOException { try (ResponseBody responseBody = response.body()) { System.out.println(responseBody.string()); } }}); 异步请求会在Android 中开启一个线程队列，在子线程中运行，不影响Android UI 线程。注意的是Callback类回调仍然执行在子线程中，需要通过handler处理UI线程相关操作。 Post 请求注意下述代码中演示的同步请求，通过client.newCall(request).enqueue(Callback)可以进行异步请求 Post 提交 json 请求体123456789101112MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");RequestBody body = RequestBody.create(JSON, json);OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(url) .post(body) .build();try (Response response = client.newCall(request).execute()) { return response.body().string();} 根据string类型的json字符串请求请求体，通过post(ReqeustBody)方法请求数据。 Post 提交 String 请求体注意创建的MediaType类型，MediaType类型根据自己需求创建。这里定义为markdown类型： 12345678910111213MediaType MEDIA_TYPE_MARKDOWN = MediaType.get(\"text/x-markdown; charset=utf-8\");OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(\"https://api.github.com/markdown/raw\") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)) .build();try (Response response = client.newCall(request).execute()) { if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string());} Post 提交Form表单（FormBody）12345678910111213RequestBody formBody = new FormBody.Builder() .add(\"md5\", \"12232\") .build();Request request = new Request.Builder() .url(\"http://221.130.29.94:8090/bookQr/test/isUpload\") .post(formBody) .build();try (Response response = client.newCall(request).execute()) { if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string());} Post 提交File文件12345678910111213MediaType MEDIA_TYPE_MARKDOWN= MediaType.get(\"text/x-markdown; charset=utf-8\");OkHttpClient client = new OkHttpClient();File file = new File(\"README.md\");Request request = new Request.Builder() .url(\"https://api.github.com/markdown/raw\") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)) .build();try (Response response = client.newCall(request).execute()) { if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string());} Post 提交多种类型文件（MultiPartBody）123456789101112131415161718MediaType MEDIA_TYPE_PNG = MediaType.get(\"image/png\");RequestBody requestBody = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(\"title\", \"Square Logo\") .addFormDataPart(\"image\", \"logo-square.png\", RequestBody.create(MEDIA_TYPE_PNG, new File(filePath))) .build();OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(\"https://api.imgur.com/3/image\") .post(requestBody) .build();try (Response response = client.newCall(request).execute()) { if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string());} ##访问请求头内容（Acessing Header） 1234567891011121314Request request = new Request.Builder() .url(\"https://api.github.com/repos/square/okhttp/issues\") .header(\"User-Agent\", \"OkHttp Headers.java\") .addHeader(\"Accept\", \"application/json; q=0.5\") .addHeader(\"Accept\", \"application/vnd.github.v3+json\") .build();OkHttpClient client = new OkHttpClient();try (Response response = client.newCall(request).execute()) { if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(\"Server: \" + response.header(\"Server\")); System.out.println(\"Date: \" + response.header(\"Date\")); System.out.println(\"Vary: \" + response.headers(\"Vary\"));} Request.Builder#header()和Request.Builder#addHeader()区别，header()方法添加的key只有一个，多次添加改变value值，addHeader() 会为当前key再添加一个值。对于Response#header()和Response#headers()区别：header()方法会打印对于key出现的最后一次值，而headers()会将对应key的所有值列出来。 okhttp拦截器 - Interceptor##添加应用拦截器 123OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(new LoggingInterceptor()) .build(); 如何实现自定义拦截器，我们需要实现系统提供的 Interceptor 接口： 1234567891011121314private static class LoggingInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { long t1 = System.nanoTime(); Request request = chain.request(); logger.info(String.format(\"Sending request %s on %s%n%s\", request.url(), chain.connection(), request.headers())); Response response = chain.proceed(request); long t2 = System.nanoTime(); logger.info(String.format(\"Received response for %s in %.1fms%n%s\", request.url(), (t2 - t1) / 1e6d, response.headers())); return response; }} 当我们发起网络请求，打印日志如下,request#headers()值为空： 123456789101112Sending request http://www.publicobject.com/helloworld.txt on nullUser-Agent: OkHttp SampleReceived response for http://www.publicobject.com/helloworld.txt in 2957.8msServer: nginx/1.10.0 (Ubuntu)Date: Mon, 01 Jul 2019 02:52:58 GMTContent-Type: text/plainContent-Length: 1759Last-Modified: Tue, 27 May 2014 02:35:47 GMTConnection: keep-aliveETag: \"5383fa03-6df\"Accept-Ranges: bytes ##添加网络拦截器 添加网络拦截器如下所示： 123OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new LoggingInterceptor()) .build(); 打印日志信息： 1234567891011121314151617181920212223242526272829Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=www.publicobject.com/54.187.32.157:80 cipherSuite=none protocol=http/1.1}User-Agent: OkHttp SampleHost: www.publicobject.comConnection: Keep-AliveAccept-Encoding: gzipReceived response for http://www.publicobject.com/helloworld.txt in 271.5msServer: nginx/1.10.0 (Ubuntu)Date: Mon, 01 Jul 2019 02:54:12 GMTContent-Type: text/htmlContent-Length: 194Connection: keep-aliveLocation: https://publicobject.com/helloworld.txtSending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=publicobject.com/54.187.32.157:443 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 protocol=http/1.1}User-Agent: OkHttp SampleHost: publicobject.comConnection: Keep-AliveAccept-Encoding: gzipReceived response for https://publicobject.com/helloworld.txt in 176.9msServer: nginx/1.10.0 (Ubuntu)Date: Mon, 01 Jul 2019 02:54:13 GMTContent-Type: text/plainContent-Length: 1759Last-Modified: Tue, 27 May 2014 02:35:47 GMTConnection: keep-aliveETag: \"5383fa03-6df\"Accept-Ranges: bytes 网络拦截器打印了两次日志信息，第一个地址是http://www.publicobject.com/helloworld.txt,第二个地址是https://publicobject.com/helloworld.txt。 Application interceptors（应用拦截器） 不必担心中间的responses，例如重定向和重连。 总是调用一次，即使是从缓存HTTP响应。 观察应用程序的原始意图。不关心OkHttp的注入headers，例如If-None-Match 允许短路和不执行Chain.proceed(). 允许重连，多次调用proceed()。 Network Interceptors （网络拦截器） 能够操作中间反应，例如重定向和重连。 不能被缓存响应，例如短路网络调用（short-circuit the network）。 观察数据，正如它将在网络上传输。 访问携带request的Connection 注意在进行okhttp请求获取下载进度，根据Callback返回 缓存响应数据（Reponse Caching） To cache responses, you’ll need a cache directory that you can read and write to, and a limit on the cache’s size. The cache directory should be private, and untrusted applications should not be able to read its contents! 我们需要限制缓存的大小，并且缓存数据的目录不可以被其他应用读取。 Response caching uses HTTP headers for all configuration. You can add request headers like Cache-Control: max-stale=3600 and OkHttp’s cache will honor them. Your webserver configures how long responses are cached with its own response headers, like Cache-Control: max-age=9600. There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET. 我们可以手动为request请求添加请求头”Cache-Control: max-stale=3600”，设置缓存时间。或者由服务器决定我们的缓存时间。max-stale是发起请求方设置的缓存时间，只对请求端有效。max-age为设置相应数据的缓存有效期时间，在没有超过max-age的情况下，会自动从缓存中读数据；在超出max-age的情况会向服务端发送新的请求，如果请求失败会返回缓存的数据。如果max-age有效期过了，请求端设置了max-stale，仍然可以从缓存中读取，不需要去服务器请求新的内容。因此max-age和max-stale在请求中同时使用的情况下，缓存的时间为max-age和max-stale的和，超出max-age值会提示Warning: 110 HttpURLConnection &quot;Response is stale。max-age和max-stale详解 12345678910111213141516171819202122232425262728293031int cacheSize = 10 * 1024 * 1024; // 10 MiBCache cache = new Cache(cacheDirectory, cacheSize);OkHttpClient client = new OkHttpClient.Builder() .cache(cache) .build();Request request = new Request.Builder() .url(\"http://publicobject.com/helloworld.txt\") .build();String response1Body;try (Response response1 = client.newCall(request).execute()) { if (!response1.isSuccessful()) throw new IOException(\"Unexpected code \" + response1); response1Body = response1.body().string(); System.out.println(\"Response 1 response: \" + response1); System.out.println(\"Response 1 cache response: \" + response1.cacheResponse()); System.out.println(\"Response 1 network response: \" + response1.networkResponse());}String response2Body;try (Response response2 = client.newCall(request).execute()) { if (!response2.isSuccessful()) throw new IOException(\"Unexpected code \" + response2); response2Body = response2.body().string(); System.out.println(\"Response 2 response: \" + response2); System.out.println(\"Response 2 cache response: \" + response2.cacheResponse()); System.out.println(\"Response 2 network response: \" + response2.networkResponse());}System.out.println(\"Response 2 equals Response 1? \" + response1Body.equals(response2Body)); response2的数据将从缓存中获取，日志信息如下： 1234567Response 1 response: Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}Response 1 cache response: Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}Response 1 network response: Response{protocol=http/1.1, code=304, message=Not Modified, url=https://publicobject.com/helloworld.txt}Response 2 response: Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}Response 2 cache response: Response{protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt}Response 2 network response: nullResponse 2 equals Response 1? true","link":"/2018/06/22/Android开发笔记/Android okhttp使用详解/"},{"title":"Android的Handler消息机制分析","text":"Handler的介绍中出现最多的关键字，Looper，ThreadLocal，MessageQueue。 在工作线程的handler#sendMessage方法实际上是向主线程即UI线程的线程存储空间（ThreadLocal）或消息队列插入消息，通过Looper循环查询消息队列的新消息。 ThreadLocal1ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;&gt;(); 在ActivityThread中调用 Looper.prepare方法，创建当前线程的Looper对象和MessageQueue队列，并通过sThreadLocal.set()方法保存当前队列。在Looper#loop方法中循环遍历消息队列","link":"/2018/10/22/Android开发笔记/Android的Handler消息机制分析/"},{"title":"Android使用RenderScript处理图片","text":"RenderScript是Android平台上简单快速处理图片效果的脚本工具，Renderscript``基于C99（Ed. C 语言）。使用前需要在Module下build.gradle文件中添加两行代码： 12345defaultConfig { //略... renderscriptTargetApi 24 renderscriptSupportModeEnabled true} renderscriptTargetApi - Specifies the bytecode version to be generated. We recommend you set this value to the lowest API level able to provide all the functionality you are using and set renderscriptSupportModeEnabled to true. Valid values for this setting are any integer value from 11 to the most recently released API level. If your minimum SDK version specified in your application manifest is set to a different value, that value is ignored and the target value in the build file is used to set the minimum SDK version. renderscriptTargetApi- 指定要生成的字节码版本。建议将此值设置为能够提供您正在使用的所有功能的最低API级别，并将renderscriptSupportModeEnabled设置为true。此设置的有效值是从11到最近发布的API级别的任何整数值。如果应用程序清单中指定的最低SDK版本设置为其他值，则忽略该值，并使用构建中的目标值设置最低SDK版本。 renderscriptSupportModeEnabled - Specifies that the generated bytecode should fall back to a compatible version if the device it is running on does not support the target version. renderscriptSupportModeEnabled - 指定生成的字节码如果运行的设备不支持目标版本，则应回退到兼容版本。 Renderscript将使用C写的脚本并行计算图片的每一个像素。一个脚本就是一个扩展名为'.rs'的文件，必须置于app/src/main/rs。Android Studio 并不会为你生成这个目录或者任何脚本。 ##使用ScriptInstrinsicBlur模糊图片 模糊图片，系统为我们提供了ScriptInstrinsicBlur工具类，不需要使用rs脚本渲染 ： 12345678910111213141516171819202122232425262728293031323334 public static Bitmap blurBitmap(Bitmap bitmap, float radius, Context context) { //Create renderscript RenderScript rs = RenderScript.create(context); //Create allocation from Bitmap Allocation allocation = Allocation.createFromBitmap(rs, bitmap); Type t = allocation.getType(); //Create allocation with the same type Allocation blurredAllocation = Allocation.createTyped(rs, t); //Create script ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); //Set blur radius （maximum 25.0） blurScript.setRadius(radius); //Set input for script blurScript.setInput(allocation); //Call script for output allocation blurScript.forEach(blurredAllocation); //Copy script result into bitmap blurredAllocation.copyTo(bitmap); //Destroy everything to free memory allocation.destroy(); blurredAllocation.destroy(); blurScript.destroy(); t.destroy(); rs.destroy(); return bitmap;} Renderscript.jar包中提供了简单的图片渲染工具类，例ScriptIntrinsicBlur，ScriptIntrinsicConvolve5x5，ScriptIntrinsicColorMatrix等。同时可以自定是rs文件，项目编译后会生成对应脚本类。例rs文件夹下有名为hist_Eq.rs文件，编译后会生成对应的ScriptC_histEq类。 直方图均衡化 ​ Y 分量上的Histogram Equalization (前后对比) Y的直方图均衡化算法很简单： 把RGB颜色空间转换成YUV颜色空间。 计算Y分量的直方图。 根据直方图重新映射Y分量。 重新把YUV转换回RGB颜色空间。 我们现在可以开始创建我们的rs文件了：histEq.rs，位于rs目录。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#pragma version(1)#pragma rs_fp_relaxed#pragma rs java_package_name(com.example.q.renderscriptexample) #include \"rs_debug.rsh\" int32_t histo[256];float remapArray[256];int size; //Method to keep the result between 0 and 1static float bound (float val) { float m = fmax(0.0f, val); return fmin(1.0f, m);} uchar4 __attribute__((kernel)) root(uchar4 in, uint32_t x, uint32_t y) { //Convert input uchar4 to float4 float4 f4 = rsUnpackColor8888(in); //Get YUV channels values float Y = 0.299f * f4.r + 0.587f * f4.g + 0.114f * f4.b; float U = ((0.492f * (f4.b - Y))+1)/2; float V = ((0.877f * (f4.r - Y))+1)/2; //Get Y value between 0 and 255 (included) int32_t val = Y * 255; //Increment histogram for that value rsAtomicInc(&amp;histo[val]); //Put the values in the output uchar4, note that we keep the alpha value return rsPackColorTo8888(Y, U, V, f4.a);} uchar4 __attribute__((kernel)) remaptoRGB(uchar4 in, uint32_t x, uint32_t y) { //Convert input uchar4 to float4 float4 f4 = rsUnpackColor8888(in); //Get Y value float Y = f4.r; //Get Y value between 0 and 255 (included) int32_t val = Y * 255; //Get Y new value in the map array Y = remapArray[val]; //Get value for U and V channel (back to their original values) float U = (2*f4.g)-1; float V = (2*f4.b)-1; //Compute values for red, green and blue channels float red = bound(Y + 1.14f * V); float green = bound(Y - 0.395f * U - 0.581f * V); float blue = bound(Y + 2.033f * U); //Put the values in the output uchar4 return rsPackColorTo8888(red, green, blue, f4.a);} void init() { //init the array with zeros for (int i = 0; i &lt; 256; i++) { histo[i] = 0; remapArray[i] = 0.0f; }} void createRemapArray() { //create map for y float sum = 0; for (int i = 0; i &lt; 256; i++) { sum += histo[i]; remapArray[i] = sum / (size); }} 这里有几个方法： bound(float val): 这个方法用于让结果保持在0到1之间。 root(): 这个方法是为input Allocation的每一个像素而调用（被叫做一个kernel）。它把像素从RGBA转换成YUVA，它把结果放在 output allocation。它还增加了Y直方图的值。 remaptoRGB(): 这个方法也是一个kernel。它重新映射Y值然后从YUVA转换回RGBA。 init(): 当在java中创建脚本的时候，这个方法自动被调用。它用0初始化数组。 createRemapArray(): 它为Y分量创建remap数组。 你可以像以往在c中那样创建方法。但是这里如果你需要像我在bound()中那样返回什么东西，这个方法必须是静态的。 12345678910111213141516171819202122232425262728293031323334353637383940414243public static Bitmap histogramEqualization(Bitmap image, Context context) { //Get image size int width = image.getWidth(); int height = image.getHeight(); //Create new bitmap Bitmap res = image.copy(image.getConfig(), true); //Create renderscript RenderScript rs = RenderScript.create(context); //Create allocation from Bitmap Allocation allocationA = Allocation.createFromBitmap(rs, res); //Create allocation with same type Allocation allocationB = Allocation.createTyped(rs, allocationA.getType()); //Create script from rs file. ScriptC_histEq histEqScript = new ScriptC_histEq(rs); //Set size in script histEqScript.set_size(width*height); //Call the first kernel. histEqScript.forEach_root(allocationA, allocationB); //Call the rs method to compute the remap array histEqScript.invoke_createRemapArray(); //Call the second kernel histEqScript.forEach_remaptoRGB(allocationB, allocationA); //Copy script result into bitmap allocationA.copyTo(res); //Destroy everything to free memory allocationA.destroy(); allocationB.destroy(); histEqScript.destroy(); rs.destroy(); return res;} 参考文章： RenderScript :简单而快速的图像处理 RenderScript Overview | Android Developers","link":"/2019/05/06/Android开发笔记/Android使用RenderScript处理图片/"},{"title":"Android中的IPC之Binder机制","text":"Android中的IPC机制即跨进程通信技术（Inter-Process-Comunicate），主要技术是 Android 的序列化机制和Binder。 Android 跨进程通信常见的几种方式；Bundle、文件共享、AIDL、Messenger、ContentProVider和Socket等。其中AIDL、Messenger、ContentProvider底层属于基于 Android Binder 机制实现的。 Android 多进程模式关于开启多进程模式注意，android:process=&quot;:remote&quot; 与android:precess=&quot;com.xxx.xxx.remote&quot;指定Android 多进程方式的区别，进程名以”:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一进程，而进程名不以”:”开头的进程属于全局进程，其他应用通过 ShareUID 方式（签名也需相同）可以和它跑在同一个进程中。Android系统为每个应用分配一个唯一的 UUID，具有相同的 UUID 的应用才能共享数据。 多进程模式下会造成如下几方面的问题： 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPrefence 的可靠性下降（SharedPrefence 本质上是读写 xml 文件进行存储，并发操作会导致混乱） Application 多次创建 运行在同一个进程中的组件是属于同一个虚拟机和同一个 Application 的，同理，运行在不同进程中的组件是属于两个不同的虚拟机和 Application 的。 IPC基础概念介绍IPC基本概念主要包含三方面内容：Serializable 和Parcelable 接口以及 Binder。Serializable 和Parcelable 接口可以完成对象的序列化过程。通过序列化保证对象的持久化，可以使用 Intent 、Bundle 以及网络传递对象。 Serializable序列化Serializable 实现序列化的过程主要通过下面的表示实现: 1private static final long serialVersionUID = 8711368828010083044L 序列化标识并不是必须的，系统会自动生成这个标识，但是当实现 Serializable 序列化接口的对象实体类结构发生变化，序列化标识也会重新赋值，这将对与反序列化过程有影响。 12345678910//序列化过程User user = new User(\"0\",\"jake\",true);ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"cache.txt\"));out.writeObject(user);out.close();//反序列化过程ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"cache.txt\"));User newUser = (User)int.readObject();in.close(); 需要注意的是 user 和 newUser 的内容相同，但不是同一个对象。关于 serialVersionUID 这个标识，只有序列化之前的对象的 serialVersionUID 值和序列化之后 serialVersionUID 值一致，才可以正常反序列化。实体类中成员数量和类型发生变化， serialVersionUID 值都会改变。一般来说我们手动指定 serialVersionUID 值，这样反序列化过程不会受到影响。如果不手动指定 serialVersionUID ，反序列化是当前类有所改变，比如增加或者删除了某些成员变量，那么系统就会重新计算当前类结的 hash 值并把它赋值给 serialVersionUID，这个时候当前类的serialVersionUID 就和序列化后的数据中的 serialVersionUID 不一致，于是反序列化失败。当我们手动指定了它以后，就可以很大程度上避免反序列化过程的失败，比如删除了某些成员变量或者增加了某些成员变量，数据仍然可以正常反序列化。不过如果类结构发生非常规性改变，比如修改类名，变量类型或者名称，即便指定了serialVersionUID，依然会反序列化失败。 Parcelable序列化Parcelable 是 Android 平台上提供的序列化方案，相对于 Serialable 大量的 IO 操作，拥有更好的性能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Book implements Parcelable { private int bookId; private String bookName; public Book() {} public Book(int bookId, String bookName) { this.bookId = bookId; this.bookName = bookName; } public int getBookId() { return bookId; } public void setBookId(int bookId) { this.bookId = bookId; } public String getBookName() { return bookName; } public void setBookName(String bookName) { this.bookName = bookName; } protected Book(Parcel in) { bookId = in.readInt(); bookName = in.readString(); } //当设置参数标签为out和inout时会要求重写这个方法 public void readFromParcel(Parcel in) { bookId = in.readInt(); bookName = in.readString(); } public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() { @Override public Book createFromParcel(Parcel in) { return new Book(in); } @Override public Book[] newArray(int size) { return new Book[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(bookId); dest.writeString(bookName); }} Android进程通信之Binder机制Messenger-进程间通信的信使Messenger 根据 Handler 生成实例构造方法： 123456789101112131415161718192021222324//Messenger.java/** * Create a new Messenger pointing to the given Handler. Any Message * objects sent through this Messenger will appear in the Handler as if * {@link Handler#sendMessage(Message) Handler.sendMessage(Message)} had * been called directly. * * @param target The Handler that will receive sent messages. */public Messenger(Handler target) { mTarget = target.getIMessenger();}/** * Send a Message to this Messenger's Handler. * * @param message The Message to send. Usually retrieved through * {@link Message#obtain() Message.obtain()}. * * @throws RemoteException Throws DeadObjectException if the target * Handler no longer exists. */public void send(Message message) throws RemoteException { mTarget.send(message);} 通过 Handler 对象创建 Messenger，通过 Messenger#send(Message) 方法就可以跨进程传递信息。 12345678910111213141516171819202122232425//MainActivity.java private Messenger client = new Messenger(new MessengerHandler());private ServiceConnection serviceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { MainActivity.this.service = new Messenger(service); Message msg = Message.obtain(null, Contanstants.MSG_FROM_CLIENT); Bundle bundle = new Bundle(); bundle.putString(\"msg\", \"hello, this is client\"); msg.setData(bundle); //指定回复信使 msg.replyTo = client; try { MainActivity.this.service.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { }}; MainActivity 通过调用bindservice() 方法，获取IBinder 对象。看一下 Messenger 关于 IBinder 参数的构造方法： 123456789/** * Create a Messenger from a raw IBinder, which had previously been * retrieved with {@link #getBinder}. * * @param target The IBinder this Messenger should communicate with. */public Messenger(IBinder target) { mTarget = IMessenger.Stub.asInterface(target);} 上面是 clien 端向 service 端发送信息，再看一下关于 service 端处理 client 端的数据，并回复 client 端。上述代码我们在 Message 传递信息中指定了回复信使，看一下 service 端代码： 1234567891011121314151617181920212223242526272829//MessengerService.javaprivate Messenger mMessenger = new Messenger(new MessengerHandler());private static class MessengerHandler extends Handler { @Override public void handleMessage(Message msg) { if (msg.what == Contanstants.MSG_FROM_CLIENT) { Bundle bundle = msg.getData(); Log.d(TAG, bundle.getString(\"msg\")); Messenger clientMessenger = msg.replyTo; Message replyMsg = Message.obtain(null, Contanstants.MSG_FROM_SERVER); bundle.putString(\"msg\", \"this is server\"); replyMsg.setData(bundle); try { clientMessenger.send(replyMsg); } catch (RemoteException e) { e.printStackTrace(); } } else { super.handleMessage(msg); } }}@Nullable@Overridepublic IBinder onBind(Intent intent) { return mMessenger.getBinder();}} AIDL（android interface define launage）关于基于 Binder 机制的 AIDL 以及 Messenger 概述：AIDL 文件在编译过程中会在 build 文件中生成对应的java文件，所以我们也可以通过写java文件来实现进程间通信。这里简单介绍一样 AIDL 文件对应java文件的结构以便于理解后续的概念： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public interface IBookManager extends android.os.IInterface { //... public static abstract class Stub extends android.os.Binder implements com.markzl.android.androidipc.entity.IBookManager { private static final java.lang.String DESCRIPTOR = \"com.markzl.android.androidipc.entity.IBookManager\"; /** * Construct the stub at attach it to the interface. */ public Stub() { this.attachInterface(this, DESCRIPTOR); } /** * Cast an IBinder object into an com.markzl.android.androidipc.entity.IBookManager interface, * generating a proxy if needed. * client端会调用该方法根据service端传回的IBinder对象生成IBookManager对象 */ public static com.markzl.android.androidipc.entity.IBookManager asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.markzl.android.androidipc.entity.IBookManager))) { return ((com.markzl.android.androidipc.entity.IBookManager) iin); } return new com.markzl.android.androidipc.entity.IBookManager.Stub.Proxy(obj); } /** * service端会将当前的binder通过@link{Service#OnBinder(Intent intent)}传递给client */ @Override public android.os.IBinder asBinder() { return this; } //... private static class Proxy implements com.markzl.android.androidipc.entity.IBookManager { //... } } public void addBookIn(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookInOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException;} 可以看到 client 端调用的IBookManager.Stub#asInterface()方法中，会先通过 binder 对象查询当前进程中的IBookManager 对象是否存在，不存在就走 Proxy 代理类。关于 Proxy 中如何处理跨进程通信，下面会结合AIDL定向标签来介绍。 关于 AIDL 中定向标签 in，out，inout通过分析定向标签，我们同样可以学习到 AIDL 的基本原理。 12345678910// IBookManager.aidlpackage com.markzl.android.androidipc.entity;import com.markzl.android.androidipc.entity.Book;import com.markzl.android.androidipc.IOnNewBookAddedListener;interface IBookManager { void addBookIn(in Book book); void addBookOut(out Book book); void addBookInOut(inout Book book);} 生成的 java 文件： 123456789101112131415161718192021222324252627282930313233343536public interface IBookManager extends android.os.IInterface { //... public static abstract class Stub extends android.os.Binder implements com.markzl.android.androidipc.entity.IBookManager { //... @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { java.lang.String descriptor = DESCRIPTOR; switch (code) { //根据方法对应的code码处理相应数据 //... case TRANSACTION_addBookIn: //... break; case TRANSACTION_addBookOut: //... break; case TRANSACTION_addBookInOut: //... break; } } private static class Proxy implements com.markzl.android.androidipc.entity.IBookManager { //... static final int TRANSACTION_addBookIn = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBookOut = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); static final int TRANSACTION_addBookInOut = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2); } } public void addBookIn(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException; public void addBookInOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException;} in 标签in 标签 client 端向 service 端写入数据，我们看一下生成的对应的 IBookManager.java 文件，其中用于跨进程处理数据的 IBookManager.Stub 内部私有 Proxy 类： 123456789101112131415161718192021222324252627282930313233//IBookManager.java private static class Proxy implements com.markzl.android.androidipc.entity.IBookManager { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } @Override public void addBookIn(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_addBookIn, _data, _reply, 0); _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } }} 可以看到 Proxy 中类将我们传入的实体序列化后，交给 mRemote#transact 方法处理，从 Proxy 类中可以看出，mRemote 是一个 IBinder 对象，在调用 Proxy 的构造方法时传入的是 Binder 的对象。 transact 方法是在IBinder 接口类中定义的，其实现类 Binder#transact 方法如下： 1234567891011121314151617/** * Default implementation rewinds the parcels and calls onTransact. On * the remote side, transact calls into the binder to do the IPC. */public final boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException { if (false) Log.v(\"Binder\", \"Transact: \" + code + \" to \" + this); if (data != null) { data.setDataPosition(0); } boolean r = onTransact(code, data, reply, flags); if (reply != null) { reply.setDataPosition(0); } return r;} 可以看到最终调用的方法是onTransact(code, data, reply, flags)，接下来我们看一下 onTransact 中方法如何处理序列化后的数据： 12345678910111213141516171819@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { //... switch (code) { //... case TRANSACTION_addBookIn: { data.enforceInterface(descriptor); com.markzl.android.androidipc.entity.Book _arg0; if ((0 != data.readInt())) { _arg0 = com.markzl.android.androidipc.entity.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.addBookIn(_arg0); reply.writeNoException(); return true; } }} onTransact() 方法中将序列化的数据重新反序列化成一个新的Book对象，然后调用service端的addBookIn()方法添加Book对象。注意这个过程是生成一个新的Book对象，具体为什么要注意生成新对象后面会讲到。这里总结一下in标签的作用向service传递数据但没有处理service的reply结果。 out标签同样首先看Proxy类中生成的addBookOut()方法： 12345678910111213141516@Overridepublic void addBookOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_addBookOut, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) { book.readFromParcel(_reply); } } finally { _reply.recycle(); _data.recycle(); }} 可以看到这里我们并没有处理 Book 对象，_data 始终没有写入 Book 对象，而且调用transact() 方法之后的_reply.readInt() 不等于0的时候，会重新从 _reply 中读取 book 实体。我们再来看一下调用的 onTransact() 方法中如何处理out标签： 1234567891011121314case TRANSACTION_addBookOut: { data.enforceInterface(descriptor); com.markzl.android.androidipc.entity.Book _arg0; _arg0 = new com.markzl.android.androidipc.entity.Book(); this.addBookOut(_arg0); reply.writeNoException(); if ((_arg0 != null)) { reply.writeInt(1); _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } return true;} out定向标签中是重新生成了一个新的 Book 对象，没有写入任何值。然后调用了addBook(Book book)方法，由此可知 service 并没有真正添加 client 传来的 Book 对象。 inout标签先看 Proxy#addBookInOut() ： 12345678910111213141516171819202122@Overridepublic void addBookInOut(com.markzl.android.androidipc.entity.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_addBookInOut, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) { book.readFromParcel(_reply); } } finally { _reply.recycle(); _data.recycle(); }} 在 _data 传入 book 序列化数据时和in标签同样的处理， _reply 的处理和 out 标签时保持一致。接着我们看一下 addBookInOut() 方法标签对应的 onTransact() 方法。 123456789101112131415161718case TRANSACTION_addBookInOut: { data.enforceInterface(descriptor); com.markzl.android.androidipc.entity.Book _arg0; if ((0 != data.readInt())) { _arg0 = com.markzl.android.androidipc.entity.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.addBookInOut(_arg0); reply.writeNoException(); if ((_arg0 != null)) { reply.writeInt(1); _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } return true;} 调用IBookManager#Stub实例对象通过 addBookInOut 方法添加由data反序列化后得到的Book对象。inout标签在某种意义上算得上是in和out标签的“并集”，目前并没有看出out和inout标签中的 _reply 值存在的意义。_reply在处理有返回值的方法使用如下: 1234567891011121314151617//Proxy#getBookList()@Overridepublic java.util.List&lt;com.markzl.android.androidipc.entity.Book&gt; getBookList() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.markzl.android.androidipc.entity.Book&gt; _result; try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.markzl.android.androidipc.entity.Book.CREATOR); } finally { _reply.recycle(); _data.recycle(); } return _result;} onTransact()中对于_reply赋值如下： 12345678//IBookManager.Stub#onTransact()case TRANSACTION_getBookList: { data.enforceInterface(descriptor); java.util.List&lt;com.markzl.android.androidipc.entity.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true;} 关于AIDL各种方法生成的详细内容都可以在build文件夹下生成对应java文件中看到。 service端数据改动时如何主动响应client端service数据有改动如何主动响应client端？这种情况类似View的setOnClickListener设置监听事件方法，当View被单击调用OnClickListener#onClick方法来做出相应处理，即事件回调。在之前的IBookManager添加如下接口： 123456//...interface IBookManager { //... void setOnBookAddedListener(OnBookAddedListener listener); void removeOnBookAddedListener(OnBookAddedListener listener);} 创建接口类OnBookAddedListener: 1234//OnBookAddedListener.aidlinterface OnBookAddedListener{ void onNewBookAdded();} 然后在service中实现如下： 12345678910111213141516171819202122232425262728public class BookService extends Service { private List&lt;Book&gt; mBookList = new ArrayList&lt;&gt;(); private List&lt;OnBookAddedListener&gt; mListenerList = new ArrayList&lt;&gt;(); IBookManager bookManager = new IBookManager.Stub() { //... @Override public void setOnBookAddedListener(OnBookAddedListener listener) throws RemoteException { mListenerList.add(listener); } @Override public void removeOnBookAddedListener(OnBookAddedListener listener) throws RemoteException { mListenerList.remove(listener); } }; @Nullable @Override public IBinder onBind(Intent intent) { //开启线程不断添加新书。然后遍历mListenerList， //调用OnBookAddedListener#onNewBookAdded()方法通知client端 new Thread(new AddBookWorker()).start(); return bookManager.asBinder(); } //...} 在client端与ServiceConnection#onServiceConnected()注册监听方法： 12345678910@Overridepublic void onServiceConnected(ComponentName name, IBinder service) { bookManager = IBookManager.Stub.asInterface(service); try { //listener中打印日志 bookManager.registerOnNewBookAddListener(listener); } catch (RemoteException e) { e.printStackTrace(); }} 在bindService()方法之后，当service端线程不断添加新书，我们可以正常打印新书添加日志信息，但是当我们调用removeOnBookAddedListener()方法时，打印日志信息并没有像我们期望的那样停止。这是因为client端进程中的OnBookAddedListener对象和service端的OnBookAddedListener对象不是同一个对象，正如我们在3.3.1末尾提到的一样。那么我们该如何在serice端和client操作同一个对象。这里系统为我们提供了RemoteCallbackList类，原理是通过键值对的形式保存OnBookAddedListener对象，使得我们添加和移除的是同一个对象。关于RemoteCallbackList的介绍： 12remoteCallbackList.register(listener);remoteCallbackList.unregister(listener); 其中RemoteCallbackList#register() 简单的概述如下（详情请阅读源码）: 1234IBinder binder = listener.asBinder();//...Callback cb = new Callback(listener, cookie);mCallbacks.put(binder, cb); 可以看出利用的是两个进程使用的是同一个Binder对象来作为key，通过client 端和service端相同key(binder)删除相应的listener。 关于Binder线程池的使用// 待续……","link":"/2019/06/16/Android开发笔记/AndroidIPC机制/"},{"title":"Gradle 配置常见问题","text":"常见gradle配置记录，如输出应用包名，相关debug和release版本信息分开配置等，对于gradle中常见问题如版本重复依赖版本冲突等问题的处理记录。 输出包名 12 对于项目中出现重复依赖且版本冲突处理方式 详情查看文章链接 对于出现项目依赖 Rxjava 3.x 版本，而同时使用 RxAndroid 2.x 版本（RxAndroid 2.x 版本内部依赖 Rxjava 2.x 版本）出现的 Rxjava 版本冲突最终处理如下：统一项目使用的 Rxjava 版本。 全局替换重复依赖 123456configurations.all { resolutionStrategy.dependencySubstitution { // Substitute one module dependency for another substitute module(\"io.reactivex.rxjava2:rxjava:2.2.0\") with module(\"io.reactivex.rxjava3:rxjava:3.0.0-RC0\") }} 全局排除重复依赖 1234567891011121314151617181920configurations { compile.exclude group: 'io.reactivex.rxjava2', module: 'rxjava' all { resolutionStrategy { eachDependency { details -&gt; if (details.requested.group == 'io.reactivex.rxjava3' &amp;&amp; details.requested.name == 'rxjava') { details.useVersion '3.0.0-RC0' details.because 'Unified the version of RxJava3.' } } } }}dependencies { // ... implementation rootProject.ext.dependencies['rxjava3'] implementation rootProject.ext.dependencies['rxandroid']} 指定重复依赖项单独配置排除（不推荐）： 123implementation ('io.reactivex.rxjava2:rxandroid:2.1.0') { exclude group: 'io.reactivex.rxjava2', module: 'rxjava'} 替换本地与远程依赖（可以在开发 Library 时使用，方便切换本地库和在线库）： 123456configurations.all { resolutionStrategy.dependencySubstitution { substitute module(\"org.utils:api\") because \"we work with the unreleased development version\" with project(\":api\") substitute module(\"org.utils:util:2.5\") with project(\":util\") }} 打包统一输出配置","link":"/2019/07/31/gradle配置笔记/Android Gradle配置/"},{"title":"Android设置全屏及沉浸式布局","text":"注意：下述代码根据 AppCompatActivity 及主题 parent=&quot;Theme.AppCompat.NoActionBar&quot; 和midSdk 21实现。 对于非刘海屏幕而言有两种方式设置全屏 代码中设定，需要写在 setContentView() 之前： 123456// 隐藏标题//requestWindowFeature(Window.FEATURE_NO_TITLE);// 设置全屏getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN)//或者是通过设置DecorView#setSystemUiVisibility(int) //getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN) 需要说明一点 requestWindowFeature() 方法是指定主题为 parent=&quot;android:Theme.Black&quot;之类的Activity 时隐藏老式 ActionBar 标题栏内容。对于继承 AppCompatActivity 这个方法无效。如果继承 AppCompatActivity 的 Activity 需要隐藏标题栏，可以通过以下方法： 123if(getSupportActionBar()!=null){ getSupportActionBar().hide();} 指定 Activity 的 Theme 主题 1android:theme=\"@style/FullScreenTheme\" 主题设置属性： 123456//styles.xml&lt;style name=\"FullScreenTheme\" parent=\"Theme.AppCompat.NoActionBar\"&gt; //这里指定的是Appcompat主题，这个属性可以去掉 &lt;!--&lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt;--&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;&lt;/style&gt; 上述两种方式都可以指定非刘海屏幕全屏显示。 关于刘海屏的全屏展示。测试机是华为8x刘海屏手机，发现设置全屏之后界面并没有延伸到刘海。刘海屏幕全屏适配分为两种情况：Android P 及Android P 一下： Android P 9.0系统提供了处理刘海屏的方法。设置全屏如下 1234567if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) { WindowManager.LayoutParams lp = getWindow().getAttributes(); // 始终允许窗口延伸到屏幕短边上的刘海区域 lp.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; getWindow().setAttributes(lp);}getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN| View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); Android P 中新增了窗口布局参数属性 layoutInDisplayCutoutMode，共有三种模式 LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT：仅当缺口区域完全包含在状态栏之中时，才允许窗口延伸到刘海区域显示 LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER：// 永远不允许窗口延伸到刘海区域 LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES：始终允许窗口延伸到屏幕短边上的刘海区域 通过设置 setSystemUiVisibility(int) 方法可以获取实现常见的全屏或者是沉浸式布局的效果: 控制SystemBar相关： SYSTEM_UI_FLAG_FULLSCREEN SYSTEM_UI_FLAG_HIDE_NAVIGATION SYSTEM_UI_FLAG_LOW_PROFILE 布局相关： SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION SYSTEM_UI_FLAG_LAYOUT_STABLE 沉浸式相关 (4.4 引入)： SYSTEM_UI_IMMERSIVE SYSTEM_UI_IMMERSIVE_STICKY 控制 SystemBar 相关SYSTEM_UI_FLAG_FULLSCREEN 该属性是用来隐藏状态栏的， SYSTEM_UI_HIDE_NAVIGATION 该属性是用来隐藏导航栏的 SYSTEM_UI_LOW_PROFILE 这个属性的能力是让SystemBar在视觉上变得模糊，重要性变得更低一点。具体表现是状态栏图标仅保留电量时间关键图标，并且变暗。导航栏图标变成三个点或者变暗。这个flag使用的很少。 布局相关 在新的Android4.1以及之后新的SystemUI设置里，仅单独设置隐藏状态栏和导航栏的flag会导致布局重绘，为了在显隐状态栏和导航栏的时候保持布局的稳定的显示效果，就需要以下属性了。 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 可以让布局延伸到状态栏的位置。在状态栏在隐藏和显示之前切换的时候，布局稳定的显示在状态栏后面（如果显示状态栏则布局在状态栏后面，隐藏状态栏布局也不变）。 SYSTEM_UI_FLAG_LAYOUT_STABLE 该flag的作用是保持布局稳定，避免在显隐状态栏导航栏的时候发生布局的变化。可以辅助以下SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN、SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION两个flag的使用，让应用保持全屏的情况下，布局不随状态栏导航栏显隐发生变化。也可以不配合这两个flag使用，也能达到保持布局稳定的效果，不过不能实现全屏，会留出状态栏和导航栏的位置。 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 可以让布局延伸到导航栏的位置。可以让导航栏在隐藏和显示之前切换的时候，布局稳定的显示在导航栏后面（如果显示导航栏则在导航栏后面，隐藏导航栏也不变）。 关于沉浸式界面在代码中指定。在 setContentView() 之前指定状态栏颜色透明即可,设置状态栏透明后，界面布局将延伸到状态栏。注意如果设置全屏，状态栏不再显示. 123456//设置沉浸式状态栏Window window = getWindow();//设置状态栏颜色window.setStatusBarColor(Color.TRANSPARENT);//设置布局延伸到状态栏window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); 对于状态栏白色的情况，在Android 6.0 sdk版本23 的情况，应如下设置： 12345678Window window = getWindow();if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { window.setStatusBarColor(Color.WHITE); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);}//关于小米魅族状态栏颜色设置暂不考虑 参考文章： Android沉浸式全屏讲解(状态栏、导航栏处理) Android刘海屏适配全方案（华为、小米、Vivo、Oppo)","link":"/2019/06/05/Android开发笔记/Android设置应用界面全屏/"},{"title":"Java内部类详解","text":"内部类的定义：一个定义在另一个类中的类，叫做内部类。内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性。然而必须要了解，内部类与组合是完全不同的概念，这一点很重要。在最初，内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。但是，你将会了解到，内部类远不止如此，它了解外部类，并能与之通信，而且你用内部类写出的代码更加更加优雅而清晰，尽管并不总是这样（而且Java8的Lambda表达式和方法引用减少了编写内部类的需求）。 成员内部类成员内部类是最普通的内部类，它的定义是位于另外一个类的内部，如下所示： 123456789101112class Outer{ private Inner inner = null; public Outer(){} class Inner{ public Inner(){ } }} 这里，类Outer被称为外部类，Inner就是我们通常称呼的成员内部类。成员内部类可以无条件访问外部类中的所有成员属性和成员方法（包括private成员和静态成员）。不过要注意的是当成员内部类出现和外部类相同名称的成员变量或方法时，默认使用的内部类中定义的成员变量或方法。如果要使用外部类中的属性和方法，可以通过以下方式访问： 12外部类.this.成员变量外部类.this.方法 在外部类中如果想要访问内部类中的成员变量或方法，必须创建一个成员内部类对象，再通过指向这个对象的引用来访问。 成员内部类是依靠外部类而存在的，所以说要想生成成员内部类的对象，必须先创建外部类对象。 1234567891011121314151617181920public class Main { public static void main(String[] args) { Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); }}class Outer{ private Inner inner = null; public Outer(){} class Inner{ public Inner(){ } }} 内部类可以拥有private访问权限、protext访问权限、public访问权限以及包访问权限。而外部类只能被public和包访问两种权限修饰。 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它与成员内部类的区别在于局部内部类的访问仅限于该方法内或该作用域内。 1234567891011121314151617class People { public People() { }}class Man { public Man() { } public People getWomen() { class Women extends People { int age = 11; } return new Women(); }} 匿名内部类匿名内部类的使用一般是用来编写事件监听代码。同样匿名内部类不能有访问修饰符和static修饰符。匿名内部类主要用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或重写。 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类名前面添加了static关键字，静态内部类是不需要依赖外部类的。并且它不能使用外部类的非static成员变量或方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员变量必须依赖于具体的对象。 123456789101112131415161718192021public class Main { public static void main(String[] args) { Outer.Inner inner = new Outer.Inner(); }}class Outer { private Inner inner = null; public Outer() { } static class Inner { public Inner() { } }} 闭包（closure）和回调 闭包的价值在于可以作为函数对象或者匿名函数，持有上下文数据，作为第一级对象进行传递和保存。 闭包广泛用于回调函数、函数式编程中。 Java中，闭包是通过“接口+内部类”实现，Java内部类也可以有匿名内部类。 闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部类对象（创建内部类的作用域）的信息，还自动拥有指向外部类对象的引用，在此作用域内，内部类有权操作所有的成员。 12345678910111213141516171819202122232425262728293031323334class Writer{ void work(){};}interface programmer{ void work();}class WriterProgrammer extends Writer{ @Override void work() { super.work(); } void code(){ // } programmer getProgrammer(){ return new ProgrammerInner(); } public static void main(String[] args) { WriterProgrammer writerProgrammer = new WriterProgrammer(); writerProgrammer.getProgrammer().work(); } class ProgrammerInner implements programmer{ @Override public void work() { code(); } }} 参考资料https://www.cnblogs.com/dolphin0520/p/3811445.html https://www.cnblogs.com/tiancai/p/7350464.html","link":"/2017/10/16/Java笔记/Java内部类详解/"},{"title":"Rxjava操作符：第3篇 Flitering Observable","text":"本文基于Rxjava 2.x版本,介绍用于 Observable 过滤发射项目的操作符。 Operators that selectively emit items from a source Observable. Debounce — only emit an item from an Observable if a particular timespan has passed without it emitting another item 如果特定的时间跨度已经过去而没有发出另一个项目，则只从Observable中发出一个项目 Distinct — suppress duplicate items emitted by an Observable 过滤重复发射源 ElementAt — emit only item n emitted by an Observable 仅发出方法中指定的发射源 Filter — emit only those items from an Observable that pass a predicate test 仅发出符合过滤条件的发射源 First — emit only the first item, or the first item that meets a condition, from an Observable 仅保留发射序列的第一个发射源 IgnoreElements — do not emit any items from an Observable but mirror its termination notification 忽略发射序列的所有元素，只会响应 onComplete 方法 Last — emit only the last item emitted by an Observable 仅保留发射序列的最后一个发射源 Sample — emit the most recent item emitted by an Observable within periodic time intervals 取每个时间周期内的最后一个发射源。 Skip — suppress the first n items emitted by an Observable 跳过起始位置的 n 个发射源 SkipLast — suppress the last n items emitted by an Observable 跳过终点位置的 n 个发射源 Take — emit only the first n items emitted by an Observable 保留起始位置的 n 个发射源 TakeLast — emit only the last n items emitted by an Observable 保留终点位置的 n 个发射源 debounce 操作符当发射源 Emitter#onNext 方法发射间隔小于 debounce 方法指定间隔，取时间间隔有交集的最后一个发射源。在当前指定时间周期内只有一个发射源的时候，直接发出该发射源，如果指定时间周期出现多个发射源，取周期内最后一个发射源发出，其他的发射源过滤掉。根据下面的 debounce 图解可以得知，debounce 周期随发射源发出开始计算。注意和 sample 操作符区别 1234567891011121314151617181920212223242526272829303132333435363738// Diagram:// -A--------------B----C-D-------------------E-|----&gt;// a---------1s// b---------1s// c---------1s// d---------1s// e-|----&gt;// -----------A---------------------D-----------E-|--&gt;Observable&lt;String&gt; source = Observable.create(emitter -&gt; { emitter.onNext(\"A\"); Thread.sleep(1_500); emitter.onNext(\"B\"); Thread.sleep(500); emitter.onNext(\"C\"); Thread.sleep(250); emitter.onNext(\"D\"); Thread.sleep(2_000); emitter.onNext(\"E\"); emitter.onComplete();});source.subscribeOn(Schedulers.io()) .debounce(1, TimeUnit.SECONDS) .blockingSubscribe( item -&gt; System.out.println(\"onNext: \" + item), Throwable::printStackTrace, () -&gt; System.out.println(\"onComplete\"));// prints:// onNext: A// onNext: D// onNext: E// onComplete distinct 操作符过滤重复的发射项目 123456789Observable.just(2, 3, 4, 4, 2, 1) .distinct() .subscribe(System.out::println);// prints:// 2// 3// 4// 1 elementAt 操作符获取指定发射序列上某条数据 12345678910Observable&lt;Long&gt; source = Observable.&lt;Long, Long&gt;generate(() -&gt; 1L, (state, emitter) -&gt; { emitter.onNext(state); return state + 1L;}).scan((product, x) -&gt; product * x);Maybe&lt;Long&gt; element = source.elementAt(5);element.subscribe(System.out::println);// prints 720 filter 操作符过滤非函数判断指定的发射序列 12345678Observable.just(1, 2, 3, 4, 5, 6) .filter(x -&gt; x % 2 == 0) .subscribe(System.out::println);// prints:// 2// 4// 6 first 操作符取发射序列的第一个发射源，和 last 操作符对应。first 方法中参数为指定默认值。 123456Observable&lt;String&gt; source = Observable.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);Single&lt;String&gt; firstOrDefault = source.first(&quot;D&quot;);firstOrDefault.subscribe(System.out::println);// prints A ignoreElement 操作符忽略被观察者发射序列携带的数据，返回值为 Completable&lt;T&gt; ，只调用 onComplete 方法 12345678Observable&lt;Long&gt; source = Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS);Completable completable = source.ignoreElements();completable.doOnComplete(() -&gt; System.out.println(\"Done!\")) .blockingAwait();// prints (after 5 seconds):// Done! last 操作符去发射序列最后一个发射源，last 方法参数为默认值 123456Observable&lt;String&gt; source = Observable.just(\"A\", \"B\", \"C\");Single&lt;String&gt; lastOrDefault = source.last(\"D\");lastOrDefault.subscribe(System.out::println);// prints C sample 操作符从指定的时间周期中取最后一个发射源。与 debounce 操作符的区别是，sample 操作符的时间周期是独立的。 123456789101112131415161718192021222324252627282930313233// Diagram:// -A----B-C-------D-----E-|--&gt;// -0s-----c--1s---d----2s-|--&gt;// -----------C---------D--|--&gt;Observable&lt;String&gt; source = Observable.create(emitter -&gt; { emitter.onNext(\"A\"); Thread.sleep(500); emitter.onNext(\"B\"); Thread.sleep(200); emitter.onNext(\"C\"); Thread.sleep(800); emitter.onNext(\"D\"); Thread.sleep(600); emitter.onNext(\"E\"); emitter.onComplete();});source.subscribeOn(Schedulers.io()) .sample(1, TimeUnit.SECONDS) .blockingSubscribe( item -&gt; System.out.println(\"onNext: \" + item), Throwable::printStackTrace, () -&gt; System.out.println(\"onComplete\"));// prints:// onNext: C// onNext: D// onComplete skip 操作符指定从起始位置跳过 n 个发射源后继续发射 123456789101112Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.skip(4) .subscribe(System.out::println);// prints:// 5// 6// 7// 8// 9// 10 skipLast 操作符指定跳过终点位置的 n 个发射源 123456789101112Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.skipLast(4) .subscribe(System.out::println);// prints:// 1// 2// 3// 4// 5// 6 take 操作符和 skip 操作符相反操作，指定保留从起始位置发射的 n 个发射源 12345678910Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.take(4) .subscribe(System.out::println);// prints:// 1// 2// 3// 4 takeLast 操作符和 skipLast操作符相反，保留从终点位置发射的 n 个发射源 12345678910Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);source.takeLast(4) .subscribe(System.out::println);// prints:// 7// 8// 9// 10 参考文章： https://github.com/ReactiveX/RxJava/wiki/Filtering-Observables","link":"/2019/06/20/Rxjava笔记/第3篇 Flitering Observables/"},{"title":"Android预览pdf文档","text":"谷歌为我们提供了PdfRender工具类对pdf文档进行渲染，首先看一下PdfRender的构造方法： 123456789101112131415161718192021222324/** * Creates a new instance. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; The provided file descriptor must be &lt;strong&gt;seekable&lt;/strong&gt;, * i.e. its data being randomly accessed, e.g. pointing to a file. * &lt;/p&gt; * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; This class takes ownership of the passed in file descriptor * and is responsible for closing it when the renderer is closed. * &lt;/p&gt; * &lt;p&gt; * If the file is from an untrusted source it is recommended to run the renderer in a separate, * isolated process with minimal permissions to limit the impact of security exploits. * &lt;/p&gt; * * @param input Seekable file descriptor to read from. * * @throws java.io.IOException If an error occurs while reading the file. * @throws java.lang.SecurityException If the file requires a password or * the security scheme is not supported. */public PdfRenderer(@NonNull ParcelFileDescriptor input){ //略...} 可以看构造方法中的参数是ParcelFileDescriptor的一个实例，那么ParcelFileDescriptor类是做什么的呢？ParcelFileDescriptor是Android 提供的一种数据结构，支持数据的写入和写出。我们通过ParcelFileDescriptor#open 建立文件和ParcelFileDescriptor的联系 1234567891011121314151617181920/** * Create a new ParcelFileDescriptor accessing a given file. * * @param file The file to be opened. * @param mode The desired access mode, must be one of * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or * {@link #MODE_READ_WRITE}; may also be any combination of * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE}, * {@link #MODE_WORLD_READABLE}, and * {@link #MODE_WORLD_WRITEABLE}. * @return a new ParcelFileDescriptor pointing to the given file. * @throws FileNotFoundException if the given file does not exist or can not * be opened with the requested mode. * @see #parseMode(String) */ public static ParcelFileDescriptor open(File file, int mode) throws FileNotFoundException { final FileDescriptor fd = openInternal(file, mode); if (fd == null) return null; return new ParcelFileDescriptor(fd); } 从该方法中可以看出ParcelFileDescriptor#open实际操作的是FileDescriptor，仔细阅读FileDescriptor的注释，FileDescriptor是文件操作符。FileDescriptor可以用来表示开放文件、开放套接字。以FileDecriptor 表示文件来说，当FileDescroptor表示某文件 时，我们可以通俗的将FileDescriptor看成是该文件。但是，我们不能直接通过FileDescription对该文件进行操作；若需要通过FileDescriptor对该文件进行操作，则需要新创建FileDescriptor对应的FileOutputSteam，再对文件进行操作。这里有对FileDescription的详细描述。 12345678 ParcelFileDescriptor mFileDescriptor; PdfRenderer mPdfRenderer; //根据文件对象创建mFileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY); // This is the PdfRenderer we use to render the PDF. if (mFileDescriptor != null) { mPdfRenderer = new PdfRenderer(mFileDescriptor); } 打开pdf指定页面和生成当前页面的Bitmap展示： 12345678910111213141516171819202122private PdfRenderer.Page mCurrentPage;private void showPage(int index) { if (mPdfRenderer.getPageCount() &lt;= index) { return; } // Make sure to close the current page before opening another one. if (null != mCurrentPage) { mCurrentPage.close(); } // Use `openPage` to open a specific page in PDF. mCurrentPage = mPdfRenderer.openPage(index); // Important: the destination bitmap must be ARGB (not RGB). Bitmap bitmap = Bitmap.createBitmap(mCurrentPage.getWidth(), mCurrentPage.getHeight(),Bitmap.Config.ARGB_8888); // Here, we render the page onto the Bitmap. // To render a portion of the page, use the second and third parameter. Pass nulls to get // the default result. // Pass either RENDER_MODE_FOR_DISPLAY or RENDER_MODE_FOR_PRINT for the last parameter. mCurrentPage.render(bitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY); // We are ready to show the Bitmap to user. mImageView.setImageBitmap(bitmap); updateUi();} 完整实例： 页面R.layout.fragment_pdf_renderer_basic： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".PdfRendererBasicFragment\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:background=\"@android:color/white\" android:scaleType=\"fitCenter\" android:contentDescription=\"@null\"/&gt; &lt;LinearLayout style=\"?android:attr/buttonBarStyle\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:measureWithLargestChild=\"true\" android:orientation=\"horizontal\"&gt; &lt;Button android:id=\"@+id/previous\" style=\"?android:attr/buttonBarButtonStyle\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"@string/previous\" /&gt; &lt;Button android:id=\"@+id/next\" style=\"?android:attr/buttonBarButtonStyle\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"@string/next\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 渲染pdf代码，pdf文档来源于asset目录下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208public class PdfRendererBasicFragment extends Fragment implements View.OnClickListener { /** * Key string for saving the state of current page index. */ private static final String STATE_CURRENT_PAGE_INDEX = \"current_page_index\"; /** * The filename of the PDF. */ private static final String FILENAME = \"sample.pdf\"; /** * File descriptor of the PDF. */ private ParcelFileDescriptor mFileDescriptor; /** * {@link android.graphics.pdf.PdfRenderer} to render the PDF. */ private PdfRenderer mPdfRenderer; /** * Page that is currently shown on the screen. */ private PdfRenderer.Page mCurrentPage; /** * {@link android.widget.ImageView} that shows a PDF page as a {@link android.graphics.Bitmap} */ private ImageView mImageView; /** * {@link android.widget.Button} to move to the previous page. */ private Button mButtonPrevious; /** * {@link android.widget.Button} to move to the next page. */ private Button mButtonNext; /** * PDF page index */ private int mPageIndex; public PdfRendererBasicFragment() { } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_pdf_renderer_basic, container, false); } @Override public void onViewCreated(View view, Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); // Retain view references. mImageView = (ImageView) view.findViewById(R.id.image); mButtonPrevious = (Button) view.findViewById(R.id.previous); mButtonNext = (Button) view.findViewById(R.id.next); // Bind events. mButtonPrevious.setOnClickListener(this); mButtonNext.setOnClickListener(this); mPageIndex = 0; // If there is a savedInstanceState (screen orientations, etc.), we restore the page index. if (null != savedInstanceState) { mPageIndex = savedInstanceState.getInt(STATE_CURRENT_PAGE_INDEX, 0); } } @Override public void onStart() { super.onStart(); try { openRenderer(getActivity()); showPage(mPageIndex); } catch (IOException e) { e.printStackTrace(); Toast.makeText(getActivity(), \"Error! \" + e.getMessage(), Toast.LENGTH_SHORT).show(); } } @Override public void onStop() { try { closeRenderer(); } catch (IOException e) { e.printStackTrace(); } super.onStop(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); if (null != mCurrentPage) { outState.putInt(STATE_CURRENT_PAGE_INDEX, mCurrentPage.getIndex()); } } /** * Sets up a {@link android.graphics.pdf.PdfRenderer} and related resources. */ private void openRenderer(Context context) throws IOException { // In this sample, we read a PDF from the assets directory. File file = new File(context.getCacheDir(), FILENAME); if (!file.exists()) { // Since PdfRenderer cannot handle the compressed asset file directly, we copy it into // the cache directory. InputStream asset = context.getAssets().open(FILENAME); FileOutputStream output = new FileOutputStream(file); final byte[] buffer = new byte[1024]; int size; while ((size = asset.read(buffer)) != -1) { output.write(buffer, 0, size); } asset.close(); output.close(); } mFileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY); // This is the PdfRenderer we use to render the PDF. if (mFileDescriptor != null) { mPdfRenderer = new PdfRenderer(mFileDescriptor); } } /** * Closes the {@link android.graphics.pdf.PdfRenderer} and related resources. * * @throws java.io.IOException When the PDF file cannot be closed. */ private void closeRenderer() throws IOException { if (null != mCurrentPage) { mCurrentPage.close(); } mPdfRenderer.close(); mFileDescriptor.close(); } /** * Shows the specified page of PDF to the screen. * * @param index The page index. */ private void showPage(int index) { if (mPdfRenderer.getPageCount() &lt;= index) { return; } // Make sure to close the current page before opening another one. if (null != mCurrentPage) { mCurrentPage.close(); } // Use `openPage` to open a specific page in PDF. mCurrentPage = mPdfRenderer.openPage(index); // Important: the destination bitmap must be ARGB (not RGB). Bitmap bitmap = Bitmap.createBitmap(mCurrentPage.getWidth(), mCurrentPage.getHeight(), Bitmap.Config.ARGB_8888); // Here, we render the page onto the Bitmap. // To render a portion of the page, use the second and third parameter. Pass nulls to get // the default result. // Pass either RENDER_MODE_FOR_DISPLAY or RENDER_MODE_FOR_PRINT for the last parameter. mCurrentPage.render(bitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY); // We are ready to show the Bitmap to user. mImageView.setImageBitmap(bitmap); updateUi(); } /** * Updates the state of 2 control buttons in response to the current page index. */ private void updateUi() { int index = mCurrentPage.getIndex(); int pageCount = mPdfRenderer.getPageCount(); mButtonPrevious.setEnabled(0 != index); mButtonNext.setEnabled(index + 1 &lt; pageCount); getActivity().setTitle(getString(R.string.app_name_with_index, index + 1, pageCount)); } /** * Gets the number of pages in the PDF. This method is marked as public for testing. * * @return The number of pages. */ public int getPageCount() { return mPdfRenderer.getPageCount(); } @Override public void onClick(View view) { switch (view.getId()) { case R.id.previous: { // Move to the previous page showPage(mCurrentPage.getIndex() - 1); break; } case R.id.next: { // Move to the next page showPage(mCurrentPage.getIndex() + 1); break; } } }}","link":"/2018/04/18/Android开发笔记/Android预览pdf文档/"},{"title":"Rxjava操作符：第1篇 Creating Observables","text":"本文基于Rxjava 2.x版本,介绍用于创建 Observable 对象的操作符。 Operators that originate new Observables. Create — create an Observable from scratch by calling observer methods programmatically Defer — do not create the Observable until the observer subscribes, and create a fresh Observable for each observer Empty/Never/Throw — create Observables that have very precise and limited behavior From — convert some other object or data structure into an Observable Interval — create an Observable that emits a sequence of integers spaced by a particular time interval Just — convert an object or a set of objects into an Observable that emits that or those objects Range — create an Observable that emits a range of sequential integers Repeat — create an Observable that emits a particular item or sequence of items repeatedly Start — create an Observable that emits the return value of a function Timer — create an Observable that emits a single item after a given delay create 操作符通过 create 方法构造 Observable 对象，通过被观察者的 subcribe 方法建立起观察者与被观察者的联系。 create example 123456789Observable&lt;String&gt; observable = Observable.create(emitter -&gt; { emitter.onNext(\"Hello\"); emitter.onNext(\"World\"); emitter.onComplete(); emitter.onError(new NullPointerException());});observable.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(\"onComplete\")); defer 操作符一个允许延迟操作的操作符，直到 ObservableSource 订阅了观察者 Observer，发射源 emitting item 才会发射数据。defer会为每一个 Observer 观察者对象创建新的 Observable ，所以下面两次打印数据是不同的。而 create 操作符观察者对象无论被订阅多少次，数据都是相同的。 defer example 123456789Observable&lt;Long&gt; observable = Observable.defer(() -&gt; { long time = System.currentTimeMillis(); return Observable.just(time);});observable.subscribe(time -&gt; System.out.println(time));Thread.sleep(1000);observable.subscribe(time -&gt; System.out.println(time));//print 1562638410886 1562638411891 empty 操作符这个操作符会生成一个没有发射数据的 Observable 对象，只会且直接调用 Observer#onComplete 方法。 empty example 1234567Observable&lt;String&gt; empty = Observable.empty();empty.subscribe( v -&gt; System.out.println(\"This should never be printed!\"), error -&gt; System.out.println(\"Or this!\"), () -&gt; System.out.println(\"Done will be printed.\"));//print Done will be printed. never 操作符never 操作符不会调用观察者对象的 onNext、onComplete 或者 onError 方法，它主要用来测试或者禁用组合操作符中的某些 Observable 对象。 never example 123456Observable&lt;String&gt; never = Observable.never();never.subscribe( v -&gt; System.out.println(\"This should never be printed!\"), error -&gt; System.out.println(\"Or this!\"), () -&gt; System.out.println(\"This neither!\")); error 操作符error 操作符只会调用 Observer#error 方法，常见 error 使用场景： error example 123456789101112131415161718Observable&lt;String&gt; results = Observable.fromCallable((Callable&lt;String&gt;) () -&gt; { if (Math.random() &lt; 0.5) { throw new IOException(); } throw new IllegalArgumentException();}).onErrorResumeNext(error -&gt; { if (error instanceof IllegalArgumentException) { return Observable.empty(); } return Observable.error(error);});for (int i = 0; i &lt; 10; i++) { results.subscribe( v -&gt; System.out.println(\"This should never be printed!\"), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\"));} from 操作符fromIterable 操作符根据 Iterable （类似 List，Set，Collection 等） 对象创建可观察者模型。 fromIterable example 123456List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));Observable&lt;Integer&gt; observable = Observable.fromIterable(list);observable.subscribe(item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\")); fromArray 操作符根据数组创建可观察者模型。 123456789Integer[] array = new Integer[10];for (int i = 0; i &lt; array.length; i++) { array[i] = i;}Observable&lt;Integer&gt; observable = Observable.fromArray(array);observable.subscribe(item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\")); fromCallable 操作符当订阅事件发生，Callable中的方法会被调用，返回值会转发至观察者。 12345678910Callable&lt;String&gt; callable = () -&gt; { System.out.println(\"Hello World!\"); return \"Hello World!\";};Observable&lt;String&gt; observable = Observable.fromCallable(callable);observable.subscribe(item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\"));//print Hello World! Hello World! Done fromAction 操作符//待验证… 12345Action action = () -&gt; System.out.println(\"Hello World!\");Completable completable = Completable.fromAction(action);completable.subscribe(() -&gt; System.out.println(\"Done\"), error -&gt; error.printStackTrace()); fromRunnable 操作符//待验证… 12345Runnable runnable = () -&gt; System.out.println(&quot;Hello World!&quot;);Completable completable = Completable.fromRunnable(runnable);completable.subscribe(() -&gt; System.out.println(&quot;Done&quot;), error -&gt; error.printStackTrace()); fromFuture 操作符给定预先存在的，已经运行或已经完成的java.util.concurrent.Future，等待Future正常完成或以阻塞方式使用异常并将生成的值或异常转发给使用者。 123456789101112ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();//延迟1秒Future&lt;String&gt; future = executor.schedule(() -&gt; \"Hello world!\", 1, TimeUnit.SECONDS);Observable&lt;String&gt; observable = Observable.fromFuture(future);observable.subscribe( item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\"));executor.shutdown(); from{reactive type} 操作符//待验证… 12345678Flux&lt;Integer&gt; reactorFlux = Flux.fromCompletionStage(CompletableFuture.&lt;Integer&gt;completedFuture(1));Observable&lt;Integer&gt; observable = Observable.fromPublisher(reactorFlux);observable.subscribe( item -&gt; System.out.println(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println(\"Done\")); generate 操作符//待验证… 12345678int startValue = 1;int incrementValue = 1;Flowable&lt;Integer&gt; flowable = Flowable.generate(() -&gt; startValue, (s, emitter) -&gt; { int nextValue = s + incrementValue; emitter.onNext(nextValue); return nextValue;});flowable.subscribe(value -&gt; System.out.println(value)); interval 操作符interval操作符指定定时发送发出数据的时间间隔，interval 有多个重载方法，最终都会调用下面的方法： 123456789101112131415/** * @param initialDelay 发射第一条数据的延迟时间 * @param period 其它数据的延迟发射周期 * @param unit 时间单位 * @param scheduler 任务调度器 */@CheckReturnValue@NonNull@SchedulerSupport(SchedulerSupport.CUSTOM)public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) { ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); return RxJavaPlugins.onAssembly(new ObservableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));} interval()的其它重载方法默认不设置 initialDleay 值时，initialDelay 的值将和 period 值保持一致，默认的调度器 Schedulers.computation()。在 java 中使用默认调度器的时候，interval 方法不会正常执行，程序会自动退出。interval 方法指定线程是未阻塞的，并不会阻止 JVM 退出程序。指定调度器 trampoline() 延长程序存活时间，interval 方法会正常执行。在Android中程序是在活跃的，不需要指定调度器。问题详情见 Rxjava issue interval example 12345678Observable&lt;Long&gt; clock = Observable.interval(1, TimeUnit.SECONDS, Schedulers.trampoline());clock.subscribe(time -&gt; { if (time % 2 == 0) { System.out.println(\"Tick\"); } else { System.out.println(\"Tock\"); }}); just 操作符根据 just 方法中顺序依次发射数据到下游观察者对象，just 方法可定义 1~9 个参数，但参数类型应保持一致。 just example 12345Observable&lt;Object&gt; observable = Observable.just(\"1\", \"A\", \"3.2\", \"def\"); observable.subscribe(item -&gt; System.out.print(item), error -&gt; error.printStackTrace(), () -&gt; System.out.println());//print 1A3.2def range 操作符发出指定范围的整数队列值，调用的是 onNext 方法。 range example 123456789String greeting = \"Hello World!\";Observable&lt;Integer&gt; indexes = Observable.range(0, greeting.length());Observable&lt;Character&gt; characters = indexes .map(index -&gt; greeting.charAt(index));characters.subscribe(character -&gt; System.out.print(character), error -&gt; error.printStackTrace(), () -&gt; System.out.println()); timer 操作符timer(long, TimeUnit) 方法指定延迟时间发射出指定数据，不重复发出。 timer example 123Observable&lt;Long&gt; eggTimer = Observable.timer(5, TimeUnit.MINUTES);eggTimer.blockingSubscribe(v -&gt; System.out.println(&quot;Egg is ready!&quot;)); 参考文章： https://github.com/ReactiveX/RxJava/wiki/Creating-Observables","link":"/2019/06/18/Rxjava笔记/第1篇 Creating Observables/"},{"title":"Java基础知识点","text":"面向过程编程和面向对象编程的区别在于：面向过程编程强调的是整个软件系统由一个个函数构成，最小的程序单元是函数，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统的设计。 面向对象的设计是使所需要的对象具备某些功能，强调的是具备某些功能的对象。面向对象主要有三大特征：封装（Encapsulation），继承（Inheritance），多态（Polymorphism）。 面向对象的特征 封装：封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的”高内聚、低耦合“，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。 继承: 继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。 多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行时才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能确定。多态性增强了程序的灵活性和扩展性。 接口和抽象类区别接口的特点： 接口中的方法，永远都被public来修饰 接口中没有构造方法，也不能实例化接口对象 接口中只有方法的声明，没有方法体 接口中只有常量，如果定义变量，在编译的时候会默认加上“public static final” 接口中定义的方法都需要实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需定义为抽象类 静态方法不能被子类覆盖（隐藏），因此接口中不定声明静态方法 使用接口可以实现多继承 抽象类关键字和哪些关键字不能共存？ final：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。 private：抽象类中的私有的抽象方法，不被子类所致，就无法被复写。而抽象方法出现的就是需要被复写。 static：如果static可以修饰抽象方法，直接类名调用就可以了。 抽象类的特点 如果一个类中有抽象方法，那么这个类一定是抽象类 抽象类中不一定有抽象方法 抽象类中的所有抽象方法需要有子类实现，如果子类不实现，则子类也需要定义为抽象的 抽象类不可以用new创建对象，因为调用抽象方法没意义 权限修饰符public: 任何地方都可以访问 protected: 同包中的类和不同包的子类中可以访问，但是protected关键字不可以修饰类名 default：缺省包只有相同包和相同包下的子类可以访问。 private: 本类内可以访问。 对象生命周期创建阶段（Created）、应用阶段（In Use）、不可见阶段（Invisible）、不可达阶段（Unreachable）、收集阶段（collected）、终结阶段（Finalized）、对象空间重分配阶段（De-allocated）。 static 关键字 在静态方法中不能直接访问实例方法和实例变量 在静态方法中不能使用this和super关键字 静态方法不能被abstract修饰 当类被加载时，静态代码块只能被执行一次。 静态属性和静态方法能被继承吗？静态方法是否能被重写呢？ 静态属性和静态方法可以被继承和重写，但无法实现多态。 final 关键字 final 变量必须被显式初始化，并且只能被赋一次值 final 修饰基本类型变量的时候，该变量不能重新赋值 final 修饰引用类型变量的时候，该变量不能重新指向其他对象 final 修饰的方法为最终的方法，该方法不能被重写 private 类型的方法都默认为是final方法，因而也不能被子类重写 final修饰的类为最终的类，不能被继承。 八大基本数据类型&amp;引用类型基本数据类型： 简单类型 boolean byte char short int long float double void 二进制位数 1 8 16 16 32 64 32 64 - 封装器类 Boolean Byte Character Short Integer Long Float Double Void 引用类型： Java有5种引用类型（对象类型）：类 接口 数组 枚举 标注 堆内存和栈内存详解Java 把内存分为两种，一种叫做栈内存，一种叫做堆内存 1String s; 这里创建对象的引用，并非对象。直接使用会报错，因为没有赋值-指向任何对象。 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。 ​ 堆内存：用于存放由new创建的对象或数组。在堆中分配的内存，有java虚拟机自动回收器来管理。在堆中产生一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的别名或者代号。 ​ 引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组&amp;对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的对象，这就是Java中的指针。 总结： 栈内存中保存的是对象的引用，而Java对象保存在堆内存上。 参考资料 https://blog.csdn.net/Xk632172748/article/details/51755438 https://www.cnblogs.com/xiaoxi/p/6392154.html https://blog.csdn.net/u014266877/article/details/54374867","link":"/2017/10/10/Java笔记/Java基础知识点/"},{"title":"Java异常详解","text":"摘要 (来自于 Java编程思想) Java 的基本理念是“结构不佳的代码不能运行”。 改进的错误恢复机制是提高代码健壮性的最强有力的方式。错误恢复在我们所编写的每一个程序中都是基本的要素，但是在 Java 中它显得格外重要，因为 Java 的主要目标之一就是创建供他人使用的程序构件。发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。然而，编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。这就需要错误源能通过某种方式，把适当的信息传递给某个接受者–该接受者将知道如何正确处理这个问题。 异常往往能降低错误代码的复杂度的。如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它。而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误。总结，与普通的错误处理方法相比，异常处理方式使程序更加简洁、清晰，同时方便我们定位错误和处理错误。 Java 异常分类 所有异常的父类都是Throwable。 Error表示Java系统中出现了一个非常严重的异常错误，并且这个错误可能是应用程序所不能恢复的，例如LinkageError，或 ThreadDeath 等。 Java Exception和Error区别Exception: 可以是可被控制（checked）或者不可控制（unchecked）； 表示一个有程序员导致的错误； 应该在应用程序级被处理； Error: 总是不可控制的（unchecked）； 经常用来表示系统错误或者底层资源错误； 如果可能的话，应该系统级被捕捉； Java 检查异常、非检查异常、运行时异常、非运行时异常的区别Java的异常（Throwable，Exception和Error的父类）分为检查异常和非检查的异常。 检查异常： 就是编译器要求你必须处理的异常。比如我们在编程某个文件的读写时，编译器要求你必须对某段代码进行try…catch…或者throws exception，这就是检查异常。即在程序运行之前，编译器就会要求处理的异常被称为检查异常。 检查异常包括除了RuntimeException与其派生类（子类），以及错误（Error）之外，其它差不多都是检查异常。 非检查异常： 编译器不要求强制处置的异常，虽然可能出现错误，但是我不会在编译的时候检查。这类异常我们一般是不处理的，因为很难判断会出现什么问题，而且有些异常你也无法在编译时处理，比如空指针。 非检查异常包括 RuntimeException及其子类，以及错误（Error） Exception异常进行划分，它可分为运行时异常和非运行时异常 运行时异常： 都是RuntimeException类及其子类异常，如NullpointerException(空指针异常)、IndexArrayOutRangeException(下标越界异常)等，这些异常都是非检查异常，程序可以选择捕获处理，也可以不处理。这些异常一般有程序逻辑错误引起，程序应该尽可能从逻辑角度避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现运行时异常，即使没有try…catch…捕获它，也没有throws声明抛出它，也会编译通过。 常见的运行时异常：NullPointerException、ArrayIndexOutOfBoundsException、IndexOutOfBoundsException、ArrayIndexOutOfBoundsException、NumberFormatException、IllegalArgumentException等等。 非运行时异常： 是RuntimeException意外的异常，类型上都属于Exception类及其子类。属于必须在编译时处理的异常，否则就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况不要自定义检查异常。 Java 自定义异常用户自定义异常属于非运行时异常，需要在程序编译时处理。 1234567891011121314151617181920212223242526272829public class Main { public static void main(String[] args) { try { new Main().age(16); } catch (IllegalAgeException e) { e.printStackTrace(); } } private void age(int age) throws IllegalAgeException{ if (age &lt; 18) { throw new IllegalAgeException(\"\"); } System.out.println(\"age = [\" + age + \"]\"); }}class IllegalAgeException extends Exception { public IllegalAgeException() { this(\"\"); } public IllegalAgeException(String message) { super(\"年龄不合法\"); }} Java throw关键字和throws关键字区别 throws抛出的是可能出现的异常，需要用户手动处理异常，throw是明确程序这个地方需要抛出指定的异常对象。 throws出现在方法函数头；而throw出现在函数体。 throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定报出了某种异常。 两种都是消极处理异常的方式，这里的消极并不是说这种方式不好，只是抛出或者可能抛出异常，但是不会有函数本身去处理异常，真正的处理异常由函数的上层调用处理。12345678throw 语法： throw 异常对象 throw new IllegalArgumentException(\" u can't ...\");throws 是方法可能会抛出的异常的声明。throws 语法： [(修饰符)(返回值)(方法名)([参数列表])[thows (异常类)]{...} public void doA(int a) throws ExceptionA{....} 捕获异常try{}catch{}finally{} 常见使用形式： 12345try{} catch{}try{} finally{}try{} catch{} finally{} finally 关键字的特点及作用 特点被 finally 控制的语句一定会执行。特殊情况：在执行到finally之前jvm推出了（比如System.exit(0)），finally块语句将不会被执行 作用 一般在IO流操作或者数据库操作最后释放资源。 即使有return关键字，程序也会在返回之前执行finally代码块。 123456789101112 public static void main(String[] args) { try { System.out.println(1/0); }catch (Exception e){ System.out.println(\"除数不可以为0\");// System.exit(0);//退出JVM虚拟机 return; }finally { System.out.println(\"看看执行了没有\"); } } 打印结果： 除数不可以为0 看看执行了没有 Process finished with exit code 0 参考资料https://www.cnblogs.com/yiwangzhibujian/p/7141390.html https://www.cnblogs.com/sishuiliuyun/p/4421767.html https://www.cnblogs.com/oukele/p/10035238.html 《Java编程思想》","link":"/2017/10/17/Java笔记/Java异常详解/"},{"title":"Java线程详解","text":"并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务（也被称为子任务）中的每一个都将执行线程来驱动。一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以用于多个并发执行的任务，但是你的程序使得每个任务都好像有自己的CPU一样。其底层机制是切分CPU时间，但通常你不需要考虑它。 线程的生命周期线程的生命周期主要有五种状态：新建（New）、就绪（Runable）、运行（Running）、阻塞（Blocking）和死亡（Death）。 线程在运行过程中，不可能一直占用CPU，CPU会在多个线程之前来回切换，所以线程的状态也会随时在运行和阻塞状态切换： 新建状态，使用 New 关键字创建线程对象，线程就处于新建状态。此时仅由JVM分配内存空间，初始化其变量。 就绪状态，调用Thread#start方法，线程处于就绪状态。JVM虚拟机会为其创建方法调用栈和程序计数器，等待CPU调度进入运行状态。 运行状态，CPU准备就绪，调用Thread#run方法执行方法体，此时线程处于运行状态。 阻塞状态，处于运行状态的线程失去CPU为其分配的资源，线程进入阻塞状态。 死亡状态，线程执行正常结束或因抛出Exception或Error而终止，线程进入死亡状态。 终止线程的三个方法 通过线程run方法中标志位实现 使用Thread#stop方法实现，这个方法不推荐使用。（因为与suspend、resume一样可能出现意料以外的情况。 使用Thread#interrupt方法终止线程 volatile的作用以及用法volatile关键字让程序每次都在主存获取变量，而不是从各个线程的工作内存获取。 volatile具有synchronized关键字的可见性，但是没有synchronized关键字的并发正确性，也就是说不能保证线程执行的顺序性。每个工作线程都可以获取当前volatile变量的最新值，但是volatile变量并不能保证并发的正确性。volatile关键字并不能保证操作的原子性。 参考资料 https://www.cnblogs.com/sunddenly/p/4106562.html https://www.cnblogs.com/sunrunzhi/p/3930297.html","link":"/2017/10/21/Java笔记/Java线程详解/"},{"title":"Java集合详解","text":"通常，程序总是根据运行时才知道的某些条件去创建新的对象。在此之前，无法知道所需对象的数量甚至确切类型。为了解决这个普遍的编程问题，需要在任一时刻和任意位置创建任意数量的对象。因此，不能依靠创建命名的引用来持有每一个对象：MyType aReference ，因为从来不会知道实际需要多少个这样的引用。Java 中有多种方式保存对象（准确来说是对象的引用）。数据是 Java 中保存一组对象最有效的方式，如果想要保存一组基本类型数据，也推荐使用数组。但是数组具有固定的大小尺寸，而且在更一般的情况下，在写程序的时候并不知道需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制就显得太过受限了。 *java.util * 库提供了一套相对完整的集合类（collection classes）来解决这个问题，其中基本类型有 List、Set、Queue 和 Map。这些类型也被称作容器类（container classes）。Set 对于每个值都只保存一个对象，Map 是一个关联数组，允许将某些对象和其他对象关联起来。Java 集合类都可以自动调整自己的大小。 基本概念Java集合分类体系图（包括抽象类和遗留构件，不包括Queue）： Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口： 集合（Collection）：一个独立元素的序列，这些元素都服从一条或多条规则。List 必须以插入的顺序保存元素，Set 不能包含重复元素，Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。 映射（Map）：一组成对的“键值对”对象，允许使用键来查找值。ArrayList 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 map 允许我们使用一个对戏那个来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起；或者称作字典（dictionary），因此可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。Map 是强大的编程工具。 Collection&amp;Map区别 Collection 和 Map 接口之间的主要区别在于：Collection中存储了一组对象，而 Map 中存储关键字键/值对。Collection 接口，包含 list 和 set 子接口；继承 Map 的类有HashMap，HashTable。Map 中每一个关键字最多有一个关联的值。不能包括两个相同的键，一个键最多能绑定一个值。null可以作为键，这样的键值可以有一个。当get()方法返回null值时，即可以表示Map中没有该键，也可以表示该键对应的值为null。所以不可以通过get()方法判断Map中的某个键是否存在，而应该通过containsKey()方法来判断。Map中提供三种集合的视图，Map的内容可以被当作一组key集合，一组value集合和一组key-value的映射。 浅拷贝&amp;深拷贝浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。 深拷贝的实现方式：使用JSON拷贝、序列化或者重写clone方法并遍历。","link":"/2017/10/24/Java笔记/Java集合详解/"},{"title":"Java运行环境","text":"操作系统（OS）是管理计算机硬件和软件资源的系统软件，为计算机程序提供公共服务。分时操作系统可以有效地使用系统，还可以包括处理器处理器事件、海量存储、打印和其他资源的成本分配的会计软件。对于诸如输入输出和内存分配这样的硬件功能，操作系统充当了程序和计算机硬件之间的中介，尽管应用程序代码通常是由硬件直接执行的，并且常常使系统调用一个OS函数或被它中断。在许多设备上都有操作系统，这些设备包括电脑—-从手机和视频游戏机到网络服务器和超级计算机。Android是一种基于Linux的自由及开发源代码的操作系统。 什么是线程，什么是进程？进程是系统进行资源分配的独立单元，它的特点如下： 进程是程序的一次执行过程。若程序执行两次甚至多次，则需要两个甚至多个进程。进程是正在运行程序的抽象。它代表运行的CPU，也称进程是对CPU的抽象（虚拟技术的支持，将一个CPU变换为多个虚拟的CPU）。系统资源（如内存、文件）以进程为单位分配，操作系统为每个进程分配了独立的地址空间，操作系统通过”调用”把控制权交给进程，线程是CPU调度的基本单元。 线程和进程的区别： 定义方面：进程是程序在某个数据集合上的一次运行活动；线程是进程中的一个执行路径。（进程可以创建多个线程） 角色方法：在支持线程机制的系统中，进程是系统资源分配的单位，线程是CPU调度的单位 资源共享方面：进程之间不能共享资源，而线程共享所在进程的地址空间和其他资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。 独立性方面：进程有自己独立的地址空间，而线程没有，线程必须依赖进程而存在。 开销方面。进程切换的开销较大。线程相对较小。（引入线程的原因是处于系统进程开销的考虑） JDK&amp;JVM&amp;JRE分别是什么以及他们的区别？JDK：JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。JDK中包含了JRE，在JDK安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib目录下则是jvm虚拟机工作所需要的类库，而jvm和lib和起来就称为jre。JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（java/java/jdb等）和Java基础的类库（即Java API包括rt.jar）。 JRE：是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将开发的程序发布到用户手中，让用户使用。JRE中包含了Java virtual machine(JVM)，runtime class libraries和Java application launcher，这些都是运行Java程序的必要组件。与大家熟悉的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对使用Java程序的用户。 JVM：就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有java程序会受限编译为.class的类文件，这种类文件可以在虚拟机上运行。也就是说class并不直接机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包包含lib类库。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行上的目标代码（字节码），就可以在多个平台上不加修改地运行。 三者的关系：JDK&gt;JRE&gt;JVM","link":"/2017/10/01/Java笔记/Java运行环境/"},{"title":"Rxjava操作符：第4篇 Combining Observables","text":"本文基于Rxjava 2.x版本,介绍用于操作多个 Observable 对象的操作符。 Operators that work with multiple source Observables to create a single Observable And/Then/When — combine sets of items emitted by two or more Observables by means of Patternand Plan intermediaries CombineLatest — when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function Join — combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable Merge — combine multiple Observables into one by merging their emissions StartWith — emit a specified sequence of items before beginning to emit the items from the source Observable Switch — convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables Zip — combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function startWith操作符在 Observable 序列发送之前添加起始位置指定发送的 Observable startWith Example 1234Observable&lt;String&gt; names = Observable.just(\"Spock\", \"McCoy\");names.startWith(\"Kirk\").subscribe(item -&gt; System.out.println(item));// prints Kirk, Spock, McCoy merge 操作符merge 操作符 merge 操作符在用来合并多个 Observable 操作，合并的序列依次调用 Emitter#onNext() 方法执行，遇到错误序列将不继续执行。 merge Example 12345Observable.just(1, 2, 3) .mergeWith(Observable.just(4, 5, 6)) .subscribe(item -&gt; System.out.println(item));// prints 1, 2, 3, 4, 5, 6 mergeDelayError 操作符 和 merge 操作符类似，不过遇到错误会保存下来，等所有 Observable 执行完毕，再处理出现错误的Observable。注意 mergeDelayError 是静态泛型方法，只可以通过类名访问。 mergeDelayError Example 1234567Observable&lt;String&gt; observable1 = Observable.error(new IllegalArgumentException(\"\"));Observable&lt;String&gt; observable2 = Observable.just(\"Four\", \"Five\", \"Six\");Observable.mergeDelayError(observable1, observable2) .subscribe(item -&gt; System.out.println(item));// emits 4, 5, 6 and then the IllegalArgumentException (in this specific// example, this throws an `OnErrorNotImplementedException`). zip 操作符将多个 Observable 发射的数据合并起来，并生成一个Observable根据合并后的数据继续向下传递。onNext 方法只会调用一次。zip 、zipArray、zipIterable、zipWith zip Example 123456Observable&lt;String&gt; firstNames = Observable.just(\"James\", \"Jean-Luc\", \"Benjamin\");Observable&lt;String&gt; lastNames = Observable.just(\"Kirk\", \"Picard\", \"Sisko\");firstNames.zipWith(lastNames, (first, last) -&gt; first + \" \" + last) .subscribe(item -&gt; System.out.println(item));// prints James Kirk, Jean-Luc Picard, Benjamin Sisko zip 操作符 会将对应 Observable 对应的 Emitter onNext 的数据合并最后通过新生成的 Observable 发射调整后的数据。 combineLatest 操作符让两个 Obserable 序列按照最新发出的数据组合在一起生成一个 Observable 序列向下传递。 combineLatest Example 1234567891011121314151617Observable&lt;Long&gt; newsRefreshes = Observable.interval(100, TimeUnit.MILLISECONDS);Observable&lt;Long&gt; weatherRefreshes = Observable.interval(50, TimeUnit.MILLISECONDS);Observable.combineLatest(newsRefreshes, weatherRefreshes, (newsRefreshTimes, weatherRefreshTimes) -&gt; \"Refreshed news \" + newsRefreshTimes + \" times and weather \" + weatherRefreshTimes) .subscribe(item -&gt; System.out.println(item));// prints:// Refreshed news 0 times and weather 0// Refreshed news 0 times and weather 1// Refreshed news 0 times and weather 2// Refreshed news 1 times and weather 2// Refreshed news 1 times and weather 3// Refreshed news 1 times and weather 4// Refreshed news 2 times and weather 4// Refreshed news 2 times and weather 5// ... switchOnNext 操作符switchOnNext Example 12345678910111213141516171819202122Observable&lt;Observable&lt;String&gt;&gt; timeIntervals = Observable.interval(1, TimeUnit.SECONDS) .map(ticks -&gt; Observable.interval(100, TimeUnit.MILLISECONDS) .map(innerInterval -&gt; \"outer: \" + ticks + \" - inner: \" + innerInterval));Observable.switchOnNext(timeIntervals) .subscribe(item -&gt; System.out.println(item));// prints:// outer: 0 - inner: 0// outer: 0 - inner: 1// outer: 0 - inner: 2// outer: 0 - inner: 3// outer: 0 - inner: 4// outer: 0 - inner: 5// outer: 0 - inner: 6// outer: 0 - inner: 7// outer: 0 - inner: 8// outer: 1 - inner: 0// outer: 1 - inner: 1// outer: 1 - inner: 2// outer: 1 - inner: 3// ... 参考文章： https://github.com/ReactiveX/RxJava/wiki/Combining-Observables","link":"/2019/06/21/Rxjava笔记/第4篇 Combining Observables/"},{"title":"Rxjava操作符：第2篇 Transforming Observable","text":"本文基于Rxjava 2.x版本,介绍用于变换 Observable 对象的操作符。 Operators that transform items that are emitted by an Observable. Buffer — periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time 定期将Observable中的项目收集到包中并发出这些包，而不是一次发送一个项目 FlatMap — transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable 将Observable发出的项目转换为Observables，然后将这些项目的排放量变为单个Observable GroupBy — divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key 将一个Observable划分为一组Observable，每个Observable从原始Observable中发出一组不同的项目，按键组织 Map — transform the items emitted by an Observable by applying a function to each item 通过将函数应用于每个项目来转换Observable发出的项目 Scan — apply a function to each item emitted by an Observable, sequentially, and emit each successive value 将函数应用于Observable发出的每个项目，按顺序发出每个连续的值 Window — periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time 定期将Observable中的项目细分为Observable窗口并发出这些窗口，而不是一次发出一个项目 buffer 操作符 buffer 操作符是缓存多个 emiter.onNext 事件，一次发出。buffer 方法有多个重载方法，可以仔细阅读源码注释。Buffer 方法的返回值是 Observable&lt;List&lt;T&gt;&gt; 类型。 12345678Observable.range(0, 10) .buffer(4) .subscribe((List&lt;Integer&gt; buffer) -&gt; System.out.println(buffer));// prints:// [0, 1, 2, 3]// [4, 5, 6, 7]// [8, 9] cast 操作符将被观察者传递的数据转换成指定类型。注意使用 fliter 操作符过滤非指定类型数据，以避免 Java 类型转换错误 ClassCastException 。 1234567891011Observable&lt;Number&gt; numbers = Observable.just(1, 4.0, 3f, 7, 12, 4.6, 5);numbers.filter((Number x) -&gt; Integer.class.isInstance(x)) .cast(Integer.class) .subscribe((Integer x) -&gt; System.out.println(x));// prints:// 1// 7// 12// 5 concatMap 操作符ConcatMap 操作符还有很多扩展方法，concatMapCompletable、 concatMapCompletableDelayError、concatMapDelayError、 concatMapEager、concatMapEagerDelayError、concatMapIterable、 concatMapMaybe、concatMapMaybeDelayError、 concatMapSingle、concatMapSingleDelayError 等，这里主要介绍 concatMap 和 concatMapIterable 操作符。 ConcatMap 操作的是 Observable 对象，根据初始被观察者传递的数据转换成新的 Observable 向下传递。注意 ConcatMap 操作符是按照发射顺序执行的。 12345678Observable.range(0, 5) .concatMap(i -&gt; { long delay = Math.round(Math.random() * 2); return Observable.timer(delay, TimeUnit.SECONDS).map(n -&gt; i); }) .blockingSubscribe(System.out::print);// prints 01234 concatIterable 操作符concatIterable 操作符会将转换生成的 Iterable 列表数据中的每一项单独从发射源发出，且发射源数据是按照顺序发出的。 12345Observable.just(\"A\", \"B\", \"C\") .concatMapIterable(item -&gt; Arrays.asList(item,item,item)) .subscribe(System.out::println);//print AAABBBCCC flatMap 操作符作用和 concatMap 操作符类似。flatMap 操作符与 concatMap 操作符区别：flatMap 操作符不是按照发射顺序执行。这种操作符主要是需要通过源 Observable 数据 获取新的 Observable 数据时使用。例如从某请求地址获取到参数，然后根据获取到的参数请求另一地址获取最终我们需要的数据。 1234567891011121314151617Observable.just(\"A\", \"B\", \"C\") .flatMap(a -&gt; { return Observable.intervalRange(1, 3, 0, 1, TimeUnit.SECONDS) .map(b -&gt; '(' + a + \", \" + b + ')'); }) .blockingSubscribe(System.out::println);//打印顺序有可能不同//(A, 1)//(B, 1)//(C, 1)//(B, 2)//(A, 2)//(C, 2)//(B, 3)//(A, 3)//(C, 3) flatMapIterable 操作符作用和 concatMapIterable 操作符相同，会将 Iterable 列表中的值生成 Observable&lt;T&gt; 发射源。 123456789101112131415Observable.just(1, 2, 3, 4) .flatMapIterable(x -&gt; { switch (x % 4) { case 1: return Arrays.asList(\"A\"); case 2: return Arrays.asList(\"B\", \"B\"); case 3: return Arrays.asList(\"C\", \"C\", \"C\"); default: return Arrays.asList(); } }) .subscribe(System.out::print);//print ABBCCC groupBy 操作符类似 butter 操作符打包多个发射项目，但是是根据 group(key,value) 来分包的。注意groupBy操作符返回值类型是 Observable&lt;GroupedObservable&lt;K, V&gt;&gt; ，发射源 onNext方法中传递的将会是 GroupedObservable&lt;K, V&gt; 类型，而我们需要的值在每个 GroupeObservable 中，这里我们使用 concatMapSingle 操作符将每个中的数据合并生成新的 Single&lt;List&lt;T&gt;&gt; 向下传递。 123456789101112Observable&lt;String&gt; animals = Observable.just( \"Tiger\", \"Elephant\", \"Cat\", \"Chameleon\", \"Frog\", \"Fish\", \"Turtle\", \"Flamingo\");animals.groupBy(animal -&gt; animal.charAt(0), String::toUpperCase) .concatMapSingle(Observable::toList) .subscribe(System.out::println);//println//[TIGER, TURTLE]//[ELEPHANT]//[CAT, CHAMELEON]//[FROG, FISH, FLAMINGO] map 操作符直接操作发射数据，返回变换后的数据并向下游传递。 12345678Observable.just(1, 2, 3) .map(x -&gt; x * x) .subscribe(System.out::println);// prints:// 1// 4// 9 scan 操作符scan操作符实现的是一种类似累加器的功能，如下所示 partialSum 参数为之前发射数据的和。 1234567891011Observable.just(5, 3, 8, 1, 7) .scan(0, (partialSum, x) -&gt; partialSum + x) .subscribe(System.out::println);// prints:// 0// 5// 8// 16// 17// 24 window 操作符window 操作符作用和 buffer 类似，不过 window 方法的返回值是 Observable&lt;Observable&lt;T&gt;&gt; 对象，直接传递的是Observable&lt;T&gt; 对象，在订阅方法中打印的是 Observable 对象，而不是其中传递的值。通过 flatMap 方法或者其扩展方法，既可处理按照 window(connt , skip) 设置打包数据的传递。而 buffer 方法的操作符返回值类型是 Observable&lt;List&lt;T&gt;&gt;。 123456789101112131415Observable.range(1, 10) // Create windows containing at most 2 items, and skip 3 items before starting a new window. .window(2, 3) .flatMapSingle(window -&gt; { return window.map(String::valueOf) .reduce(new StringJoiner(\", \", \"[\", \"]\"), StringJoiner::add); }) .subscribe(System.out::println);// prints:// [1, 2] window 中 emitter.onNext(1); emitter.onNext(2);// [4, 5]// [7, 8]// [10] 按照参数指定的数据打包为 Observable&lt;T&gt; 对象，参数 Observable 中会调用 onNext 方法来处理每一个集合数据。因为参数类型为 Observable&lt;T&gt; , 所有订阅方法中 onNext 方法只会调用4次。 参考文章： https://github.com/ReactiveX/RxJava/wiki/Transforming-Observables","link":"/2019/06/19/Rxjava笔记/第2篇 Transforming Observable/"}],"tags":[{"name":"NIO","slug":"NIO","link":"/tags/NIO/"},{"name":"BIO","slug":"BIO","link":"/tags/BIO/"},{"name":"AIO","slug":"AIO","link":"/tags/AIO/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Android开发艺术探索","slug":"Android开发艺术探索","link":"/tags/Android开发艺术探索/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"内部类","slug":"内部类","link":"/tags/内部类/"},{"name":"闭包","slug":"闭包","link":"/tags/闭包/"},{"name":"Rxjava操作符","slug":"Rxjava操作符","link":"/tags/Rxjava操作符/"},{"name":"特征","slug":"特征","link":"/tags/特征/"},{"name":"接口","slug":"接口","link":"/tags/接口/"},{"name":"抽象","slug":"抽象","link":"/tags/抽象/"},{"name":"堆栈","slug":"堆栈","link":"/tags/堆栈/"},{"name":"基本类型","slug":"基本类型","link":"/tags/基本类型/"},{"name":"引用类型","slug":"引用类型","link":"/tags/引用类型/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"throw","slug":"throw","link":"/tags/throw/"},{"name":"throws","slug":"throws","link":"/tags/throws/"},{"name":"线程","slug":"线程","link":"/tags/线程/"},{"name":"List","slug":"List","link":"/tags/List/"},{"name":"Set","slug":"Set","link":"/tags/Set/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"操作系统","slug":"操作系统","link":"/tags/操作系统/"},{"name":"进程","slug":"进程","link":"/tags/进程/"},{"name":"jdk","slug":"jdk","link":"/tags/jdk/"},{"name":"jre","slug":"jre","link":"/tags/jre/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"}],"categories":[{"name":"java笔记","slug":"java笔记","link":"/categories/java笔记/"},{"name":"Android开发笔记","slug":"Android开发笔记","link":"/categories/Android开发笔记/"},{"name":"Android开发艺术探索笔记","slug":"Android开发艺术探索笔记","link":"/categories/Android开发艺术探索笔记/"},{"name":"gradle配置笔记","slug":"gradle配置笔记","link":"/categories/gradle配置笔记/"},{"name":"Rxjava笔记","slug":"Rxjava笔记","link":"/categories/Rxjava笔记/"}]}